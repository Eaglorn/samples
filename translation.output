crowdout/comment/mm/src/main/lsfusion/tryonline (sources: crowdin/comment/mm/src/main/lsfusion/tryonline) -> samples/mm/src/main/lsfusion/tryonline - translated files:

In samples/mm/src/main/lsfusion/tryonline/ExportItems.lsf of Category comment - Number of lines: 11; Number of occurances: 1

[OK]         		AND currentBalance(i, s); // по умолчанию записывает результат в exportFile, а свойства export* являются результатами HTTP запроса по умолчанию
 <-  по умолчанию записывает результат в exportFile, а свойства export* являются результатами HTTP запроса по умолчанию
 ->  by default writes the result to exportFile, and export* properties are the default results of the HTTP request

In samples/mm/src/main/lsfusion/tryonline/ExportShipment.lsf of Category comment - Number of lines: 21; Number of occurances: 9

[OK]     OBJECTS s=Shipment // накладная
 <-  накладная
 ->  shipment
[OK]     PROPERTIES (s) date, customer = nameCustomer, stock = nameStock // выгружаем дату, имя покупателя (с именем customer) и имя склада (с именем stock)
 <-  выгружаем дату, имя покупателя (с именем customer) и имя склада (с именем stock)
 ->  exporting the date, customer name (named customer) and warehouse name (named stock)
[OK]     PROPERTIES IN money total = (GROUP SUM quantity(ShipmentDetail d)*price(d) IF shipment(d)=s) // выгружаем общую сумму накладной в теге money
 <-  выгружаем общую сумму накладной в теге money
 ->  exporting the total shipment amount in the money tag
[OK]     OBJECTS sd=ShipmentDetail // строки накладной     
 <-  строки накладной     
 ->  shipment lines     
[OK]     FILTERS shipment(sd) = s // строки накладной из накладной
 <-  строки накладной из накладной
 ->  shipment lines from shipment
[OK]     PROPERTIES (sd) index, item = nameItem // выгружаем номер, имя товара (с именем item)
 <-  выгружаем номер, имя товара (с именем item)
 ->  exporting the number, name of the product (with the name item)
[OK]     PROPERTIES (sd) IN money price, quantity // выгружаем количество, цену в теге money
 <-  выгружаем количество, цену в теге money
 ->  exporting the quantity, price in the money tag
[OK]     PROPERTIES sum = quantity(sd) * price(sd) // выгружаем кол-во * цену (с именем sum)    
 <-  выгружаем кол-во * цену (с именем sum)    
 ->  exporting quantity * price (named sum)    
[OK]     EXPORT shipment OBJECTS s = (GROUP MAX Shipment s IF number(s) = '12345'); // выгружаем накладную с номером 12345
 <-  выгружаем накладную с номером 12345
 ->  exporting the shipment with the number 12345

In samples/mm/src/main/lsfusion/tryonline/ExportShipments.lsf of Category comment - Number of lines: 18; Number of occurances: 7

[OK]     OBJECTS s=Shipment // накладная
 <-  накладная
 ->  shipment
[OK]     PROPERTIES (s) date, customer = nameCustomer, stock = nameStock // выгружаем дату, имя покупателя (с именем customer) и имя склада (с именем stock)
 <-  выгружаем дату, имя покупателя (с именем customer) и имя склада (с именем stock)
 ->  exporting the date, customer name (named customer) and warehouse name (named stock)
[OK]     FILTERS dFrom <= date(s) AND date(s) <= dTo // накладные за заданные даты
 <-  накладные за заданные даты
 ->  shipments for specified dates
[OK]     OBJECTS sd=ShipmentDetail // строки накладной     
 <-  строки накладной     
 ->  shipment lines     
[OK]     FILTERS shipment(sd) = s // строки накладной из накладной
 <-  строки накладной из накладной
 ->  shipment lines from shipment
[OK]     PROPERTIES (sd) index, item = nameItem, price, quantity // выгружаем номер, имя товара (с именем item),  количество, цену
 <-  выгружаем номер, имя товара (с именем item),  количество, цену
 ->  exporting the number, product name (named item), quantity, price
[OK]     EXPORT shipment OBJECTS dFrom = 2019_02_20, dTo = 2019_04_28; // выгружаем накладные в заданном периоде
 <-  выгружаем накладные в заданном периоде
 ->  exporting shipments for a given period

In samples/mm/src/main/lsfusion/tryonline/FlowOperations.lsf of Category comment - Number of lines: 20; Number of occurances: 6

[OK]     LOCAL shippedTo = BOOLEAN (Item, LegalEntity); // пометки отмеченных товаров / покупателей
 <-  пометки отмеченных товаров / покупателей
 ->  tagging marked products/customers
[OK]     FOR currentBalance(Item i, Stock s) > 10 ORDER DESC name(i) DO { // для товаров / складов с остатком > 10 в порядке имен товаров
 <-  для товаров / складов с остатком > 10 в порядке имен товаров
 ->  for products/warehouses with a balance > 10 in the order of product names
[OK]         FOR stock(shipment(ShipmentDetail sd)) = s AND item(sd) = i DO // для всех строк накладных с этим товаром складом
 <-  для всех строк накладных с этим товаром складом
 ->  for all shipment lines with this item in the warehouse
[OK]             shippedTo(i, LegalEntity l) <- TRUE WHERE l = customer(shipment(sd)); // скомпилируется в shippedTo(i, LegalEntity l) <- (GROUP MAX TRUE IF stock(shipment(ShipmentDetail sd)) = s AND item(sd) = i AND l=customer(shipment(sd)));
 <-  скомпилируется в shippedTo(i, LegalEntity l) <- (GROUP MAX TRUE IF stock(shipment(ShipmentDetail sd)) = s AND item(sd) = i AND l=customer(shipment(sd)));
 ->  will be compiled to shippedTo(i, LegalEntity l) <- (GROUP MAX TRUE IF stock(shipment(ShipmentDetail sd)) = s AND item(sd) = i AND l=customer(shipment(sd)));
[OK]     IF (GROUP SUM 1 IF shippedTo(Item i, LegalEntity l)) >= 2 THEN // количество позиций >= 2
 <-  количество позиций >= 2
 ->  number of positions >= 2
[OK]         exportString() <- GROUP CONCAT name(Item i) + ' -> ' + name(LegalEntity l) IF shippedTo(i, l),',\n'; // возвращаем имена товаров / покупателей через запятую с переводом строки 
 <-  возвращаем имена товаров / покупателей через запятую с переводом строки 
 ->  returning product/customer names separated by commas with newlines 

In samples/mm/src/main/lsfusion/tryonline/HelloWorld.lsf of Category comment - Number of lines: 9; Number of occurances: 3

[OK]     exportString() <- 'Hello world!'; // свойства export* являются результатами HTTP запроса по умолчанию
 <-  свойства export* являются результатами HTTP запроса по умолчанию
 ->  export* properties are the default results of the HTTP request
[OK]     // альтернативный способ
 <-  альтернативный способ
 ->  alternative method
[OK]     // EXPORT FROM 'Hello world!'; // по умолчанию экспортирует в JSON и записывает результат как JSONFILE в exportFile 
 <-  EXPORT FROM 'Hello world!'; // по умолчанию экспортирует в JSON и записывает результат как JSONFILE в exportFile 
 ->  EXPORT FROM 'Hello world!'; // exports to JSON by default and writes the result as JSONFILE to exportFile 

In samples/mm/src/main/lsfusion/tryonline/ImportShipments.lsf of Category comment - Number of lines: 34; Number of occurances: 10

[OK] // для импорта примитивных данных, для которых нужно найти объекты в системе
 <-  для импорта примитивных данных, для которых нужно найти объекты в системе
 ->  for importing primitive data for which objects in the system need to be found
[OK]     OBJECTS s=Shipment EXTID 'shipments' // используем EXTID чтобы оставить короткое имя объекта s, но при экспорте его именем будет считаться shipments 
 <-  используем EXTID чтобы оставить короткое имя объекта s, но при экспорте его именем будет считаться shipments 
 ->  using EXTID to keep the short name of the s object, but when exporting, shipments will be considered its name 
[OK]     OBJECTS sd=ShipmentDetail EXTID 'detail' // используем EXTID чтобы оставить короткое имя объекта sd, но при экспорте его именем будет считаться detail
 <-  используем EXTID чтобы оставить короткое имя объекта sd, но при экспорте его именем будет считаться detail
 ->  using EXTID to keep the short name of the sd object, but when exporting, detail will be considered its name
[OK]     FILTERS shipment(sd) = s // автоматически заполнит shipment для detail
 <-  автоматически заполнит shipment для detail
 ->  will automatically fill shipment for detail
[OK]     FOR jsonFile = JSONFILE('\{ shipments : [ ' + // jsonFile должен / может передаваться в параметре run, {} надо escape'ить так как фигурные скобки используются в интернационализации
 <-  jsonFile должен / может передаваться в параметре run, {} надо escape'ить так как фигурные скобки используются в интернационализации
 ->  jsonFile must/can be passed in the run parameter, {} must be escaped since braces are used in internationalization
[OK]         IMPORT shipments FROM jsonFile; // тип импорта автоматически определяется из типа файла
 <-  тип импорта автоматически определяется из типа файла
 ->  import type is automatically determined from the file type
[OK]         FOR BPSTRING[9] inn = inn(Shipment s) DO { // для всех принятых inn
 <-  для всех принятых inn
 ->  for all received inn
[OK]             customer(s) <- legalEntityINN(inn); // в поставку записываем клиента с принятым INN
 <-  в поставку записываем клиента с принятым INN
 ->  writing the client to the delivery with the received INN
[OK]             stock(s) <- GROUP MAX st AS Stock; // запишем какой-нибудь склад (с максимальным id) 
 <-  запишем какой-нибудь склад (с максимальным id) 
 ->  writing some warehouse (with maximum id) 
[OK]         FOR barcode(Item item) = barcode(ShipmentDetail sd) DO // еще один способ связать примитивные данные с объектными
 <-  еще один способ связать примитивные данные с объектными
 ->  another way to bind primitive data with object data

In samples/mm/src/main/lsfusion/tryonline/Main.lsf of Category comment - Number of lines: 6; Number of occurances: 1

[OK] // описание логики : https://documentation.lsfusion.org/pages/viewpage.action?pageId=2228636
 <-  описание логики : https://documentation.lsfusion.org/pages/viewpage.action?pageId=2228636
 ->  logic description: https://documentation.lsfusion.org/pages/viewpage.action?pageId=2228636

In samples/mm/src/main/lsfusion/tryonline/PrintShipment.lsf of Category comment - Number of lines: 20; Number of occurances: 9

[OK]     OBJECTS s=Shipment // накладная
 <-  накладная
 ->  shipment
[OK]     PROPERTIES (s) date, customer = nameCustomer, stock = nameStock // печатаем дату, имя покупателя (с именем customer) и имя склада (с именем stock)
 <-  печатаем дату, имя покупателя (с именем customer) и имя склада (с именем stock)
 ->  printing the date, customer name (named customer) and warehouse name (named stock)
[OK]     PROPERTIES total = (GROUP SUM quantity(ShipmentDetail d)*price(d) IF shipment(d)=s) // печатаем общую сумму накладной в теге money
 <-  печатаем общую сумму накладной в теге money
 ->  printing the total shipment amount in the money tag
[OK]     OBJECTS sd=ShipmentDetail // строки накладной     
 <-  строки накладной     
 ->  shipment lines     
[OK]     FILTERS shipment(sd) = s // строки накладной из накладной
 <-  строки накладной из накладной
 ->  shipment lines from shipment
[OK]     PROPERTIES (sd) index, item = nameItem // печатаем номер, имя товара (с именем item)
 <-  печатаем номер, имя товара (с именем item)
 ->  printing the number, name of the product (with the name item)
[OK]     PROPERTIES (sd) price, quantity // печатаем количество, цену в теге money
 <-  печатаем количество, цену в теге money
 ->  printing the quantity, price in the money tag
[OK]     PROPERTIES sum 'Сумма' = (quantity(sd) * price(sd)) // печатаем кол-во * цену (с именем sum)    
 <-  печатаем кол-во * цену (с именем sum)    
 ->  printing quantity * price (named sum)    
[OK]     XLSX TO exportFile; // печатаем накладную с номером 12345
 <-  печатаем накладную с номером 12345
 ->  printing the shipment with the number 12345

In samples/mm/src/main/lsfusion/tryonline/SessionOperations.lsf of Category comment - Number of lines: 26; Number of occurances: 7

[OK]     FOR price(ShipmentDetail sd) > 10 DO { // для всех строк накладных с ценой больше 10 изменим ее на 15, а количество уменьшим на 5
 <-  для всех строк накладных с ценой больше 10 изменим ее на 15, а количество уменьшим на 5
 ->  for all shipment lines with a price greater than 10, changing it to 15, and decreasing the quantity by 5
[OK]     LOCAL NESTED s = STRING(); // так как s - NESTED, она будет видна в NEWSESSION и не обнулятся при APPLY
 <-  так как s - NESTED, она будет видна в NEWSESSION и не обнулятся при APPLY
 ->  since s is NESTED, it will be visible in NEWSESSION and will not be reset on APPLY
[OK]     FOR CHANGED(sum(Shipment s)) DO { // для всех накладных у которых изменилась сумма (в результате верхних изменений)
 <-  для всех накладных у которых изменилась сумма (в результате верхних изменений)
 ->  for all shipments for which the amount has changed (as a result of upper changes)
[OK]             s() <- s() + number(s) + ' : ' + sum(s) + '\n'; // добавим в вывод сумму инвойса (без учета верхних изменений)  
 <-  добавим в вывод сумму инвойса (без учета верхних изменений)  
 ->  adding the shipment amount to the output (excluding the upper changes)  
[OK]             date(s) <- sum(date(s), 1); // увеличим дату инвойса на 1                     
 <-  увеличим дату инвойса на 1                     
 ->  increasing the shipment date by 1                     
[OK]             APPLY; // сохраним изменения
 <-  сохраним изменения
 ->  saving changes
[OK]     // изменения в сессии не сохраняются, соответственно видны не будут
 <-  изменения в сессии не сохраняются, соответственно видны не будут
 ->  changes in the session are not saved, so they will not be visible

In samples/mm/src/main/lsfusion/tryonline/SetOperations.lsf of Category comment - Number of lines: 13; Number of occurances: 3

[OK] // порядковый номер строки по возрастанию цены в накладной
 <-  порядковый номер строки по возрастанию цены в накладной
 ->  sequential line number in ascending order of price in the shipment
[OK] // сумма первых N строк для накладной, оператор GROUP в SQL-стиле 
 <-  сумма первых N строк для накладной, оператор GROUP в SQL-стиле 
 ->  sum of the first N lines for shipment, SQL-style GROUP operator 
[OK]     exportNumeric() <- topSum((GROUP MAX Shipment s IF number(s) = '12345'), 3); // выводим первые 3 записи , оператор GROUP в функциональном стиле
 <-  выводим первые 3 записи , оператор GROUP в функциональном стиле
 ->  displaying the first 3 records, the GROUP operator in a functional style
crowdout/comment/documentation/src (sources: crowdin/comment/documentation/src) -> samples/documentation/src - translated files:
crowdout/comment/documentation/src/main (sources: crowdin/comment/documentation/src/main) -> samples/documentation/src/main - translated files:
crowdout/comment/documentation/src/main/lsfusion (sources: crowdin/comment/documentation/src/main/lsfusion) -> samples/documentation/src/main/lsfusion - translated files:

In samples/documentation/src/main/lsfusion/ActionSample.lsf of Category comment - Number of lines: 850; Number of occurances: 83

[OK] showMessage  { MESSAGE 'Hello World!'; } 								// объявление действия
 <-  объявление действия
 ->  action declaration
[OK]     NEW new = Order {                                   // создается действие, состоящее из последовательного выполнения двух действий
 <-  создается действие, состоящее из последовательного выполнения двух действий
 ->  an action is created that consists of the sequential execution of two actions
[OK]         currency(new) <- currency(old);                 // точка с запятой указывается после каждого оператора
 <-  точка с запятой указывается после каждого оператора
 ->  a semicolon is put after each statement
[OK]     }                                                   // в этой строке точка с запятой не ставится, потому что оператор заканчивается на }
 <-  в этой строке точка с запятой не ставится, потому что оператор заканчивается на }
 ->  there is no semicolon in this line, because the operator ends in }
[OK] exportXls 'Выгрузить в Excel'  ABSTRACT CASE ( Order);         // В данном случае создается ABSTRACT CASE OVERRIDE LAST
 <-  В данном случае создается ABSTRACT CASE OVERRIDE LAST
 ->  In this case, ABSTRACT CASE OVERRIDE LAST is created
[OK] run 'Выполнить'  ABSTRACT ( Task);                           // ABSTRACT MULTI EXCLUSIVE
 <-  ABSTRACT MULTI EXCLUSIVE
 ->  ABSTRACT MULTI EXCLUSIVE
[OK] fill  ABSTRACT LIST ( OrderDetail, InvoiceDetail);   // ABSTRACT LIST LAST
 <-  ABSTRACT LIST LAST
 ->  ABSTRACT LIST LAST
[OK] //Форма с двумя закладками
 <- Форма с двумя закладками
 -> Form with two tabs
[OK]         MESSAGE id(s); // показывает '123'
 <-  показывает '123'
 ->  shows '123'
[OK]         id(Sku s) <- (GROUP MAX id(Sku ss)) (+) 1; // проставляем новый код внутри транзакции 
 <-  проставляем новый код внутри транзакции 
 ->  putting down a new code inside the transaction 
[OK] // установить всем клиентам у кого сумма заказа больше 100 скидку в размере 15 процентов
 <-  установить всем клиентам у кого сумма заказа больше 100 скидку в размере 15 процентов
 ->  set a 15 percent discount for all customers who have an order amount over 100
[OK] // изменить скидку для выбранных товаров для клиента
 <-  изменить скидку для выбранных товаров для клиента
 ->  change the discount for selected products for a customer
[OK] // скопировать свойство g в свойство f
 <-  скопировать свойство g в свойство f
 ->  copy property g to property f
[OK]         IF i == 50 THEN BREAK; // дойдет только до 50
 <-  дойдет только до 50
 ->  will only come up to 50
[OK]     CANCEL NESTED (in[Sku]); // отменяем все изменения, кроме свойства in
 <-  отменяем все изменения, кроме свойства in
 ->  cancel all changes except the in property
[OK] // переводит все документы с датой старше 2-х недель в статус закрыт
 <-  переводит все документы с датой старше 2-х недель в статус закрыт
 ->  sets status to closed for all documents with a date older than 2 weeks
[OK] setNoCancelInTransaction()  INTERNAL  <{ context.getSession().setNoCancelInTransaction(true); }>; // здесь context - это параметр метода executeInternal
 <-  здесь context - это параметр метода executeInternal
 ->  here context is a parameter of executeInternal method
[OK] // удаление объекта
 <-  удаление объекта
 ->  deleting an object
[OK] // удаление всех неактивных товаров
 <-  удаление всех неактивных товаров
 ->  deleting all inactive products
[OK]     DELETE Article a WHERE a IS Article AND NOT active(a); // добавляется локальный параметр a, соответствующий перебираемым объектам
 <-  добавляется локальный параметр a, соответствующий перебираемым объектам
 ->  a local parameter a is added corresponding to the objects to be iterated over
[OK]     //равносильно первому варианту
 <- равносильно первому варианту
 -> equivalent to the first option
[OK] addProperty  { EVAL ACTION 'MESSAGE \'Hello World\''; }  // исходный код, состоящий из одной инструкции, задается строковой константой
 <-  исходный код, состоящий из одной инструкции, задается строковой константой
 ->  source code consisting of one instruction is specified with a string constant
[OK] code 'Исходные код' = DATA BPSTRING[2000] ();              // свойство, в которое пользователь может ввести исходный код
 <-  свойство, в которое пользователь может ввести исходный код
 ->  a property to which the user can enter the source code
[OK] execute 'Выполнить код'  { EVAL code(); }      // действие, выполняющее этот код
 <-  действие, выполняющее этот код
 ->  the action executing this code
[OK] }                                    // объявленное выше действие importData с двумя параметрами 
 <-  объявленное выше действие importData с двумя параметрами 
 ->  declared above action importData with two parameters 
[OK] runImport(OrderDetail d)  { importData(sku(d), order(d)); } // объявление действия runImport, которое будет вызывать importData
 <-  объявление действия runImport, которое будет вызывать importData
 ->  declaration of the action runImport that will call importData
[OK]     EXPORT DBF CHARSET 'CP866' FROM id(Sku s), name(s), weight(s) WHERE in(store, s); // выгружаем в DBF все Sku, для которых задано in (Store, Sku) для нужного склада 
 <-  выгружаем в DBF все Sku, для которых задано in (Store, Sku) для нужного склада 
 ->  uploading to DBF all Sku for which in (Store, Sku) is specified for the desired warehouse 
[OK]     EXPORT CSV NOHEADER NOESCAPE FROM id(Sku s), name(s), weight(s) WHERE in(store, s); // выгружает CSV без строки заголовков и без экранирования спецсимволов
 <-  выгружает CSV без строки заголовков и без экранирования спецсимволов
 ->  uploads to CSV without header line and escaping special characters
[OK]     EXPORT FROM id(Sku s), name(s), weight(s) WHERE in(store, s) ORDER name(s) DESC; // выгружает JSON, сортируем по свойству name[Sku] в порядке убывания
 <-  выгружает JSON, сортируем по свойству name[Sku] в порядке убывания
 ->  uploads JSON, sorting by property name[Sku] in descending order
[OK]     EXPORT FROM ff='HI'; // выгружает JSON {"ff":"HI"}, так как по умолчанию получает имя value, а платформа объект {"value":"HI"} автоматически преобразует в 
 <-  выгружает JSON {"ff":"HI"}, так как по умолчанию получает имя value, а платформа объект {"value":"HI"} автоматически преобразует в 
 ->  uploads JSON {"ff":"HI"}, as by default it gets the name value, and the platform automatically converts the object {"value":"HI"} to 
[OK]     EXPORT FROM 'HI'; // выгружает JSON "HI", так как по умолчанию получает имя value, а платформа объект {"value":"HI"} автоматически преобразует в "HI"     
 <-  выгружает JSON "HI", так как по умолчанию получает имя value, а платформа объект {"value":"HI"} автоматически преобразует в "HI"     
 ->  uploads JSON "HI", as by default it gets the name value, and the platform automatically converts the object {"value": "HI"} to "HI"     
[OK]     // выгружаем в DBF все Sku, для которых задано in (Store, Sku) для нужного склада 
 <-  выгружаем в DBF все Sku, для которых задано in (Store, Sku) для нужного склада 
 ->  uploading to DBF all Sku for which in (Store, Sku) is specified for the desired warehouse 
[OK]     EXTERNAL HTTP GET 'https://www.cs.cmu.edu/~chuck/lennapg/len_std.jpg' TO exportFile; 
 <- www.cs.cmu.edu/~chuck/lennapg/len_std.jpg' TO exportFile; 
 -> www.cs.cmu.edu/~chuck/lennapg/len_std.jpg' TO exportFile; 
[OK]     EXTERNAL HTTP 'http://tryonline.lsfusion.org/exec?action=getExamples' PARAMS JSONFILE('\{"mode"=1\}') TO exportFile; // фигурные скобки escape'ся так как используются в интернационализации
 <- tryonline.lsfusion.org/exec?action=getExamples' PARAMS JSONFILE('\{"mode"=1\}') TO exportFile; // фигурные скобки escape'ся так как используются в интернационализации
 -> tryonline.lsfusion.org/exec?action=getExamples' PARAMS JSONFILE ('\{"mode"=1\}') TO exportFile; // braces are escaped as they are used in internationalization
[OK]     EXTERNAL HTTP 'http://tryonline.lsfusion.org/exec?action=doSomething&someprm=$1' BODYURL 'otherprm=$2&andonemore=$3' PARAMS 1,2,'3'; // передает в BODY url-encoded второй и третий параметры
 <- tryonline.lsfusion.org/exec?action=doSomething&someprm=$1' BODYURL 'otherprm=$2&andonemore=$3' PARAMS 1,2,'3'; // передает в BODY url-encoded второй и третий параметры
 -> tryonline.lsfusion.org/exec?action=doSomething&someprm=$1' BODYURL 'otherprm=$2&andonemore=$3' PARAMS 1,2,'3'; // passes the second and third parameters to BODY url-encoded
[OK]     EXPORT TABLE FROM bc=barcode(Article a) WHERE name(a) LIKE '%Мясо%'; // получаем все штрих-коды товаров с именем мясо
 <-  получаем все штрих-коды товаров с именем мясо
 ->  getting all barcodes of products with the name meat
[OK]     EXTERNAL SQL 'jdbc:mysql://$1/test?user=root&password=' EXEC 'select price AS pc, articles.barcode AS brc from $2 x JOIN articles ON x.bc=articles.barcode' PARAMS 'localhost',exportFile() TO exportFile; // читаем цены для считанных штрих-кодов
 <- $1/test?user=root&password=' EXEC 'select price AS pc, articles.barcode AS brc from $2 x JOIN articles ON x.bc=articles.barcode' PARAMS 'localhost',exportFile() TO exportFile; // читаем цены для считанных штрих-кодов
 -> $1/test?user=root&password=' EXEC 'select price AS pc, articles.barcode AS brc from $2 x JOIN articles ON x.bc=articles.barcode' PARAMS 'localhost',exportFile() TO exportFile; // reading prices for read barcodes
[OK]     // для всех товаров с полученными штрих-кодами записываем цены
 <-  для всех товаров с полученными штрих-кодами записываем цены
 ->  writing prices for all products with received barcodes
[OK]     EXTERNAL LSF 'http://localhost:7651' EXEC 'System.testAction[]'; 
 <- localhost:7651' EXEC 'System.testAction[]'; 
 -> localhost:7651' EXEC 'System.testAction[]'; 
[OK]     FOR Store st IS Store DO { // пробегаем по всем объектам класса Store
 <-  пробегаем по всем объектам класса Store
 ->  iterating over all objects of the Store class
[OK]         FOR in(st, Sku s) DO { // пробегаем по всем Sku, для которых in задано
 <-  пробегаем по всем Sku, для которых in задано
 ->  iterating over all Sku for which in is set
[OK] // Действие, сравнивающее значение свойства count с числом 3 и выдающее пользователю сообщение
 <-  Действие, сравнивающее значение свойства count с числом 3 и выдающее пользователю сообщение
 ->  Action that compares the value of the count property to 3 and displays a message to the user
[OK]         FOR imported(INTEGER i) DO { // свойство imported - системное свойство, предназначенное для перебора данных
 <-  свойство imported - системное свойство, предназначенное для перебора данных
 ->  imported property - a system property for iterating data
[OK]     EXTERNAL SQL 'jdbc:postgresql://localhost/test?user=postgres&password=12345' EXEC 'SELECT x.a,x.b,x.c,x.d FROM orders x WHERE x.id = $1;' PARAMS '4553' TO t;
 <- localhost/test?user=postgres&password=12345' EXEC 'SELECT x.a,x.b,x.c,x.d FROM orders x WHERE x.id = $1;' PARAMS '4553' TO t;
 -> localhost/test?user=postgres&password=12345' EXEC 'SELECT x.a,x.b,x.c,x.d FROM orders x WHERE x.id = $1;' PARAMS '4553' TO t;
[OK]     IMPORT FROM t() FIELDS INTEGER a, DATE b, BPSTRING[50] c, BPSTRING[50] d DO        // импорт с опцией FIELDS
 <-  импорт с опцией FIELDS
 ->  import with FIELDS option
[OK]             currency(o) <- GROUP MAX Currency currency IF name(currency) = d; // находим currency с данным именем
 <-  находим currency с данным именем
 ->  finding currency with this name
[OK]     OBJECTS o = INTEGER // заказы
 <-  заказы
 ->  orders
[OK]     OBJECTS od = INTEGER // строки заказов
 <-  строки заказов
 ->  order lines
[OK]     PROPERTIES (o) dateOrder = date // импортируем дату из поля dateOrder
 <-  импортируем дату из поля dateOrder
 ->  importing the date from the dateOrder field
[OK]     PROPERTIES (od) sku = sku, price = price // импортируем товар количество из полей sku и price
 <-  импортируем товар количество из полей sku и price
 ->  importing product quantity from sku and price fields
[OK]     FILTERS order(od) = o // в order - записываем верхний заказ 
 <-  в order - записываем верхний заказ 
 ->  writing the top order to order 
[OK]         SHOW import; // показываем что импортировалось
 <-  показываем что импортировалось
 ->  showing what was imported
[OK]         // создаем объекты в базе        
 <-  создаем объекты в базе        
 ->  creating objects in the database        
[OK]                 sku(od) <- GROUP MAX Sku sku IF name(sku) = sku(iod); // находим sku с данным именем
 <-  находим sku с данным именем
 ->  finding sku with this name
[OK]     INPUT f = FILE DO { // запрашиваем диалог по выбору файла
 <-  запрашиваем диалог по выбору файла
 ->  requesting a dialog to select a file
[OK]         open(f); // открываем выбранный файл
 <-  открываем выбранный файл
 ->  opening the selected file
[OK]     PROPERTIES(o) customer ON CHANGE requestCustomer(o) // будет работать, к примеру, групповая корректировка  
 <-  будет работать, к примеру, групповая корректировка  
 ->  for example, group adjustment will be performed  
[OK] message  { MESSAGE 'Hello World!'; }                                // простое текстовое сообщение
 <-  простое текстовое сообщение
 ->  plain text message
[OK]     MESSAGE IF isGood(i) THEN 'Good' ELSE 'Bad';   // в зависимости от того, какой item будет передан действию, будет показываться окно с текстом 'Good', либо с текстом 'Bad'
 <-  в зависимости от того, какой item будет передан действию, будет показываться окно с текстом 'Good', либо с текстом 'Bad'
 ->  depending on which item will be passed to the action, a window will be shown either with the text 'Good' or with the text 'Bad'
[OK] testMessage()  {                    // В этом случае пользователю будет выдано пять текстовых сообщений
 <-  В этом случае пользователю будет выдано пять текстовых сообщений
 ->  In this case, five text messages will be shown to the user
[OK] testMessageNowait()  {              // В случае NOWAIT пользователю будет выдано одно текстовое сообщение, объединяющее сообщения от пяти вызовов MESSAGE
 <-  В случае NOWAIT пользователю будет выдано одно текстовое сообщение, объединяющее сообщения от пяти вызовов MESSAGE
 ->  In the case of NOWAIT, one text message combining messages from five MESSAGE calls will be shown to the user
[OK]         APPLY; // на самом деле изменения применятся не в базу данных, а в "верхнюю" сессию
 <-  на самом деле изменения применятся не в базу данных, а в "верхнюю" сессию
 ->  in fact, the changes will not be applied to the database, but to the "upper" session
[OK]     MESSAGE (GROUP SUM 1 IF name(Sku s) == 'aaa'); // возвращает все строки
 <-  возвращает все строки
 ->  returns all rows
[OK]     MESSAGE (GROUP SUM 1 IF name(Sku s) == 'aaa'); // возвращает NULL, если в базе не было раньше Sku с именем aaa
 <-  возвращает NULL, если в базе не было раньше Sku с именем aaa
 ->  returns NULL if there was no Sku named aaa in the database before
[OK]             // показывает форму, но любые изменения в ней не будут применены в базу данных, а будут сохранены в "верхней сессии"
 <-  показывает форму, но любые изменения в ней не будут применены в базу данных, а будут сохранены в "верхней сессии"
 ->  shows the form, but any changes in it will not be applied to the database, but will be saved in the "upper" session
[OK]                     name(s) <- STRING[20](id(s)); // записываем в наименование код в 10 потоков
 <-  записываем в наименование код в 10 потоков
 ->  writing the code into the name in 10 threads
[OK]     // здесь новый объект класса Currency уже в базе данных
 <-  здесь новый объект класса Currency уже в базе данных
 ->  here a new object of class Currency is already in the database
[OK]         MESSAGE (GROUP SUM 1 IF local(Currency c) == 'Local'); // возвратит NULL
 <-  возвратит NULL
 ->  will return NULL
[OK]         MESSAGE (GROUP SUM 1 IF local(Currency c) == 'Local'); // возвратит кол-во объектов класса Currency
 <-  возвратит кол-во объектов класса Currency
 ->  will return the number of objects of class Currency
[OK]     //Показ всем сообщения 'Сообщение'
 <- Показ всем сообщения 'Сообщение'
 -> Showing messages 'Message' to all
[OK]     //Выполнение действия action с периодичностью в 10 секунд и задержкой 5 секунд
 <- Выполнение действия action с периодичностью в 10 секунд и задержкой 5 секунд
 -> Execution of the 'action' action with a frequency of 10 seconds and a delay of 5 seconds
[OK]     PRINT printOrder OBJECTS o = o; // выводим на печать
 <-  выводим на печать
 ->  printing
[OK]     //v 2.0-2.1 syntax
 <- v 2.0-2.1 syntax
 -> v 2.0-2.1 syntax
[OK]     //v 2.2 syntax
 <- v 2.2 syntax
 -> v 2.2 syntax
[OK]     //PRINT printOrder OBJECTS o = o XLS SHEET 'enctypted' PASSWORD 'pass';
 <- PRINT printOrder OBJECTS o = o XLS SHEET 'enctypted' PASSWORD 'pass';
 -> PRINT printOrder OBJECTS o = o XLS SHEET 'enctypted' PASSWORD 'pass';
[OK]     //чтение из FTP
 <- чтение из FTP
 -> reading from FTP
[OK]     READ 'ftp://ftp.lsfusion.org/file.xlsx' TO importFile;
 <- ftp.lsfusion.org/file.xlsx' TO importFile;
 -> ftp.lsfusion.org/file.xlsx' TO importFile;
[OK]     //чтение из SFTP
 <- чтение из SFTP
 -> reading from SFTP
[OK]     READ 'sftp://sftp.lsfusion.org/file.xlsx' TO importFile;
 <- sftp.lsfusion.org/file.xlsx' TO importFile;
 -> sftp.lsfusion.org/file.xlsx' TO importFile;
[OK]     //чтение из FILE
 <- чтение из FILE
 -> reading from FILE
[OK]     READ 'D://lsfusion/file.xlsx' TO importFile;
 <- lsfusion/file.xlsx' TO importFile;
 -> lsfusion/file.xlsx' TO importFile;
[OK]     READ 'file://D://lsfusion/file.xlsx' TO importFile;
 <- D://lsfusion/file.xlsx' TO importFile;
 -> D://lsfusion/file.xlsx' TO importFile;
[OK]         WRITE f TO 'file:///home/user/loadedfile.csv' APPEND;
 <- /home/user/loadedfile.csv' APPEND;
 -> /home/user/loadedfile.csv' APPEND;

In samples/documentation/src/main/lsfusion/AggregationSample.lsf of Category comment - Number of lines: 22; Number of occurances: 3

[OK] ab = AGGR AB WHERE A a IS A AND B b IS B; // для каждой пары A B создает объект AB
 <-  для каждой пары A B создает объект AB
 ->  for each A B pair creates an object AB
[OK] shipment(Invoice invoice) = AGGR ShipmentInvoice WHERE createShipment(invoice); // создаем поставку по инвойсу, если для инвойса задана опция создавать поставку
 <-  создаем поставку по инвойсу, если для инвойса задана опция создавать поставку
 ->  creating a delivery by invoice, if the option for delivery creation is defined for the invoice
[OK] date(ShipmentInvoice si) += sum(date(invoice(si)),1); // дата поставки = дата инвойса + 1
 <-  дата поставки = дата инвойса + 1
 ->  delivery date = invoice date + 1

In samples/documentation/src/main/lsfusion/ExpressionSample.lsf of Category comment - Number of lines: 20; Number of occurances: 8

[OK] points(Team team) = wins(team) * 3 + ties(team); // Количество очков, полученное командой за сыгранные матчи   
 <-  Количество очков, полученное командой за сыгранные матчи   
 ->  The number of points received by the team for the matches played   
[OK] // В данном случае выражение записано справа от знака равенства. Оно определяет новое свойство points.
 <-  В данном случае выражение записано справа от знака равенства. Оно определяет новое свойство points.
 ->  In this case, the expression is written to the right of the equal sign. It defines a new property called points.
[OK] // При вычислении выражения сначала выполнятся два оператора JOIN: wins(team) и ties(team), подставив параметр team в свойства wins и ties
 <-  При вычислении выражения сначала выполнятся два оператора JOIN: wins(team) и ties(team), подставив параметр team в свойства wins и ties
 ->  When calculating the expression, two JOIN operators are first executed: wins(team) and ties(team), substituting the team parameter in the wins and ties properties
[OK] // Затем выполнится оператор умножения, который построит свойство, возвращающее число, равное произведению возвращаемого значения wins(team) и числа 3
 <-  Затем выполнится оператор умножения, который построит свойство, возвращающее число, равное произведению возвращаемого значения wins(team) и числа 3
 ->  Then the multiplication operator will be executed, which will build a property that returns a number equal to the product of the return value of wins(team) and the number 3
[OK] // Затем выполнится оператор сложения, который создаст свойство, суммирующее возвращаемые значения (wins(team) * 3) и ties(team) 
 <-  Затем выполнится оператор сложения, который создаст свойство, суммирующее возвращаемые значения (wins(team) * 3) и ties(team) 
 ->  Then the addition operator will be executed, which will create a property that sums the return values (wins(team) * 3) and ties(team) 
[OK] // Получившееся свойство и будет являться результатом выполнения выражения
 <-  Получившееся свойство и будет являться результатом выполнения выражения
 ->  The resulting property will be the result of the expression
[OK] gamePoints(Game game) = 2 (+) (1 IF game IS BonusGame); // Количество очков за игру. Если игра бонусная, то 3, иначе 2.
 <-  Количество очков за игру. Если игра бонусная, то 3, иначе 2.
 ->  The number of points per game. If the game is bonus, then 3, otherwise 2.
[OK] // В данном примере порядок выполнения операторов будет такой: IS, IF, (+) <-  В данном примере порядок выполнения операторов будет такой: IS, IF, (+)
 ->  In this example, the order of execution of the operators will be as follows: IS, IF, (+)

In samples/documentation/src/main/lsfusion/FormSample.lsf of Category comment - Number of lines: 429; Number of occurances: 138

[OK] // объявляем форму Документы
 <-  объявляем форму Документы
 ->  declaring the Documents form
[OK]     OBJECTS d = Document // Добавляем один объект класса Document, по этому имени объект будет доступен в операторах DESIGN, SHOW, EXPORT, DIALOG и др.
 <-  Добавляем один объект класса Document, по этому имени объект будет доступен в операторах DESIGN, SHOW, EXPORT, DIALOG и др.
 ->  Adding one object of the Document class. The object will be available by this name in the DESIGN, SHOW, EXPORT, DIALOG, etc. operators.
[OK]     // ... добавляем свойства и фильтры на форму 
 <-  ... добавляем свойства и фильтры на форму 
 ->  ... adding properties and filters to the form 
[OK]     LIST Document OBJECT d // помечаем что данная форма должна использоваться, когда необходимо выбрать документ, при этом объект d должен использоваться как возвращаемое значение
 <-  помечаем что данная форма должна использоваться, когда необходимо выбрать документ, при этом объект d должен использоваться как возвращаемое значение
 ->  marking that this form should be used when it is necessary to select a document, while the d object should be used as a return value
[OK] // объявляем форму Товар
 <-  объявляем форму Товар
 ->  declaring the Product form
[OK]     OBJECTS i = Item PANEL // добавляем объект класса Item и помечаем, что он должен отображаться в панель (то есть видимо только одно значение)
 <-  добавляем объект класса Item и помечаем, что он должен отображаться в панель (то есть видимо только одно значение)
 ->  adding an object of the Item class and marking that it should be displayed in the panel (i.e., only one value is visible)
[OK]     // ... добавляем свойства и фильтры на форму 
 <-  ... добавляем свойства и фильтры на форму 
 ->  ... adding properties and filters to the form 
[OK]     EDIT Item OBJECT i // помечаем что данная форма должна использоваться, когда необходимо добавлять или редактировать товар
 <-  помечаем что данная форма должна использоваться, когда необходимо добавлять или редактировать товар
 ->  marking that this form should be used when it is necessary to add or edit a product
[OK] // объявляем форму со списком Товаров
 <-  объявляем форму со списком Товаров
 ->  declaring a form with a list of Products
[OK]     // ... добавляем свойства и фильтры на форму 
 <-  ... добавляем свойства и фильтры на форму 
 ->  ... adding properties and filters to the form 
[OK]     PROPERTIES(i) NEWSESSION NEW, EDIT // добавляем кнопки, которые будут создавать и редактировать товар, используя форму item
 <-  добавляем кнопки, которые будут создавать и редактировать товар, используя форму item
 ->  adding buttons that will create and edit the product using the item form
[OK] // объявляем форму печати инвойса
 <-  объявляем форму печати инвойса
 ->  declaring the invoice print form
[OK]     OBJECTS i = Invoice // добавляем объект класса инвойс, для которого будет идти печать
 <-  добавляем объект класса инвойс, для которого будет идти печать
 ->  adding an object of the invoice class for which printing will be executed
[OK]     // ... добавляем свойства и фильтры на форму 
 <-  ... добавляем свойства и фильтры на форму 
 ->  ... adding properties and filters to the form 
[OK] // разбиваем определение формы на две инструкции (вторую инструкцию можно перенести в другой модуль)
 <-  разбиваем определение формы на две инструкции (вторую инструкцию можно перенести в другой модуль)
 ->  splitting the form definition into two instructions (the second instruction can be transferred to another module)
[OK]     OBJECTS d = InvoiceDetail // добавляем строки инвойса, каждая из которых будет использоваться в отчете в качестве детализации
 <-  добавляем строки инвойса, каждая из которых будет использоваться в отчете в качестве детализации
 ->  adding invoice lines, each of which will be used in the report as a detail
[OK]     // ... добавляем свойства и фильтры на форму 
 <-  ... добавляем свойства и фильтры на форму 
 ->  ... adding properties and filters to the form 
[OK] print (Invoice invoice)  { PRINT printInvoice OBJECTS i = invoice; } // объявляем действие , при выполнении которого будет открываться форма печати инвойса
 <-  объявляем действие , при выполнении которого будет открываться форма печати инвойса
 ->  declaring an action that will open the invoice print form
[OK] // объявляем форму поставки
 <-  объявляем форму поставки
 ->  declaring the delivery form
[OK]     OBJECTS s = Shipment // добавляем один объект класса shipment
 <-  добавляем один объект класса shipment
 ->  adding one object of the shipment class
[OK]                         PAGESIZE 100 // указываем, что таблица всегда должна содержать 100 рядов
 <-  указываем, что таблица всегда должна содержать 100 рядов
 ->  indicating that the table should always contain 100 rows
[OK]     // ... добавляем свойства и фильтры на форму 
 <-  ... добавляем свойства и фильтры на форму 
 ->  ... adding properties and filters to the form 
[OK] // Объявляем форму, которая будет отображать обороты по товару за заданный интервал
 <-  Объявляем форму, которая будет отображать обороты по товару за заданный интервал
 ->  Declaring a form that will display the turnover of the product for a specified interval
[OK]     OBJECTS interval = (dateFrom 'Дата (с)' = DATE, dateTo 'Дата (по)' = DATE) PANEL, // объявляем группу объектов, состоящую из 2х объектов класса Дата с соответствующими заголовками, которая будет всегда отображаться в виде панели
 <-  объявляем группу объектов, состоящую из 2х объектов класса Дата с соответствующими заголовками, которая будет всегда отображаться в виде панели
 ->  declaring a group of objects, consisting of 2 objects of the Date class with the appropriate captions, which will always be displayed as a panel
[OK]             i = Item // добавляем список товаров
 <-  добавляем список товаров
 ->  adding a list of products
[OK]     PROPERTIES VALUE(dateFrom), VALUE(dateTo) // добавляем на форму свойства значений объектов даты, при помощи которых пользователь сможет выбирать даты
 <-  добавляем на форму свойства значений объектов даты, при помощи которых пользователь сможет выбирать даты
 ->  adding to the form the properties of the date objects values, with which the user can select dates
[OK]     PROPERTIES name(i), revenue(i, dateFrom, dateTo) // добавляем имя товаров и свойство с оборотами товара за интервал дат
 <-  добавляем имя товаров и свойство с оборотами товара за интервал дат
 ->  adding the product name and the property with the product turnover for the date interval
[OK] // объявляем форму заказы
 <-  объявляем форму заказы
 ->  declaring the orders form
[OK]     OBJECTS o = Order PANEL // добавляем объект заказ на форму
 <-  добавляем объект заказ на форму
 ->  adding an order object to the form
[OK]     PROPERTIES VALUE(o), // добавляем идентификатор заказа в базе данных
 <-  добавляем идентификатор заказа в базе данных
 ->  adding the order ID in the database
[OK]                date(o), time(o), series(o), number(o), // добавляем свойства дата/время заказа, серия/номер заказа
 <-  добавляем свойства дата/время заказа, серия/номер заказа
 ->  adding properties date/time of order, series/order number
[OK]                nameCustomer(o), // добавляем наименование покупателя, которое по умолчанию будет доступным для редактирования
 <-  добавляем наименование покупателя, которое по умолчанию будет доступным для редактирования
 ->  adding the name of the customer, which by default will be available for editing
[OK]                                      // при этом, при попытке его редактирования, будет вызываться диалог по выбору покупателя - форма, для которой установлен параметр LIST customer
 <-  при этом, при попытке его редактирования, будет вызываться диалог по выбору покупателя - форма, для которой установлен параметр LIST customer
 ->  here, when the user tries to edit it, a dialog will be called for the customer choice - a form for which the LIST customer parameter is set
[OK]                note(o), // добавляем примечание
 <-  добавляем примечание
 ->  adding a note
[OK]                sum(o) READONLY // добавляем сумму по заказу без возможности редактирования, так как оно автоматически считается на основе суммы строк                                     
 <-  добавляем сумму по заказу без возможности редактирования, так как оно автоматически считается на основе суммы строк                                     
 ->  adding the order amount without the possibility of editing, since it is automatically calculated based on the sum of rows                                     
[OK]     OBJECTS d = OrderDetail // добавляем объект строка заказа
 <-  добавляем объект строка заказа
 ->  adding the order line object
[OK]     PROPERTIES(d) // все свойства в этом блоке будут иметь вход строка заказа
 <-  все свойства в этом блоке будут иметь вход строка заказа
 ->  all properties in this block will have an order line input
[OK]                   index READONLY, // добавляем порядковый номер строки и делаем, чтобы его нельзя было редактировать
 <-  добавляем порядковый номер строки и делаем, чтобы его нельзя было редактировать
 ->  adding the ordinal line number and making it impossible to edit
[OK]                   nameSku, // добавляем наименование
 <-  добавляем наименование
 ->  adding a name
[OK]                   quantity, price, sum, // добавляем количество, цена, сумму
 <-  добавляем количество, цена, сумму
 ->  adding quantity, price, amount
[OK]                   NEW, // добавляем предопределенное действие NEW, которое добавляет новую строку заказа
 <-  добавляем предопределенное действие NEW, которое добавляет новую строку заказа
 ->  adding the predefined NEW action that adds a new order line
[OK]                   DELETE // добавляем действие, которое будет удалять строку заказа
 <-  добавляем действие, которое будет удалять строку заказа
 ->  adding an action that will delete the order line
[OK]     FILTERS order(d) == o // указываем, что должны показываться только строки, относящиеся к данному заказу
 <-  указываем, что должны показываться только строки, относящиеся к данному заказу
 ->  indicating that only lines related to this order should be shown
[OK]     OBJECTS s = Sku // добавляем объект sku, в который мы будем выводить итоги по каждому sku в заказе
 <-  добавляем объект sku, в который мы будем выводить итоги по каждому sku в заказе
 ->  adding a sku object to which the totals for each sku in the order will be written
[OK]     PROPERTIES(s) name READONLY // добавляем наименование , при этом делая пометку, что его нельзя редактировать на этой форме
 <-  добавляем наименование , при этом делая пометку, что его нельзя редактировать на этой форме
 ->  adding a name, while making a note that it cannot be edited on this form
[OK]     PROPERTIES quantity(o, s) // добавляем свойство, в котором будет показываться заказанное количество по sku в данном заказе
 <-  добавляем свойство, в котором будет показываться заказанное количество по sku в данном заказе
 ->  adding a property that will display the ordered quantity by sku in this order
[OK]                ON CHANGE changeQuantity(o, s) // по умолчанию, несмотря на то, что свойство не помечено как READONLY, и при попытке его изменения ничего происходить не будет, так как quantity - это агрегированное свойство
 <-  по умолчанию, несмотря на то, что свойство не помечено как READONLY, и при попытке его изменения ничего происходить не будет, так как quantity - это агрегированное свойство
 ->  by default, even though the property is not marked READONLY and nothing will happen when the user tries to change it, since quantity is an aggregated property
[OK]                                                            // в данном случае делается пометка, что при попытке изменения будет вызвано действие changeQuantity
 <-  в данном случае делается пометка, что при попытке изменения будет вызвано действие changeQuantity
 ->  in this case, a note is made that when the user tries to change, the changeQuantity action will be called
[OK]                                                            // в этом свойство написан алгоритм, который будет создавать/удалять строки заказа или изменять в них количество
 <-  в этом свойство написан алгоритм, который будет создавать/удалять строки заказа или изменять в них количество
 ->  an algorithm is written in this property that will create/delete order lines or change the quantity in them
[OK]                READONLYIF stopOrder(s) // делаем, чтобы свойство было недоступно для редактирования, в случае, если выставлен запрет на заказ по данному sku
 <-  делаем, чтобы свойство было недоступно для редактирования, в случае, если выставлен запрет на заказ по данному sku
 ->  making the property unavailable for editing, if the order is prohibited for this sku
[OK]                BACKGROUND stopOrder(s) // кроме того, подсвечиваем в таком случае эту ячейку своим фоном, чтобы пользователь заранее видел такие позиции
 <-  кроме того, подсвечиваем в таком случае эту ячейку своим фоном, чтобы пользователь заранее видел такие позиции
 ->  in addition, in this case, this cell is highlighted with custom background so that the user can see such positions in advance
[OK]     EDIT Order OBJECT o // помечаем форму, как форму для редактирования заказов
 <-  помечаем форму, как форму для редактирования заказов
 ->  marking the form as a form for editing orders
[OK] EXTEND FORM order // расширяем форму при помощи концепции Mixin
 <-  расширяем форму при помощи концепции Mixin
 ->  expanding the form with the Mixin concept
[OK]     PROPERTIES onStock(s) BEFORE quantity(d), // добавляем на форму свойство текущего остатка перед количеством в заказе
 <-  добавляем на форму свойство текущего остатка перед количеством в заказе
 ->  adding the property of the current balance to the form before the quantity in the order
[OK]                ordered(s) BEFORE quantity(d) // добавляем на форму количество уже заказанного товара в рамках всех заказов
 <-  добавляем на форму количество уже заказанного товара в рамках всех заказов
 ->  adding to the form the quantity of already ordered products within all orders
[OK]     PROPERTIES(o) READONLY VALUE, date, number // все свойства в этом блоке недоступны для редактирования
 <-  все свойства в этом блоке недоступны для редактирования
 ->  all properties in this block are unavailable for editing
[OK]     PROPERTIES(o) NEWSESSION NEW, EDIT, DELETE // добавляем предопределенные действия NEW и EDIT, которые будут вызывать форму order для добавления заказов
 <-  добавляем предопределенные действия NEW и EDIT, которые будут вызывать форму order для добавления заказов
 ->  adding predefined NEW and EDIT actions that will call the order form to add orders
[OK] // создаем "отчет", в котором будут видны заказы за определенный интервал в разрезе покупателей в конкретном регионе
 <-  создаем "отчет", в котором будут видны заказы за определенный интервал в разрезе покупателей в конкретном регионе
 ->  creating a "report" in which orders for a certain interval will be visible in the context of customers in a particular region
[OK]     OBJECTS interval = (dateFrom 'Дата (с)' = DATE, dateTo 'Дата (по)' = DATE) PANEL // объявляем группу объектов, состоящую из 2х объектов класса Дата с соответствующими заголовками, которая будет всегда отображаться в виде панели
 <-  объявляем группу объектов, состоящую из 2х объектов класса Дата с соответствующими заголовками, которая будет всегда отображаться в виде панели
 ->  declaring a group of objects, consisting of 2 objects of the Date class with the appropriate captions, which will always be displayed as a panel
[OK]     PROPERTIES dateFrom = VALUE(dateFrom), dateTo = VALUE(dateTo) // добавляем на форму свойства значений объектов даты, при помощи которых пользователь сможет выбирать даты
 <-  добавляем на форму свойства значений объектов даты, при помощи которых пользователь сможет выбирать даты
 ->  adding to the form the properties of the date objects values, with which the user can select dates
[OK]                                                                         // кроме того, присваиваем этим свойствам имена на форме dateFrom и dateTo соответственно
 <-  кроме того, присваиваем этим свойствам имена на форме dateFrom и dateTo соответственно
 ->  in addition, assigning to these properties on the form names dateFrom and dateTo, respectively
[OK]     OBJECTS r = Region PANEL // добавляем объект регион, по которому будет происходить фильтрация покупателей
 <-  добавляем объект регион, по которому будет происходить фильтрация покупателей
 ->  adding a region object, by which customers will be filtered
[OK]     PROPERTIES(r) name SELECTOR // добавляем свойство наименование региона, при этом помечаем, что при его редактировании должен вызываться диалог по выбору региона, выбранное значение которого будет использовано как текущее значение
 <-  добавляем свойство наименование региона, при этом помечаем, что при его редактировании должен вызываться диалог по выбору региона, выбранное значение которого будет использовано как текущее значение
 ->  adding the property region name, at the same time marking that when editing it, the dialog for choosing a region should be called, the selected value of which will be used as the current value
[OK]     OBJECTS c = Customer // добавляем объект покупатели
 <-  добавляем объект покупатели
 ->  adding the customers object
[OK]                          // специально не добавляем ни одного свойства, чтобы он был "невидимым", но он нужен для того, чтобы отображать покупателей в колонки
 <-  специально не добавляем ни одного свойства, чтобы он был "невидимым", но он нужен для того, чтобы отображать покупателей в колонки
 ->  specifically not adding a single property so that it is "invisible", but it is needed in order to display customers in columns
[OK]     FILTERS region(c) == r // ставим фильтр на то, чтобы покупатели были только из этого региона
 <-  ставим фильтр на то, чтобы покупатели были только из этого региона
 ->  setting a filter so that customers are only from this region
[OK]     OBJECTS s = Sku // добавляем объект sku, в таблице которого и будет показываться основная информация
 <-  добавляем объект sku, в таблице которого и будет показываться основная информация
 ->  adding a sku object, in the table of which basic information will be displayed
[OK]     PROPERTIES(s) name READONLY // добавляем наименование sku и не забываем сделать его READONLY, иначе пользователь сможет изменять наименования товара непосредственно в отчете
 <-  добавляем наименование sku и не забываем сделать его READONLY, иначе пользователь сможет изменять наименования товара непосредственно в отчете
 ->  adding the sku name and making it READONLY, otherwise the user will be able to change the product names directly in the report
[OK]                 // добавляем свойство, в котором рассчитана количество заказанного sku по покупателям за определенный интервал дат
 <-  добавляем свойство, в котором рассчитана количество заказанного sku по покупателям за определенный интервал дат
 ->  adding a property in which the quantity of ordered sku by customers for a certain date interval is calculated
[OK]                COLUMNS (c) // помечаем, что покупатели должны отображаться в колонки, при этом колонок будет столько же, сколько и рядов с учетом фильтров будет в объекте покупателя, и идти они будут в том же порядке
 <-  помечаем, что покупатели должны отображаться в колонки, при этом колонок будет столько же, сколько и рядов с учетом фильтров будет в объекте покупателя, и идти они будут в том же порядке
 ->  marking that customers should be displayed in columns, with the same number of columns as there will be rows in the customer object, taking into account filters, and they will be displayed in the same order
[OK]                HEADER name(c) // задаем, что в качестве заголовка колонок будет использоваться имя покупателя
 <-  задаем, что в качестве заголовка колонок будет использоваться имя покупателя
 ->  setting that the name of the customer will be used as the column heading
[OK] FORM onStock 'Остатки' // создаем форму, в которой можно смотреть остатки по товарам
 <-  создаем форму, в которой можно смотреть остатки по товарам
 ->  creating a form in which the balances of products can be viewed
[OK]     OBJECTS r = Region PANEL // добавляем объект регион
 <-  добавляем объект регион
 ->  adding a region object
[OK]     PROPERTIES name(r) SELECTOR // добавляем свойство имя региона, при нажатии на который пользователь сможет его выбирать
 <-  добавляем свойство имя региона, при нажатии на который пользователь сможет его выбирать
 ->  adding the property name of the region, when clicking on which the user can select it
[OK]     OBJECTS st = Stock // добавляем объект склады
 <-  добавляем объект склады
 ->  adding the warehouse object
[OK]     PROPERTIES name(st) READONLY // добавляем имя склада
 <-  добавляем имя склада
 ->  adding the warehouse name
[OK]     FILTERS region(st) == r // добавляем фильтр, чтобы показывались только склады выбранного региона
 <-  добавляем фильтр, чтобы показывались только склады выбранного региона
 ->  adding a filter so that only warehouses of the selected region are shown
[OK]     OBJECTS s = Sku // добавляем товары
 <-  добавляем товары
 ->  adding products
[OK]     PROPERTIES READONLY groupName = nameGroup(s), name(s), onStock(st, s) // добавляем наименование группы товаров, присваивая ему groupName в качестве имени свойства на форме, а также наименование и остаток по товару
 <-  добавляем наименование группы товаров, присваивая ему groupName в качестве имени свойства на форме, а также наименование и остаток по товару
 ->  adding the name of the group of products, assigning it groupName as the name of the property on the form, as well as the name and balance of the product
[OK]     FILTERS active(s) // включаем, чтобы показывались только активные товары
 <-  включаем, чтобы показывались только активные товары
 ->  turning it on to show only active products
[OK] EXTEND FORM onStock // расширяем ранее созданную форму с остатками
 <-  расширяем ранее созданную форму с остатками
 ->  extending the previously created form with balances
[OK]     FILTERGROUP stockActive // создаем группу фильтров с одним фильтрам, которая будет показываться в виде флажка, по которому пользователь сможет включать/отключать фильтр
 <-  создаем группу фильтров с одним фильтрам, которая будет показываться в виде флажка, по которому пользователь сможет включать/отключать фильтр
 ->  creating a group of filters with one filter, which will be shown as a checkbox by which the user can enable/disable the filter
[OK]         FILTER 'Активные' active(st) 'F11' // добавляем отбор по только активным складам, который будет применяться по нажатию клавиши F11
 <-  добавляем отбор по только активным складам, который будет применяться по нажатию клавиши F11
 ->  adding filter for active warehouses only, which will be applied by pressing F11
[OK]     FILTERGROUP skuAvailability // создаем новую группу фильтров, в которой пользователь сможет выбирать один из фильтров при помощи выпадающего списка
 <-  создаем новую группу фильтров, в которой пользователь сможет выбирать один из фильтров при помощи выпадающего списка
 ->  creating a new filter group in which the user can select one of the filters using the drop-down list
[OK]         FILTER 'Есть на остатках' onStock(st, s) 'F10' DEFAULT // добавляем отбор, который будет показывать только товары на остатках, выбираться по клавише F10 и будет автоматически выбран при открытии формы
 <-  добавляем отбор, который будет показывать только товары на остатках, выбираться по клавише F10 и будет автоматически выбран при открытии формы
 ->  adding a filter that will display only products on stock, which will be selected by pressing F10 and will be automatically selected when the form is opened
[OK] // ...  
 <-  ...  
 ->  ...  
[OK]         FILTER 'Отрицательные остатки' onStock(st, s) < 0 'F9' // добавляем отбор по выражению
 <-  добавляем отбор по выражению
 ->  adding filter by expression
[OK] EXTEND FORM onStock // расширяем ранее созданную форму с остатками
 <-  расширяем ранее созданную форму с остатками
 ->  extending the previously created form with balances
[OK]     ORDERS name(s) // включаем сортировку по наименования склада в списке складов
 <-  включаем сортировку по наименования склада в списке складов
 ->  enabling ordering by warehouse name in the warehouse list
[OK]     ORDERS groupName, onStock(st, s) DESC // включаем сортировку по возрастанию имени группы, а внутри по убыванию остатка на складе
 <-  включаем сортировку по возрастанию имени группы, а внутри по убыванию остатка на складе
 ->  enabling ordering in ascending order of the group name, and inside in descending order of the balance in the warehouse
[OK]                                             // следует отметить, что в качестве свойства указывается имя свойства на форме groupName, а не просто имя свойства nameGroupSku
 <-  следует отметить, что в качестве свойства указывается имя свойства на форме groupName, а не просто имя свойства nameGroupSku
 ->  it should be noted that the property is the property name on the form groupName, not just the property name nameGroupSku
[OK] FORM invoice 'Инвойс' // создаем форму по редактированию инвойса
 <-  создаем форму по редактированию инвойса
 ->  creating a form for editing an invoice
[OK]     OBJECTS i = Invoice PANEL // создаем объект класса инвойс
 <-  создаем объект класса инвойс
 ->  creating an object of the invoice class
[OK] //    ...  задаем остальное поведение формы
 <-     ...  задаем остальное поведение формы
 ->     ...  setting the rest of the form behavior
[OK]         ON OK { posted(i) <- TRUE; }, // указываем, что при нажатии пользователем OK должно выполняться действия, которое выполнит действия по "проведению" данного инвойса
 <-  указываем, что при нажатии пользователем OK должно выполняться действия, которое выполнит действия по "проведению" данного инвойса
 ->  specifying that when the user clicks OK, an action should be executed that will execute actions to "post" this invoice
[OK]         ON DROP showImpossibleMessage() // по нажатию кнопки formDrop выдаем сообщение, что такого не может быть, так как эта кнопка по умолчанию будет показываться только в форме по выбору инвойса, а эта форма по сути является формой редактирования инвойса
 <-  по нажатию кнопки formDrop выдаем сообщение, что такого не может быть, так как эта кнопка по умолчанию будет показываться только в форме по выбору инвойса, а эта форма по сути является формой редактирования инвойса
 ->  by clicking the formDrop button, showing a message that this cannot be, since this button by default will be shown only in the form for choosing an invoice, and this form is basically an invoice edit form
[OK] FORM POS 'POS' // объявляем форму для продажи товара покупателю в торговом зале
 <-  объявляем форму для продажи товара покупателю в торговом зале
 ->  declaring the form for product sale to the customer in the salesroom
[OK]     OBJECTS r = Receipt PANEL // добавляем объект, в котором будет храниться текущий чек
 <-  добавляем объект, в котором будет храниться текущий чек
 ->  adding an object that will store the current receipt
[OK] //    ... объявляем поведение формы
 <-     ... объявляем поведение формы
 ->     ... declaring the behavior of the form
[OK] EXTEND FORM POS // добавляем свойство через расширение формы, чтобы можно было сделать SEEK к уже созданному объекту на форме
 <-  добавляем свойство через расширение формы, чтобы можно было сделать SEEK к уже созданному объекту на форме
 ->  adding a property through the form extension so that SEEK could be applied to the already created object on the form
[OK]         ON INIT createReceipt() // при открытии формы выполняем действие по созданию нового чека, которое заполняет смену, кассира и прочую информацию
 <-  при открытии формы выполняем действие по созданию нового чека, которое заполняет смену, кассира и прочую информацию
 ->  when opening the form, executing the action to create a new receipt, which fills in the shift, cashier and other information
[OK] // делаем форму печати ценника для товара
 <-  делаем форму печати ценника для товара
 ->  creating a form for printing a price tag for a product
[OK]     OBJECTS i = Item               // добавляем товар, для которого будет печататься ценник
 <-  добавляем товар, для которого будет печататься ценник
 ->  adding the product for which the price tag will be printed
[OK]     REPORT printLabelFile(i)       // помечаем, что в качестве шаблона должен использоваться файл, имя которого лежит в свойстве printLabelFile (предполагается что значение i будет передаваться в блоке OBJECTS)
 <-  помечаем, что в качестве шаблона должен использоваться файл, имя которого лежит в свойстве printLabelFile (предполагается что значение i будет передаваться в блоке OBJECTS)
 ->  marking that a file whose name is stored in the printLabelFile property should be used as a template (it is assumed that the i value will be passed in the OBJECTS block)
[OK]                                    // например, пользователь может ввести туда myLabel1.jrxml, тогда система будет использовать файл, с именем myLabel1.jrxml
 <-  например, пользователь может ввести туда myLabel1.jrxml, тогда система будет использовать файл, с именем myLabel1.jrxml
 ->  for example, the user can input myLabel1.jrxml there, then the system will use a file named myLabel1.jrxml
[OK] //  ... другие свойства, необходимые для печати
 <-   ... другие свойства, необходимые для печати
 ->   ... other properties required for printing
[OK] DESIGN order { // настраиваем дизайн формы, начиная с дизайна по умолчанию
 <-  настраиваем дизайн формы, начиная с дизайна по умолчанию
 ->  customizing the design of the form, starting with the default design
[OK]     // отмечаем, что все изменения иерархии будут происходит для самого верхнего контейнера 
 <-  отмечаем, что все изменения иерархии будут происходит для самого верхнего контейнера 
 ->  marking that all changes to the hierarchy will occur for the topmost container 
[OK]     NEW orderPane FIRST { // создаем новый контейнер самым первым перед системными кнопками, в который положим два контейнера - шапка и спецификации
 <-  создаем новый контейнер самым первым перед системными кнопками, в который положим два контейнера - шапка и спецификации
 ->  creating a new container as the very first one before the system buttons, in which we put two containers - header and specifications
[OK]         fill = 1; // указываем, что контейнер должен занимать все доступное ему место
 <-  указываем, что контейнер должен занимать все доступное ему место
 ->  specifying that the container should occupy all the space available to it
[OK]         type = SPLITV; // указываем, что контейнер будет вертикальным сплиттером
 <-  указываем, что контейнер будет вертикальным сплиттером
 ->  specifying that the container will be a vertical splitter
[OK]         MOVE BOX(o) { // переносим в новый контейнер все, что касается объекта o
 <-  переносим в новый контейнер все, что касается объекта o
 ->  moving everything related to the object o to the new container
[OK]             PANEL(o) { // настроим как отображаются свойства в панели объекта o
 <-  настроим как отображаются свойства в панели объекта o
 ->  configuring how properties are displayed in the object o panel
[OK]                 type = CONTAINERV; // делаем, чтобы все потомки шли сверху вниз
 <-  делаем, чтобы все потомки шли сверху вниз
 ->  making all descendants go from top to bottom
[OK]                 NEW headerRow1 { // создаем контейнер - первый ряд
 <-  создаем контейнер - первый ряд
 ->  creating a container - the first row
[OK]                     MOVE PROPERTY(date(o)) { // переносим свойство даты заказа
 <-  переносим свойство даты заказа
 ->  moving the order date property
[OK]                         caption = 'Дата редактируемого заказа'; // "перегружаем" заголовок свойства в дизайне формы (вместо стандартного)
 <-  "перегружаем" заголовок свойства в дизайне формы (вместо стандартного)
 ->  "overriding" the property caption in the form design (instead of the standard one)
[OK]                         toolTip = 'Введите сюда дату, когда был сделан заказ'; //задаем подсказку для свойства дата заказа
 <- задаем подсказку для свойства дата заказа
 -> setting a hint for the order date property
[OK]                         background = #00FFFF; // делаем фон красным
 <-  делаем фон красным
 ->  making the background red
[OK]                     MOVE PROPERTY(time(o)) { // переносим свойство времени заказа
 <-  переносим свойство времени заказа
 ->  moving the order time property
[OK]                         foreground = #FF00FF; // делаем цвет зеленым
 <-  делаем цвет зеленым
 ->  making the color green
[OK]                     MOVE PROPERTY(number(o)) { // переносим свойство номер заказа
 <-  переносим свойство номер заказа
 ->  moving the order number property
[OK]                         charWidth = 5; // ставим, что пользователю желательно должно показываться 5 символов
 <-  ставим, что пользователю желательно должно показываться 5 символов
 ->  setting that the user should preferably be shown 5 characters
[OK]                     MOVE PROPERTY(series(o)); // переносим свойство серия заказа
 <-  переносим свойство серия заказа
 ->  moving the order series property
[OK]                     type = CONTAINERV; // потомки - сверху вниз
 <-  потомки - сверху вниз
 ->  descendants - from top to bottom
[OK]             size = (400, 300); //указываем, что контейнер o.box должен иметь базовый размер 400x300 пикселей
 <- указываем, что контейнер o.box должен иметь базовый размер 400x300 пикселей
 -> specifying that the container o.box should have a base size of 400x300 pixels
[OK]         NEW detailPane { // создаем контейнер, в котором будут хранится различные спецификации по заказу
 <-  создаем контейнер, в котором будут хранится различные спецификации по заказу
 ->  creating a container that will store various specifications for the order
[OK]             type = TABBED; // помечаем, что этот контейнер должен быть панелью закладок, где закладками являются его потомки
 <-  помечаем, что этот контейнер должен быть панелью закладок, где закладками являются его потомки
 ->  marking that this container should be a tab panel, where its descendats are tabs
[OK]             MOVE BOX(d) { // добавляем контейнер с строками заказа как одну из закладок верхней панели
 <-  добавляем контейнер с строками заказа как одну из закладок верхней панели
 ->  adding a container with order lines as one of the tabs in the top panel
[OK]                 caption = 'Строки'; // задаем заголовок панели закладки
 <-  задаем заголовок панели закладки
 ->  setting the caption of the tab panel
[OK]                 PROPERTY(index(d)) { focusable = FALSE; } // делаем, чтобы колонка с номером строки никогда не могла иметь фокус
 <-  делаем, чтобы колонка с номером строки никогда не могла иметь фокус
 ->  making the row number column never have focus
[OK]                     defaultComponent = TRUE; // делаем, чтобы по умолчанию фокус при открытии формы устанавливался на таблицу строк
 <-  делаем, чтобы по умолчанию фокус при открытии формы устанавливался на таблицу строк
 ->  making sure that by default the focus when opening the form is set to the row table
[OK]             MOVE BOX(s) { // добавляем контейнер с итогами по sku как одну из закладок detailPane
 <-  добавляем контейнер с итогами по sku как одну из закладок detailPane
 ->  adding a container with sku totals as one of the detailPane tabs
[OK] // разбиваем определение формы на две инструкции (вторую инструкцию можно перенести в другой модуль)
 <-  разбиваем определение формы на две инструкции (вторую инструкцию можно перенести в другой модуль)
 ->  splitting the form definition into two instructions (the second instruction can be transferred to another module)
[OK]     REMOVE TOOLBARLEFT; // убираем из иерархии контейнер с кнопками печати и экспорта в xls, тем самым делая их невидимыми
 <-  убираем из иерархии контейнер с кнопками печати и экспорта в xls, тем самым делая их невидимыми
 ->  removing from the hierarchy the container with the print and export buttons to xls, thereby making them invisible
[OK]     PROPERTIES(i) NEWSESSION DELETE // добавляем на форму кнопку удаления
 <-  добавляем на форму кнопку удаления
 ->  adding a delete button to the form
[OK]     OBJECTS g = ItemGroup BEFORE i // добавляем на форму объект группы товаров перед товаром
 <-  добавляем на форму объект группы товаров перед товаром
 ->  adding a product group object to the form before the product
[OK]     FILTERS itemGroup(i) == g // если бы объект был добавлен после объекта с товарами, то фильтрация шла бы по группе товаров, а не по товарам
 <-  если бы объект был добавлен после объекта с товарами, то фильтрация шла бы по группе товаров, а не по товарам
 ->  if the object was added after the object with products, then filtering would go by the group of products, and not by products

In samples/documentation/src/main/lsfusion/InstructionSample.lsf of Category comment - Number of lines: 317; Number of occurances: 43

[OK] GROUP base : root; // Заголовком этой группы будет 'base'
 <-  Заголовком этой группы будет 'base'
 ->  The caption of this group will be 'base'
[OK] GROUP local 'Локальные свойства'; // Родительской группой local будет являться System.private
 <-  Родительской группой local будет являться System.private
 ->  The parent group of local will be System.private
[OK] // отправить email, когда остаток в результате применения изменений сессии стал меньше 0
 <-  отправить email, когда остаток в результате применения изменений сессии стал меньше 0
 ->  send an email when the balance is less than 0 as a result of applying session changes
[OK] // при добавлении клиента, по умолчанию, предоставить ему заданную скидку
 <-  при добавлении клиента, по умолчанию, предоставить ему заданную скидку
 ->  when adding a client, by default, give him the specified discount
[OK] // остаток не меньше 0
 <-  остаток не меньше 0
 ->  balance not less than 0
[OK] // "эмуляция" политики безопасности
 <-  "эмуляция" политики безопасности
 ->  "emulating" security policy
[OK]     CHECKED BY sku[OrderDetail] // будет применяться фильтр по доступным sku при выборе товара для строки заказа
 <-  будет применяться фильтр по доступным sku при выборе товара для строки заказа
 ->  a filter by available sku when selecting an item for an order line will be applied
[OK] // для товара должны быть заданы штрих-код и наименование
 <-  для товара должны быть заданы штрих-код и наименование
 ->  the product must have a barcode and name specified
[OK] // для строки документа должен быть задан документ, и при удалении документа, чтобы удалялись строки этого документа
 <-  для строки документа должен быть задан документ, и при удалении документа, чтобы удалялись строки этого документа
 ->  for a document line, a document must be specified, and when deleting a document, the lines of this document should be deleted
[OK] // равносильно объявлению document = DATA Invoice (InvoiceLine) NONULL DELETE;
 <-  равносильно объявлению document = DATA Invoice (InvoiceLine) NONULL DELETE;
 ->  is equivalent to declaring document = DATA Invoice (InvoiceLine) NONULL DELETE;
[OK] // агрегация для f(a,b) создавать объект класса x, у которого свойство a(x) равняется a, а свойство b(x) равняется b
 <-  агрегация для f(a,b) создавать объект класса x, у которого свойство a(x) равняется a, а свойство b(x) равняется b
 ->  aggregation for f(a, b) create an object of class x, whose property a(x) equals a, and property b(x) equals b
[OK] CLASS ABSTRACT Document; // Заголовком этого класса будет 'Document'
 <-  Заголовком этого класса будет 'Document'
 ->  The caption of this class will be 'Document'
[OK] CLASS Musician : Person, Worker; // множественное наследование
 <-  множественное наследование
 ->  multiple inheritance
[OK] CLASS Barcode 'Штрих-код'; // Родительским классом Barcode будет класс System.Object
 <-  Родительским классом Barcode будет класс System.Object
 ->  The parent class of Barcode will be the System.Object class
[OK]     NEW FOLDER catalogs 'Справочники' WINDOW toolbar { // создаем новую папку навигатора и делаем, чтобы все ее потомки отображались в окно с вертикальным тулбаром
 <-  создаем новую папку навигатора и делаем, чтобы все ее потомки отображались в окно с вертикальным тулбаром
 ->  creating a new navigator folder and making all its descendants appear in a window with a vertical toolbar
[OK]         NEW items; // создаем в папке элемент-форму для формы items, имя элемента по умолчанию равняется имени формы 
 <-  создаем в папке элемент-форму для формы items, имя элемента по умолчанию равняется имени формы 
 ->  creating a form element for the items form in the folder, the default element name is the form name 
[OK]     catalogs {  // инструкция редактирования элемента навигатора
 <-  инструкция редактирования элемента навигатора
 ->  navigator element editing instruction
[OK]         NEW FORM stocksNavigator 'Склады' = stocks; // создаем элемент-форму stocksNavigator для формы stocls и добавляем в папку catalogs последним элементом
 <-  создаем элемент-форму stocksNavigator для формы stocls и добавляем в папку catalogs последним элементом
 ->  creating a stocksNavigator form element for the stocks form and adding the last element to the catalogs folder
[OK]         NEW legalEntities AFTER items; // создаем элемент-форму с именем legalEntities в папку catalogs непосредственно за элементом items
 <-  создаем элемент-форму с именем legalEntities в папку catalogs непосредственно за элементом items
 ->  creating a form element named legalEntities in the catalogs folder right after the items element
[OK]     NEW FOLDER documents 'Документы' WINDOW toolbar { // создаем еще одну папку, элементы которой будут также отображаться в окно с вертикальным тулбаром
 <-  создаем еще одну папку, элементы которой будут также отображаться в окно с вертикальным тулбаром
 ->  creating another folder, the elements of which will also be displayed in a window with a vertical toolbar
[OK]                                                       // сами папки будут отображаться в окне root, и при выборе одной из них в окне с вертикальным 
 <-  сами папки будут отображаться в окне root, и при выборе одной из них в окне с вертикальным 
 ->  the folders themselves will be displayed in the root window, and when the user selects one of them in a window with a vertical 
[OK]                                                       // тулбаром будут показаны потомки именно этой папки
 <-  тулбаром будут показаны потомки именно этой папки
 ->  toolbar the descendants of this particular folder will be shown
[OK]         NEW ACTION hi;   // создаем элемент-действие
 <-  создаем элемент-действие
 ->  creating an action element
[OK]         NEW ACTION h=hello;   // создаем элемент-действие
 <-  создаем элемент-действие
 ->  creating an action element
[OK]         MOVE shipments BEFORE h; // инструкция перемещения элемента shipments из папки catalogs в папку document перед элементом hello     
 <-  инструкция перемещения элемента shipments из папки catalogs в папку document перед элементом hello     
 ->  an instruction to move the shipments element from the catalogs folder to the document folder before the hello element     
[OK] // cоздание системных окон в модуле System
 <-  cоздание системных окон в модуле System
 ->  creating system windows in the System module
[OK] // меню без скроллбаров под окном root
 <-  меню без скроллбаров под окном root
 ->  menu without scrollbars under the root window
[OK] // горизонтальный тулбар внизу рабочего стола, в котором все кнопки будут выравниваться по центру, а текст выравниваться вверх
 <-  горизонтальный тулбар внизу рабочего стола, в котором все кнопки будут выравниваться по центру, а текст выравниваться вверх
 ->  a horizontal toolbar at the bottom of the desktop, in which all buttons will be centered and text will be aligned up
[OK] // в этот тулбар можно, например, помещать формы для быстрого открытия
 <-  в этот тулбар можно, например, помещать формы для быстрого открытия
 ->  in this toolbar, for example, it is possible to place forms for quick opening
[OK] EXTEND CLASS Box : Quadrilateral; // Добавляем наследование
 <-  Добавляем наследование
 ->  Adding inheritance
[OK] EXTEND CLASS ShapeType { // Добавляем статический объект
 <-  Добавляем статический объект
 ->  Adding a static object
[OK] name(CClass c) += name(c); // Здесь слева будет найден name[AClass], потому что поиск идет только среди абстрактных свойств, справа же будет найден name[CClass]
 <-  Здесь слева будет найден name[AClass], потому что поиск идет только среди абстрактных свойств, справа же будет найден name[CClass]
 ->  Here name[AClass] will be found on the left, because the search goes only among abstract properties, and on the right name[CClass] will be found
[OK]         whoAmI(a); // для каждого объекта будет выдано соответствующее сообщение
 <-  для каждого объекта будет выдано соответствующее сообщение
 ->  a corresponding message will be shown for each object
[OK] // сначала выполниться 1е действие, потом 2е действие
 <-  сначала выполниться 1е действие, потом 2е действие
 ->  first, the 1st action is executed, then the 2nd action
[OK]     object##Name 'Имя'##caption = DATA BPSTRING[100](###object); // делаем заглавной первую букву
 <-  делаем заглавной первую букву
 ->  capitalizing the first letter
[OK] @objectProperties(flower, BPSTRING[100], ); // если не передать параметр, то он будет пустым
 <-  если не передать параметр, то он будет пустым
 ->  if the parameter is not passed, then it will be empty
[OK]  // такое свойство нельзя материализовать, так как оно не NULL для бесконечного числа дат
 <-  такое свойство нельзя материализовать, так как оно не NULL для бесконечного числа дат
 ->  such a property cannot be materialized, since it is not NULL for an infinite number of dates
[OK] TABLE skuStock (Sku, Stock); // в ней будет храниться свойство in
 <-  в ней будет храниться свойство in
 ->  it will store the in property
[OK] TABLE skuDate (Sku, DATE); // в ней будет храниться свойство Sku
 <-  в ней будет храниться свойство Sku
 ->  it will store the Sku property
[OK] BEFORE changeName(Sku s, STRING[100] name) DO MESSAGE 'Changing user name'; // Сообщение будет показано перед каждым вызовом changeName
 <-  Сообщение будет показано перед каждым вызовом changeName
 ->  The message will be shown before each call to changeName
[OK] AFTER changePrice(Sku s, DATE d, NUMERIC[10,2] price) DO MESSAGE 'Price was changed'; // Сообщение будет показано после каждого вызова changePrice
 <-  Сообщение будет показано после каждого вызова changePrice
 ->  A message will be shown after each call to changePrice
[OK] };  // точка с запятой здесь не нужна, но ее наличие не является ошибкой
 <-  точка с запятой здесь не нужна, но ее наличие не является ошибкой
 ->  semicolon is not needed here, but its presence is not an error
[OK] ;;;; // это является допустимым кодом на lsFusion
 <-  это является допустимым кодом на lsFusion
 ->  this is valid lsFusion code

In samples/documentation/src/main/lsfusion/LanguageSample.lsf of Category comment - Number of lines: 30; Number of occurances: 6

[OK] // Заголовок модуля
 <-  Заголовок модуля
 ->  Module caption
[OK] // Тело модуля
 <-  Тело модуля
 ->  Module body
[OK] // Объявление классов 
 <-  Объявление классов 
 ->  Classes declaration 
[OK] // Объявление свойств 
 <-  Объявление свойств 
 ->  Properties declaration 
[OK] // Объявление формы 
 <-  Объявление формы 
 ->  Form declaration 
[OK] // Добавление формы в навигатор 
 <-  Добавление формы в навигатор 
 ->  Adding a form to the navigator 

In samples/documentation/src/main/lsfusion/ModuleSample.lsf of Category comment - Number of lines: 9; Number of occurances: 6

[OK] MODULE EmployeeExample;	 	// Задаем имя модуля
 <-  Задаем имя модуля
 ->  Defining the module name
[OK] REQUIRE System, Utils;	 	// Перечисляем модули, от которых зависит модуль Employee
 <-  Перечисляем модули, от которых зависит модуль Employee
 ->  Listing the modules that the Employee module depends on
[OK] NAMESPACE Employee;		 	// Задаем пространство имен
 <-  Задаем пространство имен
 ->  Setting the namespace
[OK] CLASS Employee 'Сотрудник';	// Создаем класс
 <-  Создаем класс
 ->  Creating a class
[OK] CLASS Position 'Должность'; // Создаем еще один класс
 <-  Создаем еще один класс
 ->  Creating another class
[OK] employeePosition(employee) = DATA Position (Employee); // Создаем свойство
 <-  Создаем свойство
 ->  Creating property

In samples/documentation/src/main/lsfusion/OperatorPropertySample.lsf of Category comment - Number of lines: 371; Number of occurances: 28

[OK] secondAttachment(Letter l) = letterAttachments(l)[2]; // возвращает attachment2
 <-  возвращает attachment2
 ->  returns attachment2
[OK] rateChargeExchange(invoice) = ABSTRACT NUMERIC[14,6] (Invoice);             // В данном случае создается ABSTRACT MULTI EXCLUSIVE
 <-  В данном случае создается ABSTRACT MULTI EXCLUSIVE
 ->  In this case, ABSTRACT MULTI EXCLUSIVE is created
[OK] backgroundSku 'Цвет' (d) = ABSTRACT CASE FULL COLOR (InvoiceDetail); // В данном случае создается ABSTRACT CASE OVERRIDE LAST, и если будут
 <-  В данном случае создается ABSTRACT CASE OVERRIDE LAST, и если будут
 ->  In this case, ABSTRACT CASE OVERRIDE LAST is created, and if there are
[OK]                                                                             // подходить несколько реализаций, то вычислена будет первая из них
 <-  подходить несколько реализаций, то вычислена будет первая из них
 ->  several suitable implementations, the first of them will be calculated
[OK] overVAT = ABSTRACT VALUE OVERRIDE FIRST Range (InvoiceDetail);          // Здесь же будет вычислена последняя из подходящих реализаций
 <-  Здесь же будет вычислена последняя из подходящих реализаций
 ->  The last matching implementation will be calculated here
[OK] //Форма с двумя закладками
 <- Форма с двумя закладками
 -> Form with two tabs
[OK] //Активна ли закладка 'Последние'
 <- Активна ли закладка 'Последние'
 -> If the 'Recent' tab is active
[OK] a(B b) += WHEN CLASS(b(b)) THEN b(b); // равносильно WHEN b IS B THEN b(b)
 <-  равносильно WHEN b IS B THEN b(b)
 ->  is equivalent to WHEN b IS B THEN b(b)
[OK] fullName(Person p) = CONCAT ' ', firstName(p), middleName(p), lastName(p);     // если какая-то часть имени не задана, то эта часть будет пропущена вместе с пробелом
 <-  если какая-то часть имени не задана, то эта часть будет пропущена вместе с пробелом
 ->  if some part of the name is not specified, then this part will be skipped along with a space
[OK] round(number, digits) = FORMULA 'round(CAST(($1) as numeric),$2)';  // свойство с двумя параметрами: округляемым числом и количеством знаков после запятой
 <-  свойство с двумя параметрами: округляемым числом и количеством знаков после запятой
 ->  a property with two parameters: a rounded number and the number of decimal places
[OK] toString15(str) = FORMULA BPSTRING[15] 'CAST($1 AS character(15))';   // свойство, преобразовывающее значение, переданное в качестве аргумента, к строковому типу длиной в 15 символов. 
 <-  свойство, преобразовывающее значение, переданное в качестве аргумента, к строковому типу длиной в 15 символов. 
 ->  a property that converts the value passed as an argument to a 15-character string. 
[OK] jumpWorkdays = FORMULA NULL DATE PG 'jumpWorkdays($1, $2, $3)', MS 'dbo.jumpWorkdays($1, $2, $3)'; // свойство с двумя различными реализациями для разных диалектов SQL
 <-  свойство с двумя различными реализациями для разных диалектов SQL
 ->  a property with two different implementations for different SQL dialects
[OK] countryName = GROUP AGGR Country country WHERE country IS Country BY name(country); // получается свойство (STRING[100]) -> Country
 <-  получается свойство (STRING[100]) -> Country
 ->  property (STRING[100]) -> Country is obtained
[OK] sex (Human h) = IF h IS Male THEN 'Male' ELSE ('Female' IF h IS Female); // если h будет другого класса, то будет NULL
 <-  если h будет другого класса, то будет NULL
 ->  if h is of another class, it will be NULL
[OK] hypotenuseSq2(triangle) = [ x*x + y*y](cathetus1(triangle), cathetus2(triangle)); // аналогичное свойство, заданное с помощью композиции
 <-  аналогичное свойство, заданное с помощью композиции
 ->  a similar property set using composition
[OK] // определяет место команды в конференции
 <-  определяет место команды в конференции
 ->  determines the place of the team in the conference
[OK] // строим порядковые индексы объектов в базе по возрастанию их внутренних идентификаторов (то есть в порядке создания)
 <-  строим порядковые индексы объектов в базе по возрастанию их внутренних идентификаторов (то есть в порядке создания)
 ->  building ordinal indexes of objects in the database in ascending order of their internal IDs (i.e., in the order of creation)
[OK] // находит команду, следующую в турнирной таблице по конференции
 <-  находит команду, следующую в турнирной таблице по конференции
 ->  finds the team next in the conference standings
[OK] // пример пропорционального распределения
 <-  пример пропорционального распределения
 ->  proportional distribution example
[OK] // пример распределения с лимитами
 <-  пример распределения с лимитами
 ->  example of distribution with limits
[OK] // выдает по очереди все изменения f(a) в сессии
 <-  выдает по очереди все изменения f(a) в сессии
 ->  outputs all changes f(a) in the session one by one
[OK] // записать в цену документа, последнюю использованную цену в БД
 <-  записать в цену документа, последнюю использованную цену в БД
 ->  write in the price of the document the last used price in the database
[OK] // PREV важен чтобы не учитывалась цены введенные в этом документе
 <-  PREV важен чтобы не учитывалась цены введенные в этом документе
 ->  PREV is important to ignore the prices entered in this document
[OK] // это особенно важно, если последняя использованная цена будет материализованной, тогда платформа сможет просто считать это значение из таблицы
 <-  это особенно важно, если последняя использованная цена будет материализованной, тогда платформа сможет просто считать это значение из таблицы
 ->  this is especially important if the last used price is materialized, then the platform can simply read this value from the table
[OK] // итерация по integer от from к to (это свойство по умолчанию входит в модуль System)
 <-  итерация по integer от from к to (это свойство по умолчанию входит в модуль System)
 ->  iteration over an integer from 'from' to 'to' (this property is by default included in the System module)
[OK] // считает количество различных путей от a до b в графе
 <-  считает количество различных путей от a до b в графе
 ->  counts the number of different paths from a to b in the graph
[OK] // определяет на каком уровне находится child от parent, и null если не является потомком (тем самым это свойство можно использовать для определения всех child'ов)
 <-  определяет на каком уровне находится child от parent, и null если не является потомком (тем самым это свойство можно использовать для определения всех child'ов)
 ->  defines at what level child is from parent, and null if it is not a child (thus this property can be used to define all children)
[OK] // числа Фибоначчи, свойство высчитывает все числа Фибоначи до значения to, (после будет возвращать null)
 <-  числа Фибоначчи, свойство высчитывает все числа Фибоначи до значения to, (после будет возвращать null)
 ->  Fibonacci numbers, the property calculates all Fibonacci numbers up to the value to, (afterwards it will return null)

In samples/documentation/src/main/lsfusion/PropertySample.lsf of Category comment - Number of lines: 56; Number of occurances: 14

[OK] cost 'Стоимость' (i) = DATA NUMERIC[12,3] (Item);		// cвойство задано контекстно-независимым оператором-свойством DATA
 <-  cвойство задано контекстно-независимым оператором-свойством DATA
 ->  property defined by the context-independent DATA property operator
[OK] weightedSum 'Взвешенная сумма' (a, b) = 2*a + 3*b; 		// cвойство задано выражением 
 <-  cвойство задано выражением 
 ->  property defined by expression 
[OK] diff = a - b; 											// заголовком этого свойства будет 'diff', а параметрами - (a, b)
 <-  заголовком этого свойства будет 'diff', а параметрами - (a, b)
 ->  the caption of this property will be 'diff' and the parameters will be (a, b)
[OK] teamName 'Название команды' = DATA BPSTRING[30](Team) IN baseGroup TABLE team; // свойство задано оператором DATA с указанием дополнительных опций свойства
 <-  свойство задано оператором DATA с указанием дополнительных опций свойства
 ->  property defined by DATA operator with additional property options
[OK]     north, east, south, west                        // объявляем статические объекты
 <-  объявляем статические объекты
 ->  declaring static objects
[OK] isNorth (Direction d) = d == Direction.north;  // здесь константное свойство создается из объекта Direction.north, которое затем используется оператором сравнения для построения свойства isNorth
 <-  здесь константное свойство создается из объекта Direction.north, которое затем используется оператором сравнения для построения свойства isNorth
 ->  here a constant property is created from a Direction.north object which is then used by the comparison operator to construct the isNorth property
[OK] defaultDate() = 1982_07_13;                         // здесь константное свойство создается из литерала, описывающего дату
 <-  здесь константное свойство создается из литерала, описывающего дату
 ->  here a constant property is created from a literal describing the date
[OK] isChild (Man m) = age(m) < 17;                        // здесь используется константное свойство, созданное из целого числа (целочисленного литерала)
 <-  здесь используется константное свойство, созданное из целого числа (целочисленного литерала)
 ->  here a constant property is used created from an integer (integer literal)
[OK] messageF  { MESSAGE f(5); } // успешно выполнится
 <-  успешно выполнится
 ->  will be executed successfully
[OK] messageG  { MESSAGE g(); } // f(b) не NULL для бесконечного числа b, платформа выдаст ошибку
 <-  f(b) не NULL для бесконечного числа b, платформа выдаст ошибку
 ->  f(b) is not NULL for infinite number b, the platform will throw an error
[OK] printFWithD { PRINT f OBJECTS d=currentDate(); } // успешно выполнится
 <-  успешно выполнится
 ->  will be executed successfully
[OK] printFWithoutD { PRINT f; } // фильтра для дат нет, а d IS DATE не NULL для бесконечного числа d, платформа выдаст ошибку
 <-  фильтра для дат нет, а d IS DATE не NULL для бесконечного числа d, платформа выдаст ошибку
 ->  there is no filter for dates, and d IS DATE is not NULL for an infinite number d, the platform will throw an error
[OK] messageHS  { MESSAGE hs(); } // теоретически должна выдать 3, но платформа все равно выдаст ошибку
 <-  теоретически должна выдать 3, но платформа все равно выдаст ошибку
 ->  theoretically, it should return 3, but the platform will still throw an error
[OK] hi = GROUP SUM 1 IF iterate(a, 4, 6); // workaround: для работы с интервалами можно использовать свойство iterate (оно в свою очередь реализуется через рекурсию) 
 <-  workaround: для работы с интервалами можно использовать свойство iterate (оно в свою очередь реализуется через рекурсию) 
 ->  workaround: to work with intervals, the iterate property can be used (which, in turn, is implemented through recursion) 

In samples/documentation/src/main/lsfusion/ResolveBSample.lsf of Category comment - Number of lines: 17; Number of occurances: 6

[OK] h(C c) = f(c); // найдет верхнее объявление - ResolveB.f[B]
 <-  найдет верхнее объявление - ResolveB.f[B]
 ->  will find the upper declaration - ResolveB.f[B]
[OK] j(C c) = ResolveA.f(c); // найдет объявление в ResolveA - ResolveA.f[C]
 <-  найдет объявление в ResolveA - ResolveA.f[C]
 ->  will find the declaration in ResolveA - ResolveA.f[C]
[OK] z(C c) = f[A](c); // найдет объявление в ResolveA - ResolveA.f[A]
 <-  найдет объявление в ResolveA - ResolveA.f[A]
 ->  will find the declaration in ResolveA - ResolveA.f[A]
[OK]     f(c) <- 1; // найдет верхнее объявление - f[B]
 <-  найдет верхнее объявление - f[B]
 ->  will find the upper declaration - f[B]
[OK]     MESSAGE f(a); // найдет верхнее объявление - f[B]
 <-  найдет верхнее объявление - f[B]
 ->  will find the upper declaration - f[B]
[OK]     ResolveB.f(c) <- 1; // найдет верхнее объявление в ResolveB - ResolveB.f[B]
 <-  найдет верхнее объявление в ResolveB - ResolveB.f[B]
 ->  will find the upper declaration in ResolveB - ResolveB.f[B]

In samples/documentation/src/main/lsfusion/ResolveCSample.lsf of Category comment - Number of lines: 11; Number of occurances: 3

[OK] x(B b) = f(b); // найдет объявление в ResolveA - ResolveA.f[A]
 <-  найдет объявление в ResolveA - ResolveA.f[A]
 ->  will find the declaration in ResolveA - ResolveA.f[A]
[OK] y(B b) = ResolveB.f(b); // найдет объявление в ResolveA - ResolveB.f[B]
 <-  найдет объявление в ResolveA - ResolveB.f[B]
 ->  will find the declaration in ResolveA - ResolveB.f[B]
[OK] @defineSmth(A, B); // найдет объявление в ResolveA - ResolveA.defineSmth(prm1, prm2)
 <-  найдет объявление в ResolveA - ResolveA.defineSmth(prm1, prm2)
 ->  will find the declaration in ResolveA - ResolveA.defineSmth(prm1, prm2)

In samples/documentation/src/main/lsfusion/StaticObjectSample.lsf of Category comment - Number of lines: 25; Number of occurances: 1

[OK] // создаем форму по выбору объекта класса Direction
 <-  создаем форму по выбору объекта класса Direction
 ->  creating a form by choosing an object of Direction class

In samples/documentation/src/main/lsfusion/UseCaseActionBook.lsf of Category comment - Number of lines: 9; Number of occurances: 4

[OK] CLASS Book; // объявляем класс книга
 <-  объявляем класс книга
 ->  declaring class "book"
[OK] overCopy  ABSTRACT ( Book, Book); // абстрактное действие, которое принимает на вход две книги и является "точкой входа", в которую другие модули смогут добавлять реализацию
 <-  абстрактное действие, которое принимает на вход две книги и является "точкой входа", в которую другие модули смогут добавлять реализацию
 ->  abstract action that takes an input two books and is "a point of input", to which other modules can add realization
[OK] copy (Book book)  { // создаем действие по копированию книги
 <-  создаем действие по копированию книги
 ->  creating action on book copy
[OK]     NEW b = Book { // добавляем новую книгу
 <-  добавляем новую книгу
 ->  adding new book

In samples/documentation/src/main/lsfusion/UseCaseActionMyBook.lsf of Category comment - Number of lines: 8; Number of occurances: 2

[OK] name = DATA STRING[100] (Book); // добавляем к товару некоторое свойство name
 <-  добавляем к товару некоторое свойство name
 ->  adding some name property to the product
[OK]     name(d) <- name(s); // подключаем к действию копирования товара копирование созданного свойства
 <-  подключаем к действию копирования товара копирование созданного свойства
 ->  connecting the copying of the created property to the product copy action

In samples/documentation/src/main/lsfusion/UseCaseCIO.lsf of Category comment - Number of lines: 84; Number of occurances: 6

[OK] // Вариант 1
 <-  Вариант 1
 ->  Option 1
[OK] // Вариант 2
 <-  Вариант 2
 ->  Option 2
[OK] // Вариант 1
 <-  Вариант 1
 ->  Option 1
[OK] // Вариант 2
 <-  Вариант 2
 ->  Option 2
[OK] // Эквивалентно :
 <-  Эквивалентно :
 ->  Equivalent to:
[OK] // Эквивалентно :
 <-  Эквивалентно :
 ->  Equivalent to:

In samples/documentation/src/main/lsfusion/UseCaseClassMA.lsf of Category comment - Number of lines: 4; Number of occurances: 2

[OK] CLASS ABSTRACT A; // объявляем абстрактный класс
 <-  объявляем абстрактный класс
 ->  declaring an abstract class
[OK] a = ABSTRACT BPSTRING[10] (A); // объявляем абстрактное свойство a <-  объявляем абстрактное свойство a
 ->  declaring an abstract property a

In samples/documentation/src/main/lsfusion/UseCaseClassMB.lsf of Category comment - Number of lines: 4; Number of occurances: 2

[OK] CLASS B; // объявляем класс B
 <-  объявляем класс B
 ->  declaring class B
[OK] b = DATA BPSTRING[10] (B); // объявляем первичное свойство b для класса B <-  объявляем первичное свойство b для класса B
 ->  declaring the data property b for class B

In samples/documentation/src/main/lsfusion/UseCaseClassMBA.lsf of Category comment - Number of lines: 6; Number of occurances: 3

[OK] REQUIRE MA, MB; // указываем, что модуль MBA зависит от модулей MA и MB, чтобы в нем можно было использовать элементы системы, объявляемые в них
 <-  указываем, что модуль MBA зависит от модулей MA и MB, чтобы в нем можно было использовать элементы системы, объявляемые в них
 ->  specifying that the MBA module depends on the MA and MB modules so that the system elements declared in them can be used in that module
[OK] EXTEND CLASS B : A; // донаследуем класс B от A
 <-  донаследуем класс B от A
 ->  inheriting class B from A
[OK] a(ba) += b(ba); // указываем, что для абстрактного свойства a, в качестве реализации должно использоваться свойство B <-  указываем, что для абстрактного свойства a, в качестве реализации должно использоваться свойство B
 ->  specifying that for the abstract property a, property B should be used as an implementation

In samples/documentation/src/main/lsfusion/UseCaseClassMyModule.lsf of Category comment - Number of lines: 16; Number of occurances: 5

[OK] META defineMyClass (className) // объявляем метакод defineMyClass с параметром className
 <-  объявляем метакод defineMyClass с параметром className
 ->  declaring the defineMyClass metacode with the className parameter
[OK]     CLASS className; // объявляем класс с именем className
 <-  объявляем класс с именем className
 ->  declaring a class named className
[OK]     myProperty###className = DATA BPSTRING[20] (className); // добавляем для созданного класса свойство с именем myProperty+className
 <-  добавляем для созданного класса свойство с именем myProperty+className
 ->  adding a property named myProperty + className for the created class
[OK] @defineMyClass(MyClass); // вызываем метакод, который создаст класс и свойство
 <-  вызываем метакод, который создаст класс и свойство
 ->  calling the metacode that will create the class and property
[OK] EXTEND CLASS MyClass : MySuperClass; // наследуем MyClass от MySuperClass, при этом MyClass "получит" все свойства, которые объявлены для класса MySuperClass
 <-  наследуем MyClass от MySuperClass, при этом MyClass "получит" все свойства, которые объявлены для класса MySuperClass
 ->  inheriting MyClass from MySuperClass, while MyClass will "receive" all the properties that are declared for the MySuperClass class

In samples/documentation/src/main/lsfusion/UseCaseConstraint.lsf of Category comment - Number of lines: 82; Number of occurances: 4

[OK] // Вариант 1
 <-  Вариант 1
 ->  Option 1
[OK] // Вариант 2
 <-  Вариант 2
 ->  Option 2
[OK] // Вариант 1
 <-  Вариант 1
 ->  Option 1
[OK] // Вариант 2
 <-  Вариант 2
 ->  Option 2

In samples/documentation/src/main/lsfusion/UseCaseCreate.lsf of Category comment - Number of lines: 137; Number of occurances: 2

[OK] // Заказы
 <-  Заказы
 ->  Orders
[OK] // Счета
 <-  Счета
 ->  Accounts

In samples/documentation/src/main/lsfusion/UseCaseCRUD.lsf of Category comment - Number of lines: 76; Number of occurances: 1

[OK] FORM book 'Книга' // форма для отображения "карточки" книги
 <-  форма для отображения "карточки" книги
 ->  form for displaying the book card

In samples/documentation/src/main/lsfusion/UseCaseDelete.lsf of Category comment - Number of lines: 34; Number of occurances: 2

[OK]     // Вариант 1
 <-  Вариант 1
 ->  Option 1
[OK]     // Вариант 2
 <-  Вариант 2
 ->  Option 2

In samples/documentation/src/main/lsfusion/UseCaseDependentProperties.lsf of Category comment - Number of lines: 60; Number of occurances: 2

[OK] // 1 вариант
 <-  1 вариант
 ->  1 option
[OK] // 2 вариант
 <-  2 вариант
 ->  2 option

In samples/documentation/src/main/lsfusion/UseCaseDesign.lsf of Category comment - Number of lines: 108; Number of occurances: 14

[OK]     // добавляем новый контейнер в самое начало формы
 <-  добавляем новый контейнер в самое начало формы
 ->  adding a new container to the very beginning of the form
[OK]         fill = 1; // помечаем, что этот контейнер должен "растягиваться" в верхнем контейнере
 <-  помечаем, что этот контейнер должен "растягиваться" в верхнем контейнере
 ->  marking that this container should "stretch" in the upper container
[OK]         type = SPLITV; // вертикальный сплиттер - то есть может быть только 2 потомка
 <-  вертикальный сплиттер - то есть может быть только 2 потомка
 ->  vertical splitter - that is, there can only be 2 children
[OK]         MOVE BOX(o); // первым контейнером будет список заказов
 <-  первым контейнером будет список заказов
 ->  the first container will be the list of orders
[OK]             fill = 2; // Указываем, что спецификация будет занимать в 2 раза больше места, чем контейнер o.box (для всех таких контейнеров fill, по умолчанию, равен 1)
 <-  Указываем, что спецификация будет занимать в 2 раза больше места, чем контейнер o.box (для всех таких контейнеров fill, по умолчанию, равен 1)
 ->  Specifying that the specification will take up 2 times more space than the o.box container (for all such containers fill, by default, is 1)
[OK]             type = TABBED; // контейнер будет панелью с вкладками
 <-  контейнер будет панелью с вкладками
 ->  the container will be a tabbed panel
[OK]             MOVE BOX(d) { // первой вкладкой будет список строк с книгами
 <-  первой вкладкой будет список строк с книгами
 ->  the first tab will be a list of rows with books
[OK]             MOVE BOX(p) { // второй вкладкой будет список оплат
 <-  второй вкладкой будет список оплат
 ->  the second tab will be the list of payments
[OK]         NEW orderHeader FIRST { // создаем новый контейнер и добавляем в вертикальный сплиттер первым компонентом
 <-  создаем новый контейнер и добавляем в вертикальный сплиттер первым компонентом
 ->  creating a new container and adding the first component to the vertical splitter
[OK]             fill = 1; // нужно сделать, чтобы он "растягивался" внутри orderList, так как в нем будет список заказов 
 <-  нужно сделать, чтобы он "растягивался" внутри orderList, так как в нем будет список заказов 
 ->  it is necessary to make it "stretch" inside the orderList, as it will have a list of orders 
[OK]             // по умолчанию, тип нового контейнера CONTAINERV, то есть все компоненты в нем располагаются сверху вниз
 <-  по умолчанию, тип нового контейнера CONTAINERV, то есть все компоненты в нем располагаются сверху вниз
 ->  by default, the type of the new container is CONTAINERV, that is, all the components in it are arranged from top to bottom
[OK]             NEW filters { // создаем контейнер, в который поместим все компоненты, которые отвечают за фильтрацию
 <-  создаем контейнер, в который поместим все компоненты, которые отвечают за фильтрацию
 ->  creating a container in which all the components that are responsible for filtering will be placed
[OK]                 type = CONTAINERH; // делаем его горизонтальным, чтобы все компоненты шли слева направо
 <-  делаем его горизонтальным, чтобы все компоненты шли слева направо
 ->  making it horizontal so that all components go from left to right
[OK]             MOVE BOX(o); // переносим контейнер со списком заказом в него, так как в сплиттере должно быть ровно два компонента
 <-  переносим контейнер со списком заказом в него, так как в сплиттере должно быть ровно два компонента
 ->  moving the container with the order list to it, since there should be exactly two components in the splitter

In samples/documentation/src/main/lsfusion/UseCaseDocument.lsf of Category comment - Number of lines: 216; Number of occurances: 11

[OK]     INPUT q = INTEGER DO { // запрашиваем число
 <-  запрашиваем число
 ->  requesting a number
[OK]         IF lastOrderDetail(o, b) THEN { // проверяем, есть ли хоть одна строка
 <-  проверяем, есть ли хоть одна строка
 ->  checking if there is at least one row
[OK]             IF q THEN // ввели число
 <-  ввели число
 ->  inputting a number
[OK]                 quantity(OrderDetail d) <- q IF d == lastOrderDetail(o, b) WHERE order(d) == o AND book(d) == b; // записываем количество в последнюю строку с такой книгой
 <-  записываем количество в последнюю строку с такой книгой
 ->  writing the quantity in the last row with such a book
[OK]             ELSE // сбросили число - удаляем строку
 <-  сбросили число - удаляем строку
 ->  the number is dropped - deleting the row
[OK]                 NEW d = OrderDetail { // создаем новую строку
 <-  создаем новую строку
 ->  creating a new row
[OK]         NEW pane { // создаем контейнер после заголовка заказа
 <-  создаем контейнер после заголовка заказа
 ->  creating a container after the order header
[OK] // имплементим свойства счета
 <-  имплементим свойства счета
 ->  implementing invoice properties
[OK] // имплементим свойства строк счета
 <-  имплементим свойства строк счета
 ->  implementing the properties of the invoice lines
[OK] // агрегированный счет
 <-  агрегированный счет
 ->  aggregated invoice
[OK] // агрегированные строки счета
 <-  агрегированные строки счета
 ->  aggregated invoice lines

In samples/documentation/src/main/lsfusion/UseCaseEvents.lsf of Category comment - Number of lines: 79; Number of occurances: 2

[OK] // Вариант 1
 <-  Вариант 1
 ->  Option 1
[OK] // Вариант 2
 <-  Вариант 2
 ->  Option 2

In samples/documentation/src/main/lsfusion/UseCaseExec.lsf of Category comment - Number of lines: 43; Number of occurances: 1

[OK] parent 'Родитель' = DATA Category (Category); // если значение NULL, то родителя нету
 <-  если значение NULL, то родителя нету
 ->  if the value is NULL, then there is no parent

In samples/documentation/src/main/lsfusion/UseCaseExternal.lsf of Category comment - Number of lines: 229; Number of occurances: 1

[OK]     EXTERNAL HTTP 'http://localhost:7651/exec?action=Location.createCity' PARAMS exportFile() TO result;
 <- localhost:7651/exec?action=Location.createCity' PARAMS exportFile() TO result;
 -> localhost=7651/exec?action=Location.importOrderNew' PARAMS exportFile() TO result;

In samples/documentation/src/main/lsfusion/UseCaseFilter.lsf of Category comment - Number of lines: 76; Number of occurances: 3

[OK] balance 'Остаток' = DATA INTEGER (Book, Stock); // для примера сделано первичным свойством, хотя обычно оно вычисляемое
 <-  для примера сделано первичным свойством, хотя обычно оно вычисляемое
 ->  for example it is made a data property, although usually it is calculated
[OK]     // Вариант 1
 <-  Вариант 1
 ->  Option 1
[OK]     // Вариант 2
 <-  Вариант 2
 ->  Option 2

In samples/documentation/src/main/lsfusion/UseCaseFor.lsf of Category comment - Number of lines: 98; Number of occurances: 6

[OK]     // Вариант 1
 <-  Вариант 1
 ->  Option 1
[OK]     // Вариант 2
 <-  Вариант 2
 ->  Option 2
[OK]     // Вариант 1
 <-  Вариант 1
 ->  Option 1
[OK]     // Вариант 2
 <-  Вариант 2
 ->  Option 2
[OK]     // Вариант 1
 <-  Вариант 1
 ->  Option 1
[OK]     // Вариант 2
 <-  Вариант 2
 ->  Option 2

In samples/documentation/src/main/lsfusion/UseCaseFormBarcode.lsf of Category comment - Number of lines: 21; Number of occurances: 10

[OK] CLASS Barcode; // объявляем класс штрих-кода
 <-  объявляем класс штрих-кода
 ->  declaring a barcode class
[OK] id = DATA BPSTRING[13] (Barcode); // создаем свойство с номером штрих-кода
 <-  создаем свойство с номером штрих-кода
 ->  creating a property with a barcode number
[OK] sku = DATA Sku (Barcode); // создаем ссылку штрих-кода на sku
 <-  создаем ссылку штрих-кода на sku
 ->  creating a barcode link to sku
[OK] EXTEND FORM sku // создаем форму Item
 <-  создаем форму Item
 ->  creating the Item form
[OK]     OBJECTS b = Barcode // добавляем объект штрих-кодов
 <-  добавляем объект штрих-кодов
 ->  adding the barcode object
[OK]     PROPERTIES(b) id // добавляем номер штрих-кода в таблицу штрих-кодов
 <-  добавляем номер штрих-кода в таблицу штрих-кодов
 ->  adding the barcode number to the barcode table
[OK]     PROPERTIES(b) NEW, DELETE // добавляем действия по созданию и удалению штрих-кодов
 <-  добавляем действия по созданию и удалению штрих-кодов
 ->  adding actions to create and delete barcodes
[OK]     FILTERS sku(b) == s // делаем, чтобы показывались только штрих-коды этого sku
 <-  делаем, чтобы показывались только штрих-коды этого sku
 ->  making that only barcodes of this sku are displayed
[OK] DESIGN sku { // расширяем дизайн формы Item
 <-  расширяем дизайн формы Item
 ->  expanding the design of the Item form
[OK]         MOVE BOX(b); // делаем контейнер, в котором находится все, что касается штрих-кодов, закладкой в предварительно созданной панели закладок
 <-  делаем контейнер, в котором находится все, что касается штрих-кодов, закладкой в предварительно созданной панели закладок
 ->  making a container, which contains everything related to barcodes, by a tab in the previously created tab panel

In samples/documentation/src/main/lsfusion/UseCaseFormSku.lsf of Category comment - Number of lines: 20; Number of occurances: 8

[OK] CLASS Sku; // объявляем класс Sku
 <-  объявляем класс Sku
 ->  declaring class Sku
[OK] name 'Наименование' = DATA BPSTRING[100] (Sku); // создаем ему свойство имя
 <-  создаем ему свойство имя
 ->  creating a name property for it
[OK] FORM sku 'Sku' // создаем форму Item
 <-  создаем форму Item
 ->  creating the Item form
[OK]     OBJECTS s = Sku PANEL // добавляем объект товар и делаем, чтобы на ней отображался ровно один экземпляр
 <-  добавляем объект товар и делаем, чтобы на ней отображался ровно один экземпляр
 ->  adding a product object and making it display exactly one copy
[OK]     PROPERTIES(s) name // добавляем свойство имени товара на форму
 <-  добавляем свойство имени товара на форму
 ->  adding the product name property to the form
[OK]     NEW skuDetails AFTER BOX(s) { // создаем новый контейнер в стандартный контейнер сразу после i.box
 <-  создаем новый контейнер в стандартный контейнер сразу после i.box
 ->  creating a new container in a standard container right after i.box
[OK]                                   // этот контейнер будет панелью закладок, в который можно будет добавлять закладки со свойствами товара
 <-  этот контейнер будет панелью закладок, в который можно будет добавлять закладки со свойствами товара
 ->  this container will be the tab panel, where tabs with product properties can be added
[OK]         fill = 1; // пусть расширяется на всю форму
 <-  пусть расширяется на всю форму
 ->  let it expand to the whole form

In samples/documentation/src/main/lsfusion/UseCaseImport.lsf of Category comment - Number of lines: 190; Number of occurances: 7

[OK]     listFiles('file://' + serverDirectory());  
 <- ' + serverDirectory());  
 -> ' + serverDirectory());  
[OK]         READ 'file://' + serverDirectory() + '/' + f TO file;
 <- ' + serverDirectory() + '/' + f TO file;
 -> ' + serverDirectory() + '/' + f TO file;
[OK]         move('file://' + serverDirectory() + '/' + f, 'file://' + serverDirectory() + '/' + (IF canceled() THEN 'error/' ELSE 'success/') + f);
 <- ' + serverDirectory() + '/' + f, 'file://' + serverDirectory() + '/' + (IF canceled() THEN 'error/' ELSE 'success/') + f);
 -> ' + serverDirectory() + '/' + f, 'file://' + serverDirectory() + '/' + (IF canceled() THEN 'error/' ELSE 'success/') + f);
[OK]     READ 'jdbc:sqlserver://localhost;databaseName=books;User=import;Password=password@SELECT id, name FROM books' TO file;
 <- localhost;databaseName=books;User=import;Password=password@SELECT id, name FROM books' TO file;
 -> localhost;databaseName=books;User=import;Password=password@SELECT id, name FROM books' TO file;
[OK]     //создаем новые книги
 <- создаем новые книги
 -> creating new books
[OK]     // меняем значения
 <-  меняем значения
 ->  changing values
[OK]     // удаляем книги
 <-  удаляем книги
 ->  deleting books

In samples/documentation/src/main/lsfusion/UseCaseInput.lsf of Category comment - Number of lines: 84; Number of occurances: 9

[OK]      INPUT s = ISTRING[100] // вводим ISTRING[100] "в параметр" s (автоматически оборачивается в REQUEST, то есть доступны групповая корректировки, PASTE и т.п.)
 <-  вводим ISTRING[100] "в параметр" s (автоматически оборачивается в REQUEST, то есть доступны групповая корректировки, PASTE и т.п.)
 ->  inputting ISTRING[100] "into the parameter" s (automatically wrapped in REQUEST, that is, group adjustments, PASTE, etc. are available)
[OK]                      DO // проверка на requestCanceled
 <-  проверка на requestCanceled
 ->  checking for requestCanceled
[OK]           DIALOG booksByGenre OBJECTS // (автоматически оборачивается в REQUEST, то есть доступны групповая корректировки, PASTE и т.п.)
 <-  (автоматически оборачивается в REQUEST, то есть доступны групповая корректировки, PASTE и т.п.)
 ->  (automatically wrapped in REQUEST, that is, group adjustments, PASTE, etc. are available)
[OK]                 g = g NULL, // разрешен NULL на входе
 <-  разрешен NULL на входе
 ->  NULL input allowed
[OK]                     // book(o) NULL - подставляем book(o) на вход (при необходимости можно не указывать вход, то есть писать просто b INPUT ..., что в свою очередь эквивалентно b=NULL NULL INPUT ...)
 <-  book(o) NULL - подставляем book(o) на вход (при необходимости можно не указывать вход, то есть писать просто b INPUT ..., что в свою очередь эквивалентно b=NULL NULL INPUT ...)
 ->  book(o) NULL - substituting book(o) to the input (if necessary, the input can be omitted, that is, the user can simply write b INPUT ..., which in turn is equivalent to b=NULL NULL INPUT ...)
[OK]                     // INPUT b NULL - возвращаем значение этого объекта "в параметр" bk (разрешен возврат NULL то есть будет кнопка сбросить). Так как не указана опция TO, результат будет записан в requestedObject
 <-  INPUT b NULL - возвращаем значение этого объекта "в параметр" bk (разрешен возврат NULL то есть будет кнопка сбросить). Так как не указана опция TO, результат будет записан в requestedObject
 ->  INPUT b NULL - returning the value of this object "in the parameter" bk (return NULL is allowed, that is, there will be a reset button). Since the TO option is not specified, the result will be written to the requestedObject
[OK]                     // CONSTRAINTFILTER - учитываем для объекта b ограничения из предположения что результат будет записан в свойство передаваемое на вход (в данном случае book(o),
 <-  CONSTRAINTFILTER - учитываем для объекта b ограничения из предположения что результат будет записан в свойство передаваемое на вход (в данном случае book(o),
 ->  CONSTRAINTFILTER - taking into account the constraints for object b on the assumption that the result will be written to the property passed to the input (in this case book(o),
[OK]                     // при необходимости можно задать другое выражение в виде CONSTRAINTFILTER = dataBook(o)
 <-  при необходимости можно задать другое выражение в виде CONSTRAINTFILTER = dataBook(o)
 ->  if necessary, another expression can be specified in the form CONSTRAINTFILTER = dataBook(o)
[OK]     DO // проверка на requestCanceled
 <-  проверка на requestCanceled
 ->  checking for requestCanceled

In samples/documentation/src/main/lsfusion/UseCaseLedger.lsf of Category comment - Number of lines: 138; Number of occurances: 2

[OK] // необходимо указывать [SKULedger], так как ReceiptDetail также наследует PriceLedger в этом же примере и платформе надо знать, какое именно свойство надо реализовать
 <-  необходимо указывать [SKULedger], так как ReceiptDetail также наследует PriceLedger в этом же примере и платформе надо знать, какое именно свойство надо реализовать
 ->  [SKULedger] must be specified, since ReceiptDetail also inherits PriceLedger in the same example and the platform needs to know which property needs to be implemented
[OK] // необходимо указывать [PriceLedger], так как ReceiptDetail также наследует SKULedger в этом же примере и платформе надо знать, какое именно свойство надо реализовать
 <-  необходимо указывать [PriceLedger], так как ReceiptDetail также наследует SKULedger в этом же примере и платформе надо знать, какое именно свойство надо реализовать
 ->  [PriceLedger] must be specified, since ReceiptDetail also inherits SKULedger in the same example and the platform needs to know which property to implement

In samples/documentation/src/main/lsfusion/UseCaseMMA.lsf of Category comment - Number of lines: 42; Number of occurances: 2

[OK] // Вариант 1
 <-  Вариант 1
 ->  Option 1
[OK] // Вариант 2
 <-  Вариант 2
 ->  Option 2

In samples/documentation/src/main/lsfusion/UseCaseNewSession.lsf of Category comment - Number of lines: 106; Number of occurances: 3

[OK]     // Вариант 1
 <-  Вариант 1
 ->  Option 1
[OK]     // Вариант 2
 <-  Вариант 2
 ->  Option 2
[OK]     OBJECTS o = Order PANEL // Не добавляем свойств, чтобы этот объект не был вообще виден на форме
 <-  Не добавляем свойств, чтобы этот объект не был вообще виден на форме
 ->  Not adding properties so that this object is not visible on the form at all

In samples/documentation/src/main/lsfusion/UseCasePartition.lsf of Category comment - Number of lines: 43; Number of occurances: 1

[OK] currentBalance 'Остаток' = DATA INTEGER (Batch, Stock); // Остаток сделан первичным для примера. Обычно это вычисляемое свойство.
 <-  Остаток сделан первичным для примера. Обычно это вычисляемое свойство.
 ->  The balance is made data for the example. This is usually a calculated property.

In samples/documentation/src/main/lsfusion/UseCasePropertyMyShape.lsf of Category comment - Number of lines: 5; Number of occurances: 1

[OK] overSquareCircle (circle) += radius(circle) * radius(circle) * 3.14159265359; // используем формулу с более высокой точностью <-  используем формулу с более высокой точностью
 ->  using a formula with higher accuracy

In samples/documentation/src/main/lsfusion/UseCaseSum.lsf of Category comment - Number of lines: 55; Number of occurances: 3

[OK] date 'Дата' = DATA DATE (Ledger) INDEXED; // лучше добавлять индекс, чтобы быстро шла фильтрация по дате
 <-  лучше добавлять индекс, чтобы быстро шла фильтрация по дате
 ->  it is better to add an index to filter by date quickly
[OK] // Вариант 1
 <-  Вариант 1
 ->  Option 1
[OK] // Вариант 2
 <-  Вариант 2
 ->  Option 2

In samples/documentation/src/main/lsfusion/UseCaseWhile.lsf of Category comment - Number of lines: 86; Number of occurances: 5

[OK]     // Вариант 1
 <-  Вариант 1
 ->  Option 1
[OK]     // Вариант 2
 <-  Вариант 2
 ->  Option 2
[OK]         FOR OrderDetail d == [ GROUP LAST OrderDetail od ORDER leftSum(od), od BY order(od)](o) DO { // находим строку с наибольшей "оставшейся" суммой
 <-  находим строку с наибольшей "оставшейся" суммой
 ->  finding the row with the largest "remaining" amount
[OK]             BREAK; // не осталось больше чего расписывать
 <-  не осталось больше чего расписывать
 ->  nothing left to break down
[OK]         cumBalance(Book b) <- cumBalance(b) (+) balance(b); //
 <- 
 -> 
crowdout/comment/hockeystats/src (sources: crowdin/comment/hockeystats/src) -> samples/hockeystats/src - translated files:
crowdout/comment/hockeystats/src/main (sources: crowdin/comment/hockeystats/src/main) -> samples/hockeystats/src/main - translated files:
crowdout/comment/hockeystats/src/main/lsfusion (sources: crowdin/comment/hockeystats/src/main/lsfusion) -> samples/hockeystats/src/main/lsfusion - translated files:

In samples/hockeystats/src/main/lsfusion/HockeyStats.lsf of Category comment - Number of lines: 152; Number of occurances: 1

[OK] // описание логики : https://documentation.lsfusion.org/pages/viewpage.action?pageId=2228240
 <-  описание логики : https://documentation.lsfusion.org/pages/viewpage.action?pageId=2228240
 ->  logic description: https://documentation.lsfusion.org/pages/viewpage.action?pageId=2228240
crowdout/comment/euroleague/src (sources: crowdin/comment/euroleague/src) -> samples/euroleague/src - translated files:
crowdout/comment/euroleague/src/main (sources: crowdin/comment/euroleague/src/main) -> samples/euroleague/src/main - translated files:
crowdout/comment/euroleague/src/main/lsfusion (sources: crowdin/comment/euroleague/src/main/lsfusion) -> samples/euroleague/src/main/lsfusion - translated files:

In samples/euroleague/src/main/lsfusion/APIFootball.lsf of Category comment - Number of lines: 160; Number of occurances: 3

[OK] url = 'https://' + host() + '/v2';
 <- ' + host() + '/v2';
 -> ' + host() + '/v2';
[OK] // Импорт клубов
 <-  Импорт клубов
 ->  Import clubs
[OK] // Импорт матчей
 <-  Импорт матчей
 ->  Import matches

In samples/euroleague/src/main/lsfusion/UEFA.lsf of Category comment - Number of lines: 95; Number of occurances: 1

[OK] // Команды
 <-  Команды
 ->  Teams
crowdout/comment/features/src/main/lsfusion (sources: crowdin/comment/features/src/main/lsfusion) -> samples/features/src/main/lsfusion - translated files:

In samples/features/src/main/lsfusion/FeaturesScript.lsf of Category comment - Number of lines: 3519; Number of occurances: 543

[OK] //////////////// MODULE HEADER //////////////////
 <- ////////////// MODULE HEADER //////////////////
 -> ////////////// MODULE HEADER //////////////////
[OK] // Syntax:
 <-  Syntax:
 ->  Syntax:
[OK] // MODULE moduleName;
 <-  MODULE moduleName;
 ->  MODULE moduleName;
[OK] // [REQUIRE moduleName1, ..., moduleNameN;]
 <-  [REQUIRE moduleName1, ..., moduleNameN;]
 ->  [REQUIRE moduleName1, ..., moduleNameN;]
[OK] // [PRIORITY namespace1, ..., namespaceK;]
 <-  [PRIORITY namespace1, ..., namespaceK;]
 ->  [PRIORITY namespace1, ..., namespaceK;]
[OK] // [NAMESPACE namespaceName;]
 <-  [NAMESPACE namespaceName;]
 ->  [NAMESPACE namespaceName;]
[OK] /////////// GROUP STATEMENT ////////////
 <- ///////// GROUP STATEMENT ////////////
 -> ///////// GROUP STATEMENT ////////////
[OK] // Syntax:
 <-  Syntax:
 ->  Syntax:
[OK] // GROUP name ['caption'] [: parentGroup];
 <-  GROUP name ['caption'] [: parentGroup];
 ->  GROUP name ['caption'] [: parentGroup];
[OK] GROUP sampleGroup : System.base; // явная квалификация имен
 <-  явная квалификация имен
 ->  explicit name qualification
[OK] /////////// CLASS STATEMENT ////////////
 <- ///////// CLASS STATEMENT ////////////
 -> ///////// CLASS STATEMENT ////////////
[OK] // Syntax:
 <-  Syntax:
 ->  Syntax:
[OK] // CLASS [ABSTRACT] name ['caption']
 <-  CLASS [ABSTRACT] name ['caption']
 ->  CLASS [ABSTRACT] name ['caption']
[OK] // [{
 <-  [{
 ->  [{
[OK] //      instanceName1 ['instanceCaption1'],
 <-       instanceName1 ['instanceCaption1'],
 ->       instanceName1 ['instanceCaption1'],
[OK] //      ...
 <-       ...
 ->       ...
[OK] //      instanceNameN ['instanceCaptionN']
 <-       instanceNameN ['instanceCaptionN']
 ->       instanceNameN ['instanceCaptionN']
[OK] // }]
 <-  }]
 ->  }]
[OK] // [: baseClass1 [, baseClass2, ..., baseClassN]];
 <-  [: baseClass1 [, baseClass2, ..., baseClassN]];
 ->  [: baseClass1 [, baseClass2, ..., baseClassN]];
[OK] // Extending class
 <-  Extending class
 ->  Extending class
[OK] // Syntax:
 <-  Syntax:
 ->  Syntax:
[OK] // EXTEND CLASS className
 <-  EXTEND CLASS className
 ->  EXTEND CLASS className
[OK] // [{
 <-  [{
 ->  [{
[OK] //      instanceName1 ['instanceCaption1']
 <-       instanceName1 ['instanceCaption1']
 ->       instanceName1 ['instanceCaption1']
[OK] //      ...
 <-       ...
 ->       ...
[OK] //      instanceNameN ['instanceCaptionN']
 <-       instanceNameN ['instanceCaptionN']
 ->       instanceNameN ['instanceCaptionN']
[OK] // }]
 <-  }]
 ->  }]
[OK] // [: baseClass1 [, baseClass2, ..., baseClassN];]
 <-  [: baseClass1 [, baseClass2, ..., baseClassN];]
 ->  [: baseClass1 [, baseClass2, ..., baseClassN];]
[OK] //////////// PROPERTY STATEMENT///////////
 <- ////////// PROPERTY STATEMENT///////////
 -> ////////// PROPERTY STATEMENT///////////
[OK] // Common syntax:
 <-  Common syntax:
 ->  Common syntax:
[OK] // name ['caption'] [(namedParam1, ..., namedParamN)] = propertyExpression [IN group] [MATERIALIZED] [TABLE <table name>]
 <-  name ['caption'] [(namedParam1, ..., namedParamN)] = propertyExpression [IN group] [MATERIALIZED] [TABLE <table name>]
 ->  name ['caption'] [(namedParam1, ..., namedParamN)] = propertyExpression [IN group] [MATERIALIZED] [TABLE <table name>]
[OK] //                                                                                                 [TOOLBAR]
 <-                                                                                                  [TOOLBAR]
 ->                                                                                                  [TOOLBAR]
[OK] //                                                                                                 [CONTEXTMENU propertyName]
 <-                                                                                                  [CONTEXTMENU propertyName]
 ->                                                                                                  [CONTEXTMENU propertyName]
[OK] //                                                                                                 [ASON CHANGE propertyName]
 <-                                                                                                  [ASON CHANGE propertyName]
 ->                                                                                                  [ASON CHANGE propertyName]
[OK] //                                                                                                 [ASON CHANGEWYS propertyName]
 <-                                                                                                  [ASON CHANGEWYS propertyName]
 ->                                                                                                  [ASON CHANGEWYS propertyName]
[OK] //                                                                                                 [ASON EDIT propertyName]
 <-                                                                                                  [ASON EDIT propertyName]
 ->                                                                                                  [ASON EDIT propertyName]
[OK] //                                                                                                 [IMAGE 'name'] [CHANGEKEY '<key code>' [SHOW | HIDE]] [AUTOSET] [CONFIRM]
 <-                                                                                                  [IMAGE 'name'] [CHANGEKEY '<key code>' [SHOW | HIDE]] [AUTOSET] [CONFIRM]
 ->                                                                                                  [IMAGE 'name'] [CHANGEKEY '<key code>' [SHOW | HIDE]] [AUTOSET] [CONFIRM]
[OK] //                                                                                                 [REGEXP '<expression>' ['<regExp message>']] [LOGGABLE] [ECHO] [INDEXED]
 <-                                                                                                  [REGEXP '<expression>' ['<regExp message>']] [LOGGABLE] [ECHO] [INDEXED]
 ->                                                                                                  [REGEXP '<expression>' ['<regExp message>']] [LOGGABLE] [ECHO] [INDEXED]
[OK] //                                                                                                 [NONULL [DELETE] [APPLY | SESSION] [FORMS form1, ..., formN]]
 <-                                                                                                  [NONULL [DELETE] [APPLY | SESSION] [FORMS form1, ..., formN]]
 ->                                                                                                  [NONULL [DELETE] [APPLY | SESSION] [FORMS form1, ..., formN]]
[OK] //                                                                                                 [ON (CHANGE | CHANGEWYS | EDIT) action]
 <-                                                                                                  [ON (CHANGE | CHANGEWYS | EDIT) action]
 ->                                                                                                  [ON (CHANGE | CHANGEWYS | EDIT) action]
[OK] //                                                                                                 [EVENTID 'id'];
 <-                                                                                                  [EVENTID 'id'];
 ->                                                                                                  [EVENTID 'id'];
[OK] // Если именованные параметры не указываются, то они выводятся из propertyExpression
 <-  Если именованные параметры не указываются, то они выводятся из propertyExpression
 ->  If named parameters are not specified, then they are derived from propertyExpression
[OK] // Data property
 <-  Data property
 ->  Data property
[OK] // Expression syntax:
 <-  Expression syntax:
 ->  Expression syntax:
[OK] // DATA [LOCAL] returnClass ( [paramClass1, ..., paramClassN] )
 <-  DATA [LOCAL] returnClass ( [paramClass1, ..., paramClassN] )
 ->  DATA [LOCAL] returnClass ( [paramClass1, ..., paramClassN] )
[OK] // If LOCAL modifier is specified, than local data property will be created.
 <-  If LOCAL modifier is specified, than local data property will be created.
 ->  If LOCAL modifier is specified, then local data property will be created.
[OK] // Built-in types: INTEGER, LONG, DOUBLE, BOOLEAN, DATE, DATETIME, TEXT, BPSTRING, BPISTRING, 
 <-  Built-in types: INTEGER, LONG, DOUBLE, BOOLEAN, DATE, DATETIME, TEXT, BPSTRING, BPISTRING, 
 ->  Built-in types: INTEGER, LONG, DOUBLE, BOOLEAN, DATE, DATETIME, TEXT, BPSTRING, BPISTRING, 
[OK] // TIME, WORDFILE, IMAGEFILE, PDFFILE, FILE, EXCELFILE, NUMERIC, COLOR, TEXTFILE, CSVFILE, HTMLFILE, JSONFILE, XMLFILE, TABLEFILE
 <-  TIME, WORDFILE, IMAGEFILE, PDFFILE, FILE, EXCELFILE, NUMERIC, COLOR, TEXTFILE, CSVFILE, HTMLFILE, JSONFILE, XMLFILE, TABLEFILE
 ->  TIME, WORDFILE, IMAGEFILE, PDFFILE, FILE, EXCELFILE, NUMERIC, COLOR, TEXTFILE, CSVFILE, HTMLFILE, JSONFILE, XMLFILE, TABLEFILE
[OK] // Join property
 <-  Join property
 ->  Join property
[OK] // Expression syntax:
 <-  Expression syntax:
 ->  Expression syntax:
[OK] // [JOIN] (name | '[' propertyDefinition ']') (param1, ..., paramN)
 <-  [JOIN] (name | '[' propertyDefinition ']') (param1, ..., paramN)
 ->  [JOIN] (name | '[' propertyDefinition ']') (param1, ..., paramN)
[OK] storeSizeName = staticCaption(storeSize(Store store)) IN base; // можем не указывать именованные параметры слева от '=', но все равно пользоваться ими
 <-  можем не указывать именованные параметры слева от '=', но все равно пользоваться ими
 ->  we can omit named parameters to the left of '=', but still use them
[OK] // IS, AS
 <-  IS, AS
 ->  IS, AS
[OK] // Expression syntax:
 <-  Expression syntax:
 ->  Expression syntax:
[OK] // propertyExpression (AS | IS) className
 <-  propertyExpression (AS | IS) className
 ->  propertyExpression (AS | IS) className
[OK] // IS - is(), AS - object()
 <-  IS - is(), AS - object()
 ->  IS - is(), AS - object()
[OK] // AND, IF (идентичны по действию)
 <-  AND, IF (идентичны по действию)
 ->  AND, IF (identical in action)
[OK] // Expression syntax:
 <-  Expression syntax:
 ->  Expression syntax:
[OK] // propertyExpression (AND | IF) [NOT] propertyExpression
 <-  propertyExpression (AND | IF) [NOT] propertyExpression
 ->  propertyExpression (AND | IF) [NOT] propertyExpression
[OK] outQuantity(document, article) = quantity[Document,Article](document, article) IF document IS OutcomeDocument;  // указание номеров параметров вместо имен
 <-  указание номеров параметров вместо имен
 ->  specifying parameter numbers instead of names
[OK] // Group property
 <-  Group property
 ->  Group property
[OK] // SUM, MAX, MIN, EQUAL group property
 <-  SUM, MAX, MIN, EQUAL group property
 ->  SUM, MAX, MIN, EQUAL group property
[OK] // Expression syntax:
 <-  Expression syntax:
 ->  Expression syntax:
[OK] // GROUP (SUM | MAX | MIN | EQUAL) propertyExpression [BY propertyExpression1, ..., propertyExpressionN]
 <-  GROUP (SUM | MAX | MIN | EQUAL) propertyExpression [BY propertyExpression1, ..., propertyExpressionN]
 ->  GROUP (SUM | MAX | MIN | EQUAL) propertyExpression [BY propertyExpression1, ..., propertyExpressionN]
[OK] // CONCAT group property
 <-  CONCAT group property
 ->  CONCAT group property
[OK] // GROUP CONCAT propertyExpr, separatorPropertyExpr [BY propertyExpr1, ..., propertyExprN] [ORDER [DESC] orderPropertyExpr1, ..., orderPropertyExprK]
 <-  GROUP CONCAT propertyExpr, separatorPropertyExpr [BY propertyExpr1, ..., propertyExprN] [ORDER [DESC] orderPropertyExpr1, ..., orderPropertyExprK]
 ->  GROUP CONCAT propertyExpr, separatorPropertyExpr [BY propertyExpr1, ..., propertyExprN] [ORDER [DESC] orderPropertyExpr1, ..., orderPropertyExprK]
[OK] // AGGR group property
 <-  AGGR group property
 ->  AGGR group property
[OK] // GROUP AGGR propertyExpression [BY propertyExpression1, ..., propertyExpressionN] [WHERE propertyExpression]
 <-  GROUP AGGR propertyExpression [BY propertyExpression1, ..., propertyExpressionN] [WHERE propertyExpression]
 ->  GROUP AGGR propertyExpression [BY propertyExpression1, ..., propertyExpressionN] [WHERE propertyExpression]
[OK] //nameToCountry(name) = GROUP AGGR country BY name(country);
 <- nameToCountry(name) = GROUP AGGR country BY name(country);
 -> nameToCountry(name) = GROUP AGGR country BY name(country);
[OK] // OR property
 <-  OR property
 ->  OR property
[OK] // Expression syntax:
 <-  Expression syntax:
 ->  Expression syntax:
[OK] // propertyExpression1 OR propertyExpression2
 <-  propertyExpression1 OR propertyExpression2
 ->  propertyExpression1 OR propertyExpression2
[OK] // Recursive property
 <-  Recursive property
 ->  Recursive property
[OK] // Expression syntax:
 <-  Expression syntax:
 ->  Expression syntax:
[OK] // RECURSION initPropertyExpression STEP stepPropertyExpression [CYCLES (YES | NO | IMPOSSIBLE)]
 <-  RECURSION initPropertyExpression STEP stepPropertyExpression [CYCLES (YES | NO | IMPOSSIBLE)]
 ->  RECURSION initPropertyExpression STEP stepPropertyExpression [CYCLES (YES | NO | IMPOSSIBLE)]
[OK] // Previous value syntax: $param
 <-  Previous value syntax: $param
 ->  Previous value syntax: $param
[OK] // Default: CYCLES NO
 <-  Default: CYCLES NO
 ->  Default: CYCLES NO
[OK] // IF THEN ELSE property
 <-  IF THEN ELSE property
 ->  IF THEN ELSE property
[OK] // Expression syntax:
 <-  Expression syntax:
 ->  Expression syntax:
[OK] // IF propertyExpression0 THEN propertyExpression1 [ELSE propertyExpression2]
 <-  IF propertyExpression0 THEN propertyExpression1 [ELSE propertyExpression2]
 ->  IF propertyExpression0 THEN propertyExpression1 [ELSE propertyExpression2]
[OK] // Case property
 <-  Case property
 ->  Case property
[OK] // Expression syntax:
 <-  Expression syntax:
 ->  Expression syntax:
[OK] // CASE [OVERRIDE | EXCLUSIVE]
 <-  CASE [OVERRIDE | EXCLUSIVE]
 ->  CASE [OVERRIDE | EXCLUSIVE]
[OK] //      WHEN whenPropertyExpression1 THEN thenPropertyExpression1
 <-       WHEN whenPropertyExpression1 THEN thenPropertyExpression1
 ->       WHEN whenPropertyExpression1 THEN thenPropertyExpression1
[OK] //      ...
 <-       ...
 ->       ...
[OK] //      WHEN whenPropertyExpressionN THEN thenPropertyExpressionN
 <-       WHEN whenPropertyExpressionN THEN thenPropertyExpressionN
 ->       WHEN whenPropertyExpressionN THEN thenPropertyExpressionN
[OK] //      [ELSE defaultPropertyExpression]
 <-       [ELSE defaultPropertyExpression]
 ->       [ELSE defaultPropertyExpression]
[OK] // Multi property
 <-  Multi property
 ->  Multi property
[OK] // Expression syntax:
 <-  Expression syntax:
 ->  Expression syntax:
[OK] // MULTI propertyExpression1, ..., propertyExpressionN [EXCLUSIVE | OVERRIDE]
 <-  MULTI propertyExpression1, ..., propertyExpressionN [EXCLUSIVE | OVERRIDE]
 ->  MULTI propertyExpression1, ..., propertyExpressionN [EXCLUSIVE | OVERRIDE]
[OK] //exclusiveTestA(a) += caseData1(a);
 <- exclusiveTestA(a) += caseData1(a);
 -> exclusiveTestA(a) += caseData1(a);
[OK] //caseTestA = ABSTRACT CASE INTEGER (CaseA);
 <- caseTestA = ABSTRACT CASE INTEGER (CaseA);
 -> caseTestA = ABSTRACT CASE INTEGER (CaseA);
[OK] //caseTestA(a) += WHEN testInt(a) < 5 THEN caseData1(a);
 <- caseTestA(a) += WHEN testInt(a) < 5 THEN caseData1(a);
 -> caseTestA(a) += WHEN testInt(a) < 5 THEN caseData1(a);
[OK] //caseTestA(a) += WHEN testInt(a) < 6 THEN caseData2(a);
 <- caseTestA(a) += WHEN testInt(a) < 6 THEN caseData2(a);
 -> caseTestA(a) += WHEN testInt(a) < 6 THEN caseData2(a);
[OK] //caseTestA(a) += WHEN testInt(a) < 7 THEN caseData3(a);
 <- caseTestA(a) += WHEN testInt(a) < 7 THEN caseData3(a);
 -> caseTestA(a) += WHEN testInt(a) < 7 THEN caseData3(a);
[OK] //caseTestA(a) += WHEN a IS CaseA THEN 0;
 <- caseTestA(a) += WHEN a IS CaseA THEN 0;
 -> caseTestA(a) += WHEN a IS CaseA THEN 0;
[OK] //caseTestA2 = ABSTRACT CASE EXCLUSIVE INTEGER (CaseA);
 <- caseTestA2 = ABSTRACT CASE EXCLUSIVE INTEGER (CaseA);
 -> caseTestA2 = ABSTRACT CASE EXCLUSIVE INTEGER (CaseA);
[OK] //caseTestA2(a) += WHEN testInt(a) > 5 THEN caseData1(a);
 <- caseTestA2(a) += WHEN testInt(a) > 5 THEN caseData1(a);
 -> caseTestA2(a) += WHEN testInt(a) > 5 THEN caseData1(a);
[OK] //caseTestA2(a) += WHEN testInt(a) < 5 THEN caseData2(a);
 <- caseTestA2(a) += WHEN testInt(a) < 5 THEN caseData2(a);
 -> caseTestA2(a) += WHEN testInt(a) < 5 THEN caseData2(a);
[OK] //caseTestA2(a) += WHEN testInt(a) = 5 THEN caseData3(a);
 <- caseTestA2(a) += WHEN testInt(a) = 5 THEN caseData3(a);
 -> caseTestA2(a) += WHEN testInt(a) = 5 THEN caseData3(a);
[OK] //multiTestA2 = ABSTRACT MULTI OVERRIDE CHECKED INTEGER (CaseA);
 <- multiTestA2 = ABSTRACT MULTI OVERRIDE CHECKED INTEGER (CaseA);
 -> multiTestA2 = ABSTRACT MULTI OVERRIDE CHECKED INTEGER (CaseA);
[OK] //multiTestA2(a) += caseData1(a);
 <- multiTestA2(a) += caseData1(a);
 -> multiTestA2(a) += caseData1(a);
[OK] //multiTestA2(a) += caseDataB(a);
 <- multiTestA2(a) += caseDataB(a);
 -> multiTestA2(a) += caseDataB(a);
[OK] //multiTestA2(a) += caseDataC(a);
 <- multiTestA2(a) += caseDataC(a);
 -> multiTestA2(a) += caseDataC(a);
[OK] //multiActionTest(a) = MULTI IF a IS CaseB THEN MESSAGE caseDataB(a), IF a IS CaseC THEN MESSAGE caseDataC(a);
 <- multiActionTest(a) = MULTI IF a IS CaseB THEN MESSAGE caseDataB(a), IF a IS CaseC THEN MESSAGE caseDataC(a);
 -> multiActionTest(a) = MULTI IF a IS CaseB THEN MESSAGE caseDataB(a), IF a IS CaseC THEN MESSAGE caseDataC(a);
[OK] //multiActionTest2(a) = MULTI OVERRIDE IF a IS CaseB THEN MESSAGE caseDataB(a), IF a IS CaseC THEN MESSAGE caseDataC(a);
 <- multiActionTest2(a) = MULTI OVERRIDE IF a IS CaseB THEN MESSAGE caseDataB(a), IF a IS CaseC THEN MESSAGE caseDataC(a);
 -> multiActionTest2(a) = MULTI OVERRIDE IF a IS CaseB THEN MESSAGE caseDataB(a), IF a IS CaseC THEN MESSAGE caseDataC(a);
[OK] //multiActionTestA  ABSTRACT MULTI ( CaseA);
 <- multiActionTestA  ABSTRACT MULTI ( CaseA);
 -> multiActionTestA  ABSTRACT MULTI ( CaseA);
[OK] //multiActionTestA(a) += IF a IS CaseB THEN MESSAGE caseDataB(a);
 <- multiActionTestA(a) += IF a IS CaseB THEN MESSAGE caseDataB(a);
 -> multiActionTestA(a) += IF a IS CaseB THEN MESSAGE caseDataB(a);
[OK] //multiActionTestA(a) += IF a IS CaseC THEN MESSAGE caseDataC(a);
 <- multiActionTestA(a) += IF a IS CaseC THEN MESSAGE caseDataC(a);
 -> multiActionTestA(a) += IF a IS CaseC THEN MESSAGE caseDataC(a);
[OK] //multiActionTestA2  ABSTRACT MULTI OVERRIDE ( CaseA);
 <- multiActionTestA2  ABSTRACT MULTI OVERRIDE ( CaseA);
 -> multiActionTestA2  ABSTRACT MULTI OVERRIDE ( CaseA);
[OK] //multiActionTestA2(a) += IF a IS CaseB THEN MESSAGE caseDataB(a);
 <- multiActionTestA2(a) += IF a IS CaseB THEN MESSAGE caseDataB(a);
 -> multiActionTestA2(a) += IF a IS CaseB THEN MESSAGE caseDataB(a);
[OK] //multiActionTestA2(a) += IF a IS CaseB THEN MESSAGE caseDataC(a);
 <- multiActionTestA2(a) += IF a IS CaseB THEN MESSAGE caseDataC(a);
 -> multiActionTestA2(a) += IF a IS CaseB THEN MESSAGE caseDataC(a);
[OK]     //DRILLDOWN overrideTest(a); 
 <- DRILLDOWN overrideTest(a); 
 -> DRILLDOWN overrideTest(a); 
[OK]     PROPERTIES(a) GRID NEW TOOLBAR, testInt, caseData1, caseData2, caseData3, overrideTest, overrideTestA, exclusiveTest, exclusiveTestA, caseTest, caseTest2, //caseTestA, caseTestA2, 
 <- caseTestA, caseTestA2, 
 -> caseTestA, caseTestA2, 
[OK]                   multiTest, multiTestA, multiTest2,// multiTestA2,
 <-  multiTestA2,
 ->  multiTestA2,
[OK]                   caseActionTest, caseActionTestA, caseActionTest2, caseActionTestA2//, multiActionTest, multiActionTestA, multiActionTest2, multiActionTestA2
 <- , multiActionTest, multiActionTestA, multiActionTest2, multiActionTestA2
 -> , multiActionTest, multiActionTestA, multiActionTest2, multiActionTestA2
[OK] // Partition property
 <-  Partition property
 ->  Partition property
[OK] // SUM, PREV partition property
 <-  SUM, PREV partition property
 ->  SUM, PREV partition property
[OK] // Expression syntax:
 <-  Expression syntax:
 ->  Expression syntax:
[OK] // PARTITION (SUM | PREV) propertyExpression
 <-  PARTITION (SUM | PREV) propertyExpression
 ->  PARTITION (SUM | PREV) propertyExpression
[OK] // [BY propertyExpressionM1, ..., propertyExpressionMN]
 <-  [BY propertyExpressionM1, ..., propertyExpressionMN]
 ->  [BY propertyExpressionM1, ..., propertyExpressionMN]
[OK] // [ORDER [DESC] propertyExpressionL1, ..., propertyExpressionLK]
 <-  [ORDER [DESC] propertyExpressionL1, ..., propertyExpressionLK]
 ->  [ORDER [DESC] propertyExpressionL1, ..., propertyExpressionLK]
[OK] // [WINDOW EXCEPTLAST]
 <-  [WINDOW EXCEPTLAST]
 ->  [WINDOW EXCEPTLAST]
[OK] // UNGROUP PROPORTION partition property
 <-  UNGROUP PROPORTION partition property
 ->  UNGROUP PROPORTION partition property
[OK] // PARTITION UNGROUP propertyObject PROPORTION [STRICT] ROUND(precision) proportionPropertyExpression
 <-  PARTITION UNGROUP propertyObject PROPORTION [STRICT] ROUND(precision) proportionPropertyExpression
 ->  PARTITION UNGROUP propertyObject PROPORTION [STRICT] ROUND(precision) proportionPropertyExpression
[OK] // [BY propertyExpressionM1, ..., propertyExpressionMN]
 <-  [BY propertyExpressionM1, ..., propertyExpressionMN]
 ->  [BY propertyExpressionM1, ..., propertyExpressionMN]
[OK] // [ORDER [DESC] propertyExpressionL1, ..., propertyExpressionLK]
 <-  [ORDER [DESC] propertyExpressionL1, ..., propertyExpressionLK]
 ->  [ORDER [DESC] propertyExpressionL1, ..., propertyExpressionLK]
[OK] // UNGROUP LIMIT partition property
 <-  UNGROUP LIMIT partition property
 ->  UNGROUP LIMIT partition property
[OK] // PARTITION UNGROUP propertyObject LIMIT [STRICT] limitPropertyExpression
 <-  PARTITION UNGROUP propertyObject LIMIT [STRICT] limitPropertyExpression
 ->  PARTITION UNGROUP propertyObject LIMIT [STRICT] limitPropertyExpression
[OK] // [BY propertyExpressionM1, ..., propertyExpressionMN]
 <-  [BY propertyExpressionM1, ..., propertyExpressionMN]
 ->  [BY propertyExpressionM1, ..., propertyExpressionMN]
[OK] // [ORDER [DESC] propertyExpressionL1, ..., propertyExpressionLK]
 <-  [ORDER [DESC] propertyExpressionL1, ..., propertyExpressionLK]
 ->  [ORDER [DESC] propertyExpressionL1, ..., propertyExpressionLK]
[OK] //FORM TestPartition
 <- FORM TestPartition
 -> FORM TestPartition
[OK] //OBJECTS s=Store, a=Article
 <- OBJECTS s=Store, a=Article
 -> OBJECTS s=Store, a=Article
[OK] //PROPERTIES NEW(s), NEW(a), testAmount(s), testData(a), testPartition(s, a), testPropPartition(s, a), testLimitPartition(s, a) 
 <- PROPERTIES NEW(s), NEW(a), testAmount(s), testData(a), testPartition(s, a), testPropPartition(s, a), testLimitPartition(s, a) 
 -> PROPERTIES NEW(s), NEW(a), testAmount(s), testData(a), testPartition(s, a), testPropPartition(s, a), testLimitPartition(s, a) 
[OK] //;
 <- ;
 -> ;
[OK] // Concatenation/Deconcatenation property
 <-  Concatenation/Deconcatenation property
 ->  Concatenation/Deconcatenation property
[OK] // Expression syntax:
 <-  Expression syntax:
 ->  Expression syntax:
[OK] // STRUCT(propertyExpression1[, ..., propertyExpressionN])
 <-  STRUCT(propertyExpression1[, ..., propertyExpressionN])
 ->  STRUCT(propertyExpression1[, ..., propertyExpressionN])
[OK] // Access expression syntax with one-base indices:
 <-  Access expression syntax with one-base indices:
 ->  Access expression syntax with one-base indices:
[OK] // concatenatePropertyExpression[2]
 <-  concatenatePropertyExpression[2]
 ->  concatenatePropertyExpression[2]
[OK] // Abstract property
 <-  Abstract property
 ->  Abstract property
[OK] // Expression syntax:
 <-  Expression syntax:
 ->  Expression syntax:
[OK] // ABSTRACT [CASE [OVERRIDE | EXCLUSIVE] | MULTI [OVERRIDE | EXCLUSIVE] | OVERRIDE | EXCLUSIVE] [CHECKED] returnClass (paramClass1, ..., paramClassN)
 <-  ABSTRACT [CASE [OVERRIDE | EXCLUSIVE] | MULTI [OVERRIDE | EXCLUSIVE] | OVERRIDE | EXCLUSIVE] [CHECKED] returnClass (paramClass1, ..., paramClassN)
 ->  ABSTRACT [CASE [OVERRIDE | EXCLUSIVE] | MULTI [OVERRIDE | EXCLUSIVE] | OVERRIDE | EXCLUSIVE] [CHECKED] returnClass (paramClass1, ..., paramClassN)
[OK] // overriding abstract property syntax:
 <-  overriding abstract property syntax:
 ->  overriding abstract property syntax:
[OK] // propertyName(namedParam1, ..., namedParamN) += expression;
 <-  propertyName(namedParam1, ..., namedParamN) += expression;
 ->  propertyName(namedParam1, ..., namedParamN) += expression;
[OK] // or
 <-  or
 ->  or
[OK] // propertyName(namedParam1, ..., namedParamN) += WHEN expression1 THEN expression2;
 <-  propertyName(namedParam1, ..., namedParamN) += WHEN expression1 THEN expression2;
 ->  propertyName(namedParam1, ..., namedParamN) += WHEN expression1 THEN expression2;
[OK] // Abstract action
 <-  Abstract action
 ->  Abstract action
[OK] // Expression syntax:
 <-  Expression syntax:
 ->  Expression syntax:
[OK] // ACTION ABSTRACT [CASE [OVERRIDE | EXCLUSIVE] | MULTI [OVERRIDE | EXCLUSIVE] | LIST] [CHECKED] (className1, ..., classNameN)
 <-  ACTION ABSTRACT [CASE [OVERRIDE | EXCLUSIVE] | MULTI [OVERRIDE | EXCLUSIVE] | LIST] [CHECKED] (className1, ..., classNameN)
 ->  ACTION ABSTRACT [CASE [OVERRIDE | EXCLUSIVE] | MULTI [OVERRIDE | EXCLUSIVE] | LIST] [CHECKED] (className1, ..., classNameN)
[OK] // overriding abstract action syntax:
 <-  overriding abstract action syntax:
 ->  overriding abstract action syntax:
[OK] // actionName(namedParam1, ..., namedParamN) += actionBody;
 <-  actionName(namedParam1, ..., namedParamN) += actionBody;
 ->  actionName(namedParam1, ..., namedParamN) += actionBody;
[OK] // or
 <-  or
 ->  or
[OK] // actionName(namedParam1, ..., namedParamN) += WHEN expression THEN actionBody;
 <-  actionName(namedParam1, ..., namedParamN) += WHEN expression THEN actionBody;
 ->  actionName(namedParam1, ..., namedParamN) += WHEN expression THEN actionBody;
[OK] // Formula property
 <-  Formula property
 ->  Formula property
[OK] // Expression syntax:
 <-  Expression syntax:
 ->  Expression syntax:
[OK] // FORMULA [primitiveType] 'formula text $1 + $2'
 <-  FORMULA [primitiveType] 'formula text $1 + $2'
 ->  FORMULA [primitiveType] 'formula text $1 + $2'
[OK] // Computational expressions
 <-  Computational expressions
 ->  Computational expressions
[OK] // Priority:
 <-  Priority:
 ->  Priority:
[OK] // OR
 <-  OR
 ->  OR
[OK] // AND  IF
 <-  AND  IF
 ->  AND  IF
[OK] // ==  !=
 <-  ==  !=
 ->  ==  !=
[OK] // <  >  <=  >=
 <-  <  >  <=  >=
 ->  <  >  <=  >=
[OK] // (+) (-)
 <-  (+) (-)
 ->  (+) (-)
[OK] // +  -
 <-  +  -
 ->  +  -
[OK] // *  /
 <-  *  /
 ->  *  /
[OK] // - (unary)
 <-  - (unary)
 ->  - (unary)
[OK] //
 <- 
 -> 
[OK] // Instances: 5, 5L, 6.35, 6.35d, TRUE, 'some string', class.object, 2011_10_25, 2011_10_25_18:00, 18:00, NULL, #ff0000, RGB(255, 0, 0)
 <-  Instances: 5, 5L, 6.35, 6.35d, TRUE, 'some string', class.object, 2011_10_25, 2011_10_25_18:00, 18:00, NULL, #ff0000, RGB(255, 0, 0)
 ->  Instances: 5, 5L, 6.35, 6.35d, TRUE, 'some string', class.object, 2011_10_25, 2011_10_25_18:00, 18:00, NULL, #ff0000, RGB(255, 0, 0)
[OK] foobar(Store store, Article article) = [ x*x + y](foo(store, article), bar(store, article));   // lambda-like syntax
 <-  lambda-like syntax
 ->  lambda-like syntax
[OK] storeIsHuge(Store store) = storeSize(store) == StoreSize.huge CHARWIDTH 50 FLEX;                        // static object
 <-  static object
 ->  static object
[OK] /////////////////////ACTIONS//////////////////
 <- ///////////////////ACTIONS//////////////////
 -> ///////////////////ACTIONS//////////////////
[OK] // General Syntax:
 <-  General Syntax:
 ->  General Syntax:
[OK] // ACTION [(param1, ..., paramN)] actionBody
 <-  ACTION [(param1, ..., paramN)] actionBody
 ->  ACTION [(param1, ..., paramN)] actionBody
[OK] // List action
 <-  List action
 ->  List action
[OK] // statement syntax:
 <-  statement syntax:
 ->  statement syntax:
[OK] // [NEWSESSION [AUTOAPPLY]]  {
 <-  [NEWSESSION [AUTOAPPLY]]  {
 ->  [NEWSESSION [AUTOAPPLY]]  {
[OK] //      actionStatement1 | LOCAL name = returnClass ( [paramClass1, ..., paramClassK1] )
 <-       actionStatement1 | LOCAL name = returnClass ( [paramClass1, ..., paramClassK1] )
 ->       actionStatement1 | LOCAL name = returnClass ( [paramClass1, ..., paramClassK1] )
[OK] //      ...
 <-       ...
 ->       ...
[OK] //      actionStatementN | LOCAL name = returnClass ( [paramClass1, ..., paramClassKN] );
 <-       actionStatementN | LOCAL name = returnClass ( [paramClass1, ..., paramClassKN] );
 ->       actionStatementN | LOCAL name = returnClass ( [paramClass1, ..., paramClassKN] );
[OK] // }
 <-  }
 ->  }
[OK] //
 <- 
 -> 
[OK] // If NEWSESSION is specified than action will be performed in new session.
 <-  If NEWSESSION is specified than action will be performed in new session.
 ->  If NEWSESSION is specified than action will be performed in new session.
[OK] // If AUTOAPPLY is specified - this new session will be applied by default,
 <-  If AUTOAPPLY is specified - this new session will be applied by default,
 ->  If AUTOAPPLY is specified - this new session will be applied by default,
[OK] // if not - one should do 'EXEC apply();' explicitly.
 <-  if not - one should do 'EXEC apply();' explicitly.
 ->  if not - one should do 'EXEC apply();' explicitly.
[OK] // Exec action
 <-  Exec action
 ->  Exec action
[OK] // statement syntax:
 <-  statement syntax:
 ->  statement syntax:
[OK] // [EXEC] actionPropertyName(propertyExpr1, ..., propertyExprN)
 <-  [EXEC] actionPropertyName(propertyExpr1, ..., propertyExprN)
 ->  [EXEC] actionPropertyName(propertyExpr1, ..., propertyExprN)
[OK] // or
 <-  or
 ->  or
[OK] // [EXEC] [actionPropertyExpr](propertyExpr1, ..., propertyExprN)
 <-  [EXEC] [actionPropertyExpr](propertyExpr1, ..., propertyExprN)
 ->  [EXEC] [actionPropertyExpr](propertyExpr1, ..., propertyExprN)
[OK] // Set action
 <-  Set action
 ->  Set action
[OK] // statement syntax:
 <-  statement syntax:
 ->  statement syntax:
[OK] // [SET] name(param1, .., paramN) <- propertyExpressionFrom [WHERE conditionalExpression]
 <-  [SET] name(param1, .., paramN) <- propertyExpressionFrom [WHERE conditionalExpression]
 ->  [SET] name(param1, .., paramN) <- propertyExpressionFrom [WHERE conditionalExpression]
[OK] // If action
 <-  If action
 ->  If action
[OK] // statement syntax:
 <-  statement syntax:
 ->  statement syntax:
[OK] // IF propertyExpresson
 <-  IF propertyExpresson
 ->  IF propertyExpresson
[OK] //      THEN actionStatement1
 <-       THEN actionStatement1
 ->       THEN actionStatement1
[OK] //     [ELSE actionStatement2]
 <-      [ELSE actionStatement2]
 ->      [ELSE actionStatement2]
[OK] // Case action
 <-  Case action
 ->  Case action
[OK] // statement syntax
 <-  statement syntax
 ->  statement syntax
[OK] // CASE [OVERRIDE | EXCLUSIVE]
 <-  CASE [OVERRIDE | EXCLUSIVE]
 ->  CASE [OVERRIDE | EXCLUSIVE]
[OK] //      WHEN propertyExpr1 THRN action1
 <-       WHEN propertyExpr1 THRN action1
 ->       WHEN propertyExpr1 THEN action1
[OK] //      ...
 <-       ...
 ->       ...
[OK] //      WHEN propertyExprN THEN actionN
 <-       WHEN propertyExprN THEN actionN
 ->       WHEN propertyExprN THEN actionN
[OK] // Multi action
 <-  Multi action
 ->  Multi action
[OK] // statement syntax:
 <-  statement syntax:
 ->  statement syntax:
[OK] // MULTI [OVERRIDE | EXCLUSIVE] action1, ..., actionN
 <-  MULTI [OVERRIDE | EXCLUSIVE] action1, ..., actionN
 ->  MULTI [OVERRIDE | EXCLUSIVE] action1, ..., actionN
[OK] // For/While action
 <-  For/While action
 ->  For/While action
[OK] // statement syntax:
 <-  statement syntax:
 ->  statement syntax:
[OK] // (FOR | WHILE) propertyExpression [ORDER [DESC] orderExpression1, ..., orderExpressionN] DO actionStatement
 <-  (FOR | WHILE) propertyExpression [ORDER [DESC] orderExpression1, ..., orderExpressionN] DO actionStatement
 ->  (FOR | WHILE) propertyExpression [ORDER [DESC] orderExpression1, ..., orderExpressionN] DO actionStatement
[OK] // Form action
 <-  Form action
 ->  Form action
[OK] // statement syntax:
 <-  statement syntax:
 ->  statement syntax:
[OK] // FORM formName
 <-  FORM formName
 ->  FORM formName
[OK] // [OBJECTS object1 =mappingExpr1, ..., objectN =mappinExprN]
 <-  [OBJECTS object1 =mappingExpr1, ..., objectN =mappinExprN]
 ->  [OBJECTS object1 =mappingExpr1, ..., objectN =mappinExprN]
[OK] // [NEWSESSION | | OLDSESSION] [DOCKED | FLOAT] [CHECK] [PRINT [AUTO]]
 <-  [NEWSESSION | | OLDSESSION] [DOCKED | FLOAT] [CHECK] [PRINT [AUTO]]
 ->  [NEWSESSION | | OLDSESSION] [DOCKED | FLOAT] [CHECK] [PRINT [AUTO]]
[OK] // Add object action
 <-  Add object action
 ->  Add object action
[OK] // statement syntax:
 <-  statement syntax:
 ->  statement syntax:
[OK] // NEW className [WHERE expression] [TO propertyName(param1, ..., paramN)]
 <-  NEW className [WHERE expression] [TO propertyName(param1, ..., paramN)]
 ->  NEW className [WHERE expression] [TO propertyName(param1, ..., paramN)]
[OK] // Custom action
 <-  Custom action
 ->  Custom action
[OK] // statement syntax:
 <-  statement syntax:
 ->  statement syntax:
[OK] // INTERNAL 'javaClassName'
 <-  INTERNAL 'javaClassName'
 ->  INTERNAL 'javaClassName'
[OK] // Message action
 <-  Message action
 ->  Message action
[OK] // statement syntax:
 <-  statement syntax:
 ->  statement syntax:
[OK] // MESSAGE propertyExpr
 <-  MESSAGE propertyExpr
 ->  MESSAGE propertyExpr
[OK] // Delete action
 <-  Delete action
 ->  Delete action
[OK] // statement syntax:
 <-  statement syntax:
 ->  statement syntax:
[OK] // DELETE object [WHERE expression]
 <-  DELETE object [WHERE expression]
 ->  DELETE object [WHERE expression]
[OK] // Change class action
 <-  Change class action
 ->  Change class action
[OK] // statement syntax:
 <-  statement syntax:
 ->  statement syntax:
[OK] // CHANGECLASS object TO className [WHERE expression]
 <-  CHANGECLASS object TO className [WHERE expression]
 ->  CHANGECLASS object TO className [WHERE expression]
[OK] // built-in or abstract class names are forbidden
 <-  built-in or abstract class names are forbidden
 ->  built-in or abstract class names are forbidden
[OK] // Confirm action
 <-  Confirm action
 ->  Confirm action
[OK] // statement syntax:
 <-  statement syntax:
 ->  statement syntax:
[OK] // CONFIRM propertyExpression
 <-  CONFIRM propertyExpression
 ->  CONFIRM propertyExpression
[OK] // Request action
 <-  Request action
 ->  Request action
[OK] // statement syntax:
 <-  statement syntax:
 ->  statement syntax:
[OK] // REQUEST type (INPUT | [objectName] actionStatement)
 <-  REQUEST type (INPUT | [objectName] actionStatement)
 ->  REQUEST type (INPUT | [objectName] actionStatement)
[OK] // type can be built-in type or OBJECT
 <-  type can be built-in type or OBJECT
 ->  type can be built-in type or OBJECT
[OK] // Eval action
 <-  Eval action
 ->  Eval action
[OK] // statement syntax:
 <-  statement syntax:
 ->  statement syntax:
[OK] // EVAL expression
 <-  EVAL expression
 ->  EVAL expression
[OK] //////////////// TEST PUSHING FOR //////
 <- ////////////// TEST PUSHING FOR //////
 -> ////////////// TEST PUSHING FOR //////
[OK]     FOR selArt(Article article) DO // to be pushed
 <-  to be pushed
 ->  to be pushed
[OK]     FOR selCur(document, Article article) ORDER date(document) DO {  // to be pushed
 <-  to be pushed
 ->  to be pushed
[OK]     FOR selArt(Article article) DO // not to be pushed
 <-  not to be pushed
 ->  not to be pushed
[OK]     FOR selAll(Document document2, Article article) ORDER date(document2) DO { // to be pushed
 <-  to be pushed
 ->  to be pushed
[OK]     FOR date(Document document2) DO { // to be pushed
 <-  to be pushed
 ->  to be pushed
[OK]     FOR quantity(Document document2, Article article) ORDER date(document2) DO { // to be pushed
 <-  to be pushed
 ->  to be pushed
[OK]     READ 'file://c:/sprgrm.dbf' TO importFile;
 <- c:/sprgrm.dbf' TO importFile;
 -> c:/sprgrm.dbf' TO importFile;
[OK]     READ 'file:///c:/sprgrm.fpt' TO memoFile;
 <- /c:/sprgrm.fpt' TO memoFile;
 -> /c:/sprgrm.fpt' TO memoFile;
[OK] ///////////////CONSTRAINT STATEMENT//////////////
 <- /////////////CONSTRAINT STATEMENT//////////////
 -> /////////////CONSTRAINT STATEMENT//////////////
[OK] // Syntax:
 <-  Syntax:
 ->  Syntax:
[OK] // CONSTRAINT propertyExpression [CHECKED [BY propertyName1, ..., propertyNameN]] propertyExpression MESSAGE 'message';
 <-  CONSTRAINT propertyExpression [CHECKED [BY propertyName1, ..., propertyNameN]] propertyExpression MESSAGE 'message';
 ->  CONSTRAINT propertyExpression [CHECKED [BY propertyName1, ..., propertyNameN]] propertyExpression MESSAGE 'message';
[OK] ////////////////FOLLOWS STATEMENT////////////////
 <- //////////////FOLLOWS STATEMENT////////////////
 -> //////////////FOLLOWS STATEMENT////////////////
[OK] // Syntax:
 <-  Syntax:
 ->  Syntax:
[OK] // propertyName(param1, ..., paramN) => propertyExpression [RESOLVE [LEFT] [RIGHT] [SESSION]],
 <-  propertyName(param1, ..., paramN) => propertyExpression [RESOLVE [LEFT] [RIGHT] [SESSION]],
 ->  propertyName(param1, ..., paramN) => propertyExpression [RESOLVE [LEFT] [RIGHT] [SESSION]],
[OK] //foo(store, article) => foo2(store, article) RESOLVE LEFT;
 <- foo(store, article) => foo2(store, article) RESOLVE LEFT;
 -> foo(store, article) => foo2(store, article) RESOLVE LEFT;
[OK] ////////////////WRITEWHEN STATEMENT//////////////
 <- //////////////WRITEWHEN STATEMENT//////////////
 -> //////////////WRITEWHEN STATEMENT//////////////
[OK] // Syntax:
 <-  Syntax:
 ->  Syntax:
[OK] // propertyName(param1, ..., paramN) <- valuePropertyExpression WHEN changePropertyExpression;
 <-  propertyName(param1, ..., paramN) <- valuePropertyExpression WHEN changePropertyExpression;
 ->  propertyName(param1, ..., paramN) <- valuePropertyExpression WHEN changePropertyExpression;
[OK] // inQuantity(document, article) <- 15 WHEN CHANGED(foo(store(document), article));
 <-  inQuantity(document, article) <- 15 WHEN CHANGED(foo(store(document), article));
 ->  inQuantity(document, article) <- 15 WHEN CHANGED(foo(store(document), article));
[OK] ///////////////////EVENT STATEMENT//////////////
 <- /////////////////EVENT STATEMENT//////////////
 -> /////////////////EVENT STATEMENT//////////////
[OK] // Syntax:
 <-  Syntax:
 ->  Syntax:
[OK] // WHEN expression DO action [ORDER [DESC] expr1, ..., exprN] [SESSION];
 <-  WHEN expression DO action [ORDER [DESC] expr1, ..., exprN] [SESSION];
 ->  WHEN expression DO action [ORDER [DESC] expr1, ..., exprN] [SESSION];
[OK] //    EXEC cancel();
 <-     EXEC cancel();
 ->     EXEC cancel();
[OK] /////////////GLOBAL EVENT STATEMENT//////////////
 <- ///////////GLOBAL EVENT STATEMENT//////////////
 -> ///////////GLOBAL EVENT STATEMENT//////////////
[OK] // Syntax:
 <-  Syntax:
 ->  Syntax:
[OK] // ON (GLOBAL | SESSION) action;
 <-  ON (GLOBAL | SESSION) action;
 ->  ON (GLOBAL | SESSION) action;
[OK] ///////////////////ASPECT STATEMENT//////////////
 <- /////////////////ASPECT STATEMENT//////////////
 -> /////////////////ASPECT STATEMENT//////////////
[OK] // Syntax:
 <-  Syntax:
 ->  Syntax:
[OK] // BEFORE | AFTER propertyName(param1, ..., paramN) DO action;
 <-  BEFORE | AFTER propertyName(param1, ..., paramN) DO action;
 ->  BEFORE | AFTER propertyName(param1, ..., paramN) DO action;
[OK] //////////////// FORM STATEMENT /////////////////
 <- ////////////// FORM STATEMENT /////////////////
 -> ////////////// FORM STATEMENT /////////////////
[OK] // Syntax:
 <-  Syntax:
 ->  Syntax:
[OK] // FORM name ['caption'] [DOCKED | FLOAT] | EXTEND FORM name
 <-  FORM name ['caption'] [DOCKED | FLOAT] | EXTEND FORM name
 ->  FORM name ['caption'] [DOCKED | FLOAT] | EXTEND FORM name
[OK] // [(GroupObjects list | TreeGroupObjects list | Properties list | Filters list | Hints list | OrderBy list | filterGroup | dialog form | edit form)]
 <-  [(GroupObjects list | TreeGroupObjects list | Properties list | Filters list | Hints list | OrderBy list | filterGroup | dialog form | edit form)]
 ->  [(GroupObjects list | TreeGroupObjects list | Properties list | Filters list | Hints list | OrderBy list | filterGroup | dialog form | edit form)]
[OK] // ...
 <-  ...
 ->  ...
[OK] // [(GroupObjects list | TreeGroupObjects list | Properties list | Filters list | Hints list | OrderBy list | filterGroup | dialog form | edit form)];
 <-  [(GroupObjects list | TreeGroupObjects list | Properties list | Filters list | Hints list | OrderBy list | filterGroup | dialog form | edit form)];
 ->  [(GroupObjects list | TreeGroupObjects list | Properties list | Filters list | Hints list | OrderBy list | filterGroup | dialog form | edit form)];
[OK] // GroupObjects list syntax:
 <-  GroupObjects list syntax:
 ->  GroupObjects list syntax:
[OK] // OBJECTS object definition | [groupAlias=] (object1 definition, ..., objectN definition) [INIT | NOFLEX] [PANEL | GRID] [PAGESIZE <int value>],
 <-  OBJECTS object definition | [groupAlias=] (object1 definition, ..., objectN definition) [INIT | NOFLEX] [PANEL | GRID] [PAGESIZE <int value>],
 ->  OBJECTS object definition | [groupAlias=] (object1 definition, ..., objectN definition) [INIT | NOFLEX] [PANEL | GRID] [PAGESIZE <int value>],
[OK] //         ...
 <-          ...
 ->          ...
[OK] //         object definition | [groupAlias=] (object1 definition, ..., objectN definition) [INIT | NOFLEX] [PANEL | GRID] [PAGESIZE <int value>]
 <-          object definition | [groupAlias=] (object1 definition, ..., objectN definition) [INIT | NOFLEX] [PANEL | GRID] [PAGESIZE <int value>]
 ->          object definition | [groupAlias=] (object1 definition, ..., objectN definition) [INIT | NOFLEX] [PANEL | GRID] [PAGESIZE <int value>]
[OK] // Object definition syntax:
 <-  Object definition syntax:
 ->  Object definition syntax:
[OK] // [alias=] className ['<caption>'] [ON CHANGE action]
 <-  [alias=] className ['<caption>'] [ON CHANGE action]
 ->  [alias=] className ['<caption>'] [ON CHANGE action]
[OK] // TreeGroup list syntax:
 <-  TreeGroup list syntax:
 ->  TreeGroup list syntax:
[OK] // TREE [SID] [alias=] className ['<caption>'] [PARENT <property>] | [groupAlias=] (object1 definition, ..., objectN definition) [PARENT <properties separated with space>],
 <-  TREE [SID] [alias=] className ['<caption>'] [PARENT <property>] | [groupAlias=] (object1 definition, ..., objectN definition) [PARENT <properties separated with space>],
 ->  TREE [SID] [alias=] className ['<caption>'] [PARENT <property>] | [groupAlias=] (object1 definition, ..., objectN definition) [PARENT <properties separated with space>],
[OK] //            ...
 <-             ...
 ->             ...
[OK] //            [alias=] className ['<caption>'] [PARENT <property>] | [groupAlias=] (object1 definition, ..., objectN definition) [PARENT <properties separated with space>]
 <-             [alias=] className ['<caption>'] [PARENT <property>] | [groupAlias=] (object1 definition, ..., objectN definition) [PARENT <properties separated with space>]
 ->             [alias=] className ['<caption>'] [PARENT <property>] | [groupAlias=] (object1 definition, ..., objectN definition) [PARENT <properties separated with space>]
[OK] // Property list syntax:
 <-  Property list syntax:
 ->  Property list syntax:
[OK] // PROPERTIES [commonOptions] [alias1=]propName1(param1, ..., paramN1) [options1], ..., [aliasK=]propNameK(param1, ..., paramNK) [optionsK]
 <-  PROPERTIES [commonOptions] [alias1=]propName1(param1, ..., paramN1) [options1], ..., [aliasK=]propNameK(param1, ..., paramNK) [optionsK]
 ->  PROPERTIES [commonOptions] [alias1=]propName1(param1, ..., paramN1) [options1], ..., [aliasK=]propNameK(param1, ..., paramNK) [optionsK]
[OK] // or
 <-  or
 ->  or
[OK] // PROPERTIES(param1, ..., paramN) [commonOptions] [alias1=]propName1 [options1], ..., [aliasK=]propNameK [optionsK]
 <-  PROPERTIES(param1, ..., paramN) [commonOptions] [alias1=]propName1 [options1], ..., [aliasK=]propNameK [optionsK]
 ->  PROPERTIES(param1, ..., paramN) [commonOptions] [alias1=]propName1 [options1], ..., [aliasK=]propNameK [optionsK]
[OK] // Special properties: VALUE, NEW, DELETE
 <-  Special properties: VALUE, NEW, DELETE
 ->  Special properties: VALUE, NEW, DELETE
[OK] // Property option:    [READONLY] [CHANGEABLE] [SELECTOR] [HINTNOUPDATE] [HINTTABLE] [COLUMNS (<groupObject list>)] [SHOWIF <mappedProperty>] [BACKGROUND <mappedProperty>]
 <-  Property option:    [READONLY] [CHANGEABLE] [SELECTOR] [HINTNOUPDATE] [HINTTABLE] [COLUMNS (<groupObject list>)] [SHOWIF <mappedProperty>] [BACKGROUND <mappedProperty>]
 ->  Property option:    [READONLY] [CHANGEABLE] [SELECTOR] [HINTNOUPDATE] [HINTTABLE] [COLUMNS (<groupObject list>)] [SHOWIF <mappedProperty>] [BACKGROUND <mappedProperty>]
[OK] //                     [HEADER <mappedProperty>] [FOOTER <mappedProperty>] [READONLYIF <mappedProperty>] [PANEL | GRID] [DRAW <groupObject>]
 <-                      [HEADER <mappedProperty>] [FOOTER <mappedProperty>] [READONLYIF <mappedProperty>] [PANEL | GRID] [DRAW <groupObject>]
 ->                      [HEADER <mappedProperty>] [FOOTER <mappedProperty>] [READONLYIF <mappedProperty>] [PANEL | GRID] [DRAW <groupObject>]
[OK] //                     [FOREGROUND <mappedProperty>] [ON (CHANGE | CHANGEWYS | CONTEXTMENU | EDIT) <mappedAction>] [(BEFORE | AFTER) (propertyAlias | <mappedProperty>)] [EVENTID 'id']
 <-                      [FOREGROUND <mappedProperty>] [ON (CHANGE | CHANGEWYS | CONTEXTMENU | EDIT) <mappedAction>] [(BEFORE | AFTER) (propertyAlias | <mappedProperty>)] [EVENTID 'id']
 ->                      [FOREGROUND <mappedProperty>] [ON (CHANGE | CHANGEWYS | CONTEXTMENU | EDIT) <mappedAction>] [(BEFORE | AFTER) (propertyAlias | <mappedProperty>)] [EVENTID 'id']
[OK] // Filters list syntax:
 <-  Filters list syntax:
 ->  Filters list syntax:
[OK] // FILTERS propertyExpression1, ..., propertyExpressionK
 <-  FILTERS propertyExpression1, ..., propertyExpressionK
 ->  FILTERS propertyExpression1, ..., propertyExpressionK
[OK] // Events list syntax:
 <-  Events list syntax:
 ->  Events list syntax:
[OK] // EVENTS
 <-  EVENTS
 ->  EVENTS
[OK] // ON (INIT | APPLY (BEFORE | AFTER) | OK | CANCEL | CLOSE | DROP | QUERYCLOSE) action1,
 <-  ON (INIT | APPLY (BEFORE | AFTER) | OK | CANCEL | CLOSE | DROP | QUERYCLOSE) action1,
 ->  ON (INIT | APPLY (BEFORE | AFTER) | OK | CANCEL | CLOSE | DROP | QUERYCLOSE) action1,
[OK] // ...
 <-  ...
 ->  ...
[OK] // ON (INIT | APPLY (BEFORE | AFTER) | OK | CANCEL | CLOSE | DROP | QUERYCLOSE) actionN
 <-  ON (INIT | APPLY (BEFORE | AFTER) | OK | CANCEL | CLOSE | DROP | QUERYCLOSE) actionN
 ->  ON (INIT | APPLY (BEFORE | AFTER) | OK | CANCEL | CLOSE | DROP | QUERYCLOSE) actionN
[OK] // Hints list syntax:
 <-  Hints list syntax:
 ->  Hints list syntax:
[OK] // HINTNOUPDATE | HINTTABLE propertyName1, ..., propertyNameN
 <-  HINTNOUPDATE | HINTTABLE propertyName1, ..., propertyNameN
 ->  HINTNOUPDATE | HINTTABLE propertyName1, ..., propertyNameN
[OK] // Order list syntax:
 <-  Order list syntax:
 ->  Order list syntax:
[OK] // ORDER (propertyAlias1 | <mappedProperty1>), ..., (propertyAliasN | <mappedPropertyN>)
 <-  ORDER (propertyAlias1 | <mappedProperty1>), ..., (propertyAliasN | <mappedPropertyN>)
 ->  ORDER (propertyAlias1 | <mappedProperty1>), ..., (propertyAliasN | <mappedPropertyN>)
[OK] //        ELSE {
 <-         ELSE {
 ->         ELSE {
[OK] //            MESSAGE 'You pressed "close"';
 <-             MESSAGE 'You pressed "close"';
 ->             MESSAGE 'You pressed "close"';
[OK] //        }
 <-         }
 ->         }
[OK] //    FOR Store s IS Store DO {
 <-     FOR Store s IS Store DO {
 ->     FOR Store s IS Store DO {
[OK] //        staticCaption(s) <- 'Склад ' + s;
 <-         staticCaption(s) <- 'Склад ' + s;
 ->         staticCaption(s) <- 'Warehouse ' + s;
[OK] //    }
 <-     }
 ->     }
[OK] //    FOR Article a IS Article DO {
 <-     FOR Article a IS Article DO {
 ->     FOR Article a IS Article DO {
[OK] //        staticCaption(a) <- 'Товар ' + a;
 <-         staticCaption(a) <- 'Товар ' + a;
 ->         staticCaption(a) <- 'Product ' + a;
[OK] //    }
 <-     }
 ->     }
[OK] //staticCaption(Store s) <- 'Склад ' + s WHEN SET(s IS Store);
 <- staticCaption(Store s) <- 'Склад ' + s WHEN SET(s IS Store);
 -> staticCaption(Store s) <- 'Warehouse ' + s WHEN SET(s IS Store);
[OK] //    FROM 'luxsoft@adsl.by'
 <-     FROM 'luxsoft@adsl.by'
 ->     FROM 'luxsoft@adsl.by'
[OK] //    BCC 'luxsoft@adsl.by'
 <-     BCC 'luxsoft@adsl.by'
 ->     BCC 'luxsoft@adsl.by'
[OK] //fs = ABSTRACT BOOLEAN (Store);
 <- fs = ABSTRACT BOOLEAN (Store);
 -> fs = ABSTRACT BOOLEAN (Store);
[OK] //countF 'Кол-во фильтр. складов' = GROUP SUM 1 IF fs(s);
 <- countF 'Кол-во фильтр. складов' = GROUP SUM 1 IF fs(s);
 -> countF 'Number of filtered warehouses' = GROUP SUM 1 IF fs(s);
[OK] //setNameX 'Добавить X к имени' = () {
 <- setNameX 'Добавить X к имени' = () {
 -> setNameX 'Add X to name' = () {
[OK] //    FOR fs(s) DO
 <-     FOR fs(s) DO
 ->     FOR fs(s) DO
[OK] //        name(s) <- 'X' + name(s);
 <-         name(s) <- 'X' + name(s);
 ->         name(s) <- 'X' + name(s);
[OK] //}
 <- }
 -> }
[OK] sss = storeSizeName(Store s);// CHARWIDTH 51;
 <-  CHARWIDTH 51;
 ->  CHARWIDTH 51;
[OK] //    PROPERTIES() countF, setNameX
 <-     PROPERTIES() countF, setNameX
 ->     PROPERTIES() countF, setNameX
[OK] //WHEN LOCAL CHANGED([ VIEW storeArticle.s](s)) DO {
 <- WHEN LOCAL CHANGED([ VIEW storeArticle.s](s)) DO {
 -> WHEN LOCAL CHANGED([ VIEW storeArticle.s](s)) DO {
[OK] //    name(s) <- 'U' + name(s);
 <-     name(s) <- 'U' + name(s);
 ->     name(s) <- 'U' + name(s);
[OK] //}
 <- }
 -> }
[OK] //////////////// DESIGN STATEMENT /////////////////
 <- ////////////// DESIGN STATEMENT /////////////////
 -> ////////////// DESIGN STATEMENT /////////////////
[OK] //        font = '"Times New Roman" bold 36';
 <-         font = '"Times New Roman" bold 36';
 ->         font = '"Times New Roman" bold 36';
[OK] //        font = '';
 <-         font = '';
 ->         font = '';
[OK] //        font = '5';
 <-         font = '5';
 ->         font = '5';
[OK] //        fontSize = 36;
 <-         fontSize = 36;
 ->         fontSize = 36;
[OK] //        fontStyle = 'bold';
 <-         fontStyle = 'bold';
 ->         fontStyle = 'bold';
[OK] //        font = 'Tahoma 36';
 <-         font = 'Tahoma 36';
 ->         font = 'Tahoma 36';
[OK] //fs(s) += [ FILTER storeArticle.s](s);
 <- fs(s) += [ FILTER storeArticle.s](s);
 -> fs(s) += [ FILTER storeArticle.s](s);
[OK]     // To use this form as EDIT\DIALOG\LIST form for some class (for ex. store)
 <-  To use this form as EDIT\DIALOG\LIST form for some class (for ex. store)
 ->  To use this form as EDIT\DIALOG\LIST form for some class (for ex. store)
[OK]     // Use this syntax:
 <-  Use this syntax:
 ->  Use this syntax:
[OK]     //(EDIT | DIALOG | LIST) <className> OBJECT <objectName>
 <- (EDIT | DIALOG | LIST) <className> OBJECT <objectName>
 -> (EDIT | DIALOG | LIST) <className> OBJECT <objectName>
[OK] //castToInt = INTEGER(sstring(s));
 <- castToInt = INTEGER(sstring(s));
 -> castToInt = INTEGER(sstring(s));
[OK] //        MESSAGE 'FOUND: ' + name(dialogBarcodeArticle()) + '; current: ' + name(article);
 <-         MESSAGE 'FOUND: ' + name(dialogBarcodeArticle()) + '; current: ' + name(article);
 ->         MESSAGE 'FOUND: ' + name(dialogBarcodeArticle()) + '; current: ' + name(article);
[OK] //        MESSAGE 'NOT FOUND: current: ' + name(article);
 <-         MESSAGE 'NOT FOUND: current: ' + name(article);
 ->         MESSAGE 'NOT FOUND: current: ' + name(article);
[OK] //    PROPERTY(sinteger) {height = 100; }
 <-     PROPERTY(sinteger) {height = 100; }
 ->     PROPERTY(sinteger) {height = 100; }
[OK] //    NEWSESSION (addedStore, ssstring) {
 <-     NEWSESSION (addedStore, ssstring) {
 ->     NEWSESSION (addedStore, ssstring) {
[OK] //    MESSAGE 'Begin';
 <-     MESSAGE 'Begin';
 ->     MESSAGE 'Begin';
[OK] //    MESSAGE 'End';
 <-     MESSAGE 'End';
 ->     MESSAGE 'End';
[OK] //tstCustom  INTERNAL  'samples.TestCustomActionProperty' ();
 <- tstCustom  INTERNAL  'samples.TestCustomActionProperty' ();
 -> tstCustom  INTERNAL  'samples.TestCustomActionProperty' ();
[OK] //EXTERNAL examples
 <- EXTERNAL examples
 -> EXTERNAL examples
[OK] //testFile = DATA LOCAL FILE ();
 <- testFile = DATA LOCAL FILE ();
 -> testFile = DATA LOCAL FILE ();
[OK] //testFile2 = DATA LOCAL FILE ();
 <- testFile2 = DATA LOCAL FILE ();
 -> testFile2 = DATA LOCAL FILE ();
[OK] //str1 = DATA LOCAL STRING[100] (Store);
 <- str1 = DATA LOCAL STRING[100] (Store);
 -> str1 = DATA LOCAL STRING[100] (Store);
[OK] //str2 = DATA LOCAL STRING[100] (Store);
 <- str2 = DATA LOCAL STRING[100] (Store);
 -> str2 = DATA LOCAL STRING[100] (Store);
[OK] //str3 = DATA LOCAL STRING[100] (Store);
 <- str3 = DATA LOCAL STRING[100] (Store);
 -> str3 = DATA LOCAL STRING[100] (Store);
[OK] //externalDB = EXTERNAL DB 'jdbc:($1)://($2)/eqs?user=root&password=' EXEC 'select ($3), date from history' TO testFile;
 <- externalDB = EXTERNAL DB 'jdbc:($1)://($2)/eqs?user=root&password=' EXEC 'select ($3), date from history' TO testFile;
 -> externalDB = EXTERNAL DB 'jdbc:($1)://($2)/eqs?user=root&password=' EXEC 'select ($3), date from history' TO testFile;
[OK] //externalHTTP = EXTERNAL HTTP 'https://www.gastronom.ru/($1)/images/20170418/b7568ebc.jpg' TO testFile, testFile2;
 <- externalHTTP = EXTERNAL HTTP 'https://www.gastronom.ru/($1)/images/20170418/b7568ebc.jpg' TO testFile, testFile2;
 -> externalHTTP = EXTERNAL HTTP 'https://www.gastronom.ru/($1)/images/20170418/b7568ebc.jpg' TO testFile, testFile2;
[OK] //
 <- 
 -> 
[OK] //testCustomHTTP(Store s)  { 
 <- testCustomHTTP(Store s)  { 
 -> testCustomHTTP(Store s)  { 
[OK] //    str1(s) <- 'binfiles';
 <-     str1(s) <- 'binfiles';
 ->     str1(s) <- 'binfiles';
[OK] //    externalHTTP(str1(s));
 <-     externalHTTP(str1(s));
 ->     externalHTTP(str1(s));
[OK] //    open(testFile());
 <-     open(testFile());
 ->     open(testFile());
[OK] //    open(testFile2());
 <-     open(testFile2());
 ->     open(testFile2());
[OK] //}
 <- }
 -> }
[OK] //
 <- 
 -> 
[OK] //testCustomDB(Store s)  { 
 <- testCustomDB(Store s)  { 
 -> testCustomDB(Store s)  { 
[OK] //    str1(s) <- 'mysql';
 <-     str1(s) <- 'mysql';
 ->     str1(s) <- 'mysql';
[OK] //    str2(s) <- 'localhost';
 <-     str2(s) <- 'localhost';
 ->     str2(s) <- 'localhost';
[OK] //    str3(s) <- 'id';
 <-     str3(s) <- 'id';
 ->     str3(s) <- 'id';
[OK] //    externalDB(str1(s),str2(s), str3(s));
 <-     externalDB(str1(s),str2(s), str3(s));
 ->     externalDB(str1(s),str2(s), str3(s));
[OK] //}
 <- }
 -> }
[OK] //WHEN f(A a) < g(a) DO
 <- WHEN f(A a) < g(a) DO
 -> WHEN f(A a) < g(a) DO
[OK] //    tstCustom();
 <-     tstCustom();
 ->     tstCustom();
[OK] //        tstCustom();
 <-         tstCustom();
 ->         tstCustom();
[OK] //path() = 'file:///C:/temp.txt';
 <- path() = 'file:///C:/temp.txt';
 -> path() = 'file:///C:/temp.txt';
[OK] //////////////// INDEX STATEMENT //////////////////
 <- ////////////// INDEX STATEMENT //////////////////
 -> ////////////// INDEX STATEMENT //////////////////
[OK] // Syntax:
 <-  Syntax:
 ->  Syntax:
[OK] // INDEX propertyName1(param1, ..., paramN) | paramI  [, ..., propertyNameN (param1, ..., paramN) | paramI];
 <-  INDEX propertyName1(param1, ..., paramN) | paramI  [, ..., propertyNameN (param1, ..., paramN) | paramI];
 ->  INDEX propertyName1(param1, ..., paramN) | paramI  [, ..., propertyNameN (param1, ..., paramN) | paramI];
[OK] //////////////// WINDOW STATEMENT /////////////////
 <- ////////////// WINDOW STATEMENT /////////////////
 -> ////////////// WINDOW STATEMENT /////////////////
[OK] // Add new window statement
 <-  Add new window statement
 ->  Add new window statement
[OK] // Syntax:
 <-  Syntax:
 ->  Syntax:
[OK] // WINDOW <name> '<caption>' (MENU | PANEL | TREE | TOOLBAR) [ option [, option ...] ]
 <-  WINDOW <name> '<caption>' (MENU | PANEL | TREE | TOOLBAR) [ option [, option ...] ]
 ->  WINDOW <name> '<caption>' (MENU | PANEL | TREE | TOOLBAR) [ option [, option ...] ]
[OK] // option ::=   HIDETITLE |
 <-  option ::=   HIDETITLE |
 ->  option ::=   HIDETITLE |
[OK] //              HIDESCROLLBARS |
 <-               HIDESCROLLBARS |
 ->               HIDESCROLLBARS |
[OK] //              DRAWROOT |
 <-               DRAWROOT |
 ->               DRAWROOT |
[OK] //              (VERTICAL | HORIZONTAL) |
 <-               (VERTICAL | HORIZONTAL) |
 ->               (VERTICAL | HORIZONTAL) |
[OK] //              (LEFT | RIGHT | TOP | BOTTOM) |
 <-               (LEFT | RIGHT | TOP | BOTTOM) |
 ->               (LEFT | RIGHT | TOP | BOTTOM) |
[OK] //              POSITION(x, y, w, h) |
 <-               POSITION(x, y, w, h) |
 ->               POSITION(x, y, w, h) |
[OK] //              HALIGN( START | CENTER | END ) |
 <-               HALIGN( START | CENTER | END ) |
 ->               HALIGN( START | CENTER | END ) |
[OK] //              VALIGN( START | CENTER | END ) |
 <-               VALIGN( START | CENTER | END ) |
 ->               VALIGN( START | CENTER | END ) |
[OK] //              TEXTHALIGN( START | CENTER | END ) |
 <-               TEXTHALIGN( START | CENTER | END ) |
 ->               TEXTHALIGN( START | CENTER | END ) |
[OK] //              TEXTVALIGN( START | CENTER | END ) |
 <-               TEXTVALIGN( START | CENTER | END ) |
 ->               TEXTVALIGN( START | CENTER | END ) |
[OK] //Hide window
 <- Hide window
 -> Hide window
[OK] //HIDE WINDOW System.log;
 <- HIDE WINDOW System.log;
 -> HIDE WINDOW System.log;
[OK] //////////////// NAVIGATOR STATEMENT /////////////////
 <- ////////////// NAVIGATOR STATEMENT /////////////////
 -> ////////////// NAVIGATOR STATEMENT /////////////////
[OK] //настройка навигатора
 <- настройка навигатора
 -> configuring the navigator
[OK]     // чтобы добавить существующий элемент в другой элемент используется команда следующего вида
 <-  чтобы добавить существующий элемент в другой элемент используется команда следующего вида
 ->  to add an existing element to another element, the following command is used
[OK]     // NEW <имя> ['<новый заголовок>'] [((AFTER | BEFORE) <имя2>) | FIRST] [WINDOW <новое окно>];
 <-  NEW <имя> ['<новый заголовок>'] [((AFTER | BEFORE) <имя2>) | FIRST] [WINDOW <новое окно>];
 ->  NEW <name> ['<new caption>'] [((AFTER | BEFORE) <name2>) | FIRST] [WINDOW <new window>];
[OK]     // при этом по умолчанию он будет добавлен в элемент текущей области видимости
 <-  при этом по умолчанию он будет добавлен в элемент текущей области видимости
 ->  here by default it will be added to the element of the current scope
[OK]     // (при использовании прямо внутри NAVIGATOR - он будет добавлен в baseElement)
 <-  (при использовании прямо внутри NAVIGATOR - он будет добавлен в baseElement)
 ->  (when used right inside the NAVIGATOR, it will be added to the baseElement)
[OK]     //
 <- 
 -> 
[OK]     // для создания нового элемента используется команда:
 <-  для создания нового элемента используется команда:
 ->  to create a new item, the following command is used:
[OK]     // NEW <имя> ['<заголовок>'] [ACTION <имя экшена>] [((AFTER | BEFORE) <имя2>) | FIRST] [WINDOW <имя окна>] [IMAGE <путь к иконке>];
 <-  NEW <имя> ['<заголовок>'] [ACTION <имя экшена>] [((AFTER | BEFORE) <имя2>) | FIRST] [WINDOW <имя окна>] [IMAGE <путь к иконке>];
 ->  NEW <name> ['<caption>'] [ACTION <action name>] [((AFTER | BEFORE) <name2>) | FIRST] [WINDOW <window name>] [IMAGE <path to icon>];
[OK]     // также можно просто настраивать существующий элемент без его перемещения
 <-  также можно просто настраивать существующий элемент без его перемещения
 ->  it is also possible to just customize an existing element without moving it
[OK]             //...
 <- ...
 -> ...
[OK]         //если задано имя действия, то создаться элемент для запуска этого действия
 <- если задано имя действия, то создаться элемент для запуска этого действия
 -> if an action name is defined, then an element is created to execute this action
[OK]     // так можно отдельно настроить окно, в которое будет рисоваться элемент
 <-  так можно отдельно настроить окно, в которое будет рисоваться элемент
 ->  in such a way the window into which the element will be drawn can be separately configured
[OK] //////////////// METACODE STATEMENT /////////////
 <- ////////////// METACODE STATEMENT /////////////
 -> ////////////// METACODE STATEMENT /////////////
[OK] // Syntax:
 <-  Syntax:
 ->  Syntax:
[OK] // META codeName([param1, ..., paramN]) metacode END
 <-  META codeName([param1, ..., paramN]) metacode END
 ->  META codeName([param1, ..., paramN]) metacode END
[OK] //
 <- 
 -> 
[OK] // Metacode usage syntax:
 <-  Metacode usage syntax:
 ->  Metacode usage syntax:
[OK] // @codeName([[param1], ..., [paramN]]);
 <-  @codeName([[param1], ..., [paramN]]);
 ->  @codeName([[param1], ..., [paramN]]);
[OK] //
 <- 
 -> 
[OK] // concatenation operator: ##
 <-  concatenation operator: ##
 ->  concatenation operator: ##
[OK] // concatenation capitalize operator: ###
 <-  concatenation capitalize operator: ###
 ->  concatenation capitalize operator: ###
[OK] //////////////// TABLE STATEMENT ////////////////
 <- ////////////// TABLE STATEMENT ////////////////
 -> ////////////// TABLE STATEMENT ////////////////
[OK] // Syntax:
 <-  Syntax:
 ->  Syntax:
[OK] // TABLE name(className1, ..., classNameN);
 <-  TABLE name(className1, ..., classNameN);
 ->  TABLE name(className1, ..., classNameN);
[OK] //fib(i, to) = RECURSION 1 IF (i==0 OR i==1) AND to IS INTEGER STEP 1 IF (i==$i+1 OR i==$i+2) AND i<to;
 <- fib(i, to) = RECURSION 1 IF (i==0 OR i==1) AND to IS INTEGER STEP 1 IF (i==$i+1 OR i==$i+2) AND i<to;
 -> fib(i, to) = RECURSION 1 IF (i==0 OR i==1) AND to IS INTEGER STEP 1 IF (i==$i+1 OR i==$i+2) AND i<to;
[OK] //    NEW caseTest;
 <-     NEW caseTest;
 ->     NEW caseTest;
[OK] // MULTITHREADING, LOCKS
 <-  MULTITHREADING, LOCKS
 ->  MULTITHREADING, LOCKS
[OK] //    FOR iterate(i,0,4) DO
 <-     FOR iterate(i,0,4) DO
 ->     FOR iterate(i,0,4) DO
[OK] //    FOR iterate(i,0,4) DO
 <-     FOR iterate(i,0,4) DO
 ->     FOR iterate(i,0,4) DO
[OK] //        NEWTHREAD {
 <-         NEWTHREAD {
 ->         NEWTHREAD {
[OK] //        }
 <-         }
 ->         }
[OK] //    OBJECTS o=CommonObject
 <-     OBJECTS o=CommonObject
 ->     OBJECTS o=CommonObject
[OK] //    PROPERTIES (o) staticName, staticCaption, balanceChange
 <-     PROPERTIES (o) staticName, staticCaption, balanceChange
 ->     PROPERTIES (o) staticName, staticCaption, balanceChange
[OK] //    OBJECTS c=Change
 <-     OBJECTS c=Change
 ->     OBJECTS c=Change
[OK] //    PROPERTIES VALUE(c), quantityChange(c, o)
 <-     PROPERTIES VALUE(c), quantityChange(c, o)
 ->     PROPERTIES VALUE(c), quantityChange(c, o)
[OK] //    FILTERS quantityChange(c,o)
 <-     FILTERS quantityChange(c,o)
 ->     FILTERS quantityChange(c,o)
[OK] //    OBJECTS o=CommonObject
 <-     OBJECTS o=CommonObject
 ->     OBJECTS o=CommonObject
[OK] //    PROPERTIES (o) staticName, staticCaption, balanceChange
 <-     PROPERTIES (o) staticName, staticCaption, balanceChange
 ->     PROPERTIES (o) staticName, staticCaption, balanceChange
[OK] //    OBJECTS c=Change
 <-     OBJECTS c=Change
 ->     OBJECTS c=Change
[OK] //    PROPERTIES VALUE(c), quantityChange(c, o)
 <-     PROPERTIES VALUE(c), quantityChange(c, o)
 ->     PROPERTIES VALUE(c), quantityChange(c, o)
[OK] //    FILTERS quantityChange(c,o)
 <-     FILTERS quantityChange(c,o)
 ->     FILTERS quantityChange(c,o)
[OK] 	    READ 'file://c:/1.txt' TO zippingFile;
 <- c:/1.txt' TO zippingFile;
 -> c:/1.txt' TO zippingFile;
[OK] 	    READ 'file://c:/2.xml' TO zippingFile;
 <- c:/2.xml' TO zippingFile;
 -> c:/2.xml' TO zippingFile;
[OK] //CLASS PA;
 <- CLASS PA;
 -> CLASS PA;
[OK] //order = DATA INTEGER (PA);
 <- order = DATA INTEGER (PA);
 -> order = DATA INTEGER (PA);
[OK] //restr = DATA INTEGER (PA);
 <- restr = DATA INTEGER (PA);
 -> restr = DATA INTEGER (PA);
[OK] //ungroup = DATA INTEGER ();
 <- ungroup = DATA INTEGER ();
 -> ungroup = DATA INTEGER ();
[OK] //ungroup2 = DATA INTEGER ();
 <- ungroup2 = DATA INTEGER ();
 -> ungroup2 = DATA INTEGER ();
[OK] //result (PA a) = PARTITION UNGROUP ungroup LIMIT restr(a) ORDER order(a);
 <- result (PA a) = PARTITION UNGROUP ungroup LIMIT restr(a) ORDER order(a);
 -> result (PA a) = PARTITION UNGROUP ungroup LIMIT restr(a) ORDER order(a);
[OK] //result2 (PA a) = PARTITION UNGROUP ungroup LIMIT STRICT restr(a) ORDER order(a);
 <- result2 (PA a) = PARTITION UNGROUP ungroup LIMIT STRICT restr(a) ORDER order(a);
 -> result2 (PA a) = PARTITION UNGROUP ungroup LIMIT STRICT restr(a) ORDER order(a);
[OK] //
 <- 
 -> 
[OK] //FORM tstPart
 <- FORM tstPart
 -> FORM tstPart
[OK] //    PROPERTIES () ungroup, ungroup2
 <-     PROPERTIES () ungroup, ungroup2
 ->     PROPERTIES () ungroup, ungroup2
[OK] //    OBJECTS a=PA
 <-     OBJECTS a=PA
 ->     OBJECTS a=PA
[OK] //    PROPERTIES (a) NEW, order, restr, result, result2
 <-     PROPERTIES (a) NEW, order, restr, result, result2
 ->     PROPERTIES (a) NEW, order, restr, result, result2
[OK] //;
 <- ;
 -> ;
[OK] //
 <- 
 -> 
[OK] //NAVIGATOR {
 <- NAVIGATOR {
 -> NAVIGATOR {
[OK] //    NEW tstPart;
 <-     NEW tstPart;
 ->     NEW tstPart;
[OK] //}
 <- }
 -> }
[OK] //edit(A1 a1) + {  SHOW TFA1 OBJECTS a1=a1; }
 <- edit(A1 a1) + {  SHOW TFA1 OBJECTS a1=a1; }
 -> edit(A1 a1) + {  SHOW TFA1 OBJECTS a1=a1; }
[OK] //    EDIT A2 OBJECT a2
 <-     EDIT A2 OBJECT a2
 ->     EDIT A2 OBJECT a2
[OK] //edit(A2 a2) + {  SHOW TFA2 OBJECTS a2=a2; }
 <- edit(A2 a2) + {  SHOW TFA2 OBJECTS a2=a2; }
 -> edit(A2 a2) + {  SHOW TFA2 OBJECTS a2=a2; }
[OK] //edit(A3 a3) + {  SHOW TFA3 OBJECTS a3=a3; }
 <- edit(A3 a3) + {  SHOW TFA3 OBJECTS a3=a3; }
 -> edit(A3 a3) + {  SHOW TFA3 OBJECTS a3=a3; }
[OK] //    ASK 'Are you sure?' d=YESNO DO {
 <-     ASK 'Are you sure?' d=YESNO DO {
 ->     ASK 'Are you sure?' d=YESNO DO {
[OK] //        ASK 'Definitely' IF NOT d DO { 
 <-         ASK 'Definitely' IF NOT d DO { 
 ->         ASK 'Definitely' IF NOT d DO { 
[OK] //            DIALOG InputC OBJECTS c INPUT z DO 
 <-             DIALOG InputC OBJECTS c INPUT z DO 
 ->             DIALOG InputC OBJECTS c INPUT z DO 
[OK] //                dq(s, a) <- z;       
 <-                 dq(s, a) <- z;       
 ->                 dq(s, a) <- z;       
[OK] //        }
 <-         }
 ->         }
[OK] //    }
 <-     }
 ->     }
[OK] //    FOR DOUBLE c == 5 DO {
 <-     FOR DOUBLE c == 5 DO {
 ->     FOR DOUBLE c == 5 DO {
[OK] //        LOCAL rrr = DOUBLE ();
 <-         LOCAL rrr = DOUBLE ();
 ->         LOCAL rrr = DOUBLE ();
[OK] //        DIALOG InputC OBJECTS c=dq(s,a) INPUT b TO rrr,d INPUT y, s INPUT z DO 
 <-         DIALOG InputC OBJECTS c=dq(s,a) INPUT b TO rrr,d INPUT y, s INPUT z DO 
 ->         DIALOG InputC OBJECTS c=dq(s,a) INPUT b TO rrr,d INPUT y, s INPUT z DO 
[OK] //            dq(s, a) <- b (+) y;
 <-             dq(s, a) <- b (+) y;
 ->             dq(s, a) <- b (+) y;
[OK] //    }
 <-     }
 ->     }
[OK]     EXTERNAL SQL 'jdbc:postgresql://localhost/testdb?user=postgres&password=11111' EXEC 'SELECT x.a,x.b,x.c,x.d FROM $1 x WHERE x.a > $2;' PARAMS a, b TO testExternalResult; 
 <- localhost/testdb?user=postgres&password=11111' EXEC 'SELECT x.a,x.b,x.c,x.d FROM $1 x WHERE x.a > $2;' PARAMS a, b TO testExternalResult; 
 -> localhost/testdb?user=postgres&password=11111' EXEC 'SELECT x.a,x.b,x.c,x.d FROM $1 x WHERE x.a > $2;' PARAMS a, b TO testExternalResult; 
[OK] //    open(t());
 <-     open(t());
 ->     open(t());
[OK] //    IMPORT XML ROOT 'export' TO xa=a, xb=b, xc=c, xd=d, xs=s FROM t();
 <-     IMPORT XML ROOT 'export' TO xa=a, xb=b, xc=c, xd=d, xs=s FROM t();
 ->     IMPORT XML ROOT 'export' TO xa=a, xb=b, xc=c, xd=d, xs=s FROM t();
[OK] //    EXTERNAL SQL '$1' EXEC 'SELECT x.a,x.b,x.c,x.d FROM $2 x WHERE x.a > $3;' PARAMS 'jdbc:postgresql://localhost/vitalur?user=postgres&password=11111', t(), 7 TO testExternalResult;
 <-     EXTERNAL SQL '$1' EXEC 'SELECT x.a,x.b,x.c,x.d FROM $2 x WHERE x.a > $3;' PARAMS 'jdbc:postgresql://localhost/vitalur?user=postgres&password=11111', t(), 7 TO testExternalResult;
 ->     EXTERNAL SQL '$1' EXEC 'SELECT x.a,x.b,x.c,x.d FROM $2 x WHERE x.a > $3;' PARAMS 'jdbc:postgresql://localhost/vitalur?user=postgres&password=11111', t(), 7 TO testExternalResult;
[OK]     EXTERNAL LSF 'http://localhost:7651' EXEC 'Features.testImport[FILE]' PARAMS t();
 <- localhost:7651' EXEC 'Features.testImport[FILE]' PARAMS t();
 -> localhost:7651' EXEC 'Features.testImport[FILE]' PARAMS t();
[OK] //            fill = 0;
 <-             fill = 0;
 ->             fill = 0;
[OK] //    vtst(a) <- 'fggf   ' WHERE a=1;
 <-     vtst(a) <- 'fggf   ' WHERE a=1;
 ->     vtst(a) <- 'fggf   ' WHERE a=1;
[OK] //    vtst(a) <- 'tggf   ' WHERE a=2;
 <-     vtst(a) <- 'tggf   ' WHERE a=2;
 ->     vtst(a) <- 'tggf   ' WHERE a=2;
[OK] //     vtst(a) <- tst(a);
 <-      vtst(a) <- tst(a);
 ->      vtst(a) <- tst(a);
[OK] //     vtst(a) <- tst(1) WHERE a=1;
 <-      vtst(a) <- tst(1) WHERE a=1;
 ->      vtst(a) <- tst(1) WHERE a=1;
[OK] //     vtst(a) <- tst(2) WHERE a=2;
 <-      vtst(a) <- tst(2) WHERE a=2;
 ->      vtst(a) <- tst(2) WHERE a=2;
[OK] 	//LOCAL dbf = FILE ();	
 <- LOCAL dbf = FILE ();	
 -> LOCAL dbf = FILE ();	
[OK] 	//EXPORT DBF FROM f(INTEGER a) TO dbf;
 <- EXPORT DBF FROM f(INTEGER a) TO dbf;
 -> EXPORT DBF FROM f(INTEGER a) TO dbf;
[OK] 	//EXPORT FROM 5, xml(), dbf();
 <- EXPORT FROM 5, xml(), dbf();
 -> EXPORT FROM 5, xml(), dbf();
[OK] //	EXPORT XML FROM a=incomeQuantity(Store s,Article a), b=Features.name(a), c=barcode(a), d=Features.name(a), s=Features.name(s) WHERE incomeQuantity(s, a);	
 <- 	EXPORT XML FROM a=incomeQuantity(Store s,Article a), b=Features.name(a), c=barcode(a), d=Features.name(a), s=Features.name(s) WHERE incomeQuantity(s, a);	
 -> 	EXPORT XML FROM a=incomeQuantity(Store s,Article a), b=Features.name(a), c=barcode(a), d=Features.name(a), s=Features.name(s) WHERE incomeQuantity(s, a);	
[OK] //	test(5);
 <- 	test(5);
 -> 	test(5);
[OK]     EXTERNAL LSF 'http://localhost:7651' EXEC 'Features.tstexp[]' TO result, xml, dbf;
 <- localhost:7651' EXEC 'Features.tstexp[]' TO result, xml, dbf;
 -> localhost:7651' EXEC 'Features.tstexp[]' TO result, xml, dbf;
[OK]     //OBJECTS dt = DATE PANEL 
 <- OBJECTS dt = DATE PANEL 
 -> OBJECTS dt = DATE PANEL 
[OK]     //PROPERTIES date = VALUE(dt)
 <- PROPERTIES date = VALUE(dt)
 -> PROPERTIES date = VALUE(dt)
[OK] //FORM testABAggr
 <- FORM testABAggr
 -> FORM testABAggr
[OK] //    OBJECTS xa = XA
 <-     OBJECTS xa = XA
 ->     OBJECTS xa = XA
[OK] //    OBJECTS xad = XADetail
 <-     OBJECTS xad = XADetail
 ->     OBJECTS xad = XADetail
[OK] //    PROPERTIES name(xa), name(xad)
 <-     PROPERTIES name(xa), name(xad)
 ->     PROPERTIES name(xa), name(xad)
[OK] //    PROPERTIES (xa) NEW, VALUE SELECTOR, DELETE, createXB 
 <-     PROPERTIES (xa) NEW, VALUE SELECTOR, DELETE, createXB 
 ->     PROPERTIES (xa) NEW, VALUE SELECTOR, DELETE, createXB 
[OK] //    PROPERTIES =ask(xa)
 <-     PROPERTIES =ask(xa)
 ->     PROPERTIES =ask(xa)
[OK] //    PROPERTIES (xad) NEW, DELETE
 <-     PROPERTIES (xad) NEW, DELETE
 ->     PROPERTIES (xad) NEW, DELETE
[OK] //
 <- 
 -> 
[OK] //    FILTERS xa(xad) = xa
 <-     FILTERS xa(xad) = xa
 ->     FILTERS xa(xad) = xa
[OK] //
 <- 
 -> 
[OK] //    OBJECTS xadl = XADetailLog
 <-     OBJECTS xadl = XADetailLog
 ->     OBJECTS xadl = XADetailLog
[OK] //    PROPERTIES (xadl) xa, name
 <-     PROPERTIES (xadl) xa, name
 ->     PROPERTIES (xadl) xa, name
[OK] //
 <- 
 -> 
[OK] //    OBJECTS xb = XB
 <-     OBJECTS xb = XB
 ->     OBJECTS xb = XB
[OK] //    OBJECTS xbd = XBDetail
 <-     OBJECTS xbd = XBDetail
 ->     OBJECTS xbd = XBDetail
[OK] //    PROPERTIES name(xb), name(xbd), =name(xb(xbd))
 <-     PROPERTIES name(xb), name(xbd), =name(xb(xbd))
 ->     PROPERTIES name(xb), name(xbd), =name(xb(xbd))
[OK] //    PROPERTIES (xb) NEW, DELETE
 <-     PROPERTIES (xb) NEW, DELETE
 ->     PROPERTIES (xb) NEW, DELETE
[OK] //    PROPERTIES (xbd) NEW, DELETE
 <-     PROPERTIES (xbd) NEW, DELETE
 ->     PROPERTIES (xbd) NEW, DELETE
[OK] //
 <- 
 -> 
[OK] //    OBJECTS xc = XC
 <-     OBJECTS xc = XC
 ->     OBJECTS xc = XC
[OK] //    OBJECTS xcd = XCDetail
 <-     OBJECTS xcd = XCDetail
 ->     OBJECTS xcd = XCDetail
[OK] //    PROPERTIES name(xc), name(xcd), =name(xc(xcd))
 <-     PROPERTIES name(xc), name(xcd), =name(xc(xcd))
 ->     PROPERTIES name(xc), name(xcd), =name(xc(xcd))
[OK] //    PROPERTIES (xc) NEW, DELETE
 <-     PROPERTIES (xc) NEW, DELETE
 ->     PROPERTIES (xc) NEW, DELETE
[OK] //    PROPERTIES (xcd) NEW, DELETE
 <-     PROPERTIES (xcd) NEW, DELETE
 ->     PROPERTIES (xcd) NEW, DELETE
[OK] //;
 <- ;
 -> ;
[OK] //
 <- 
 -> 
[OK] //DESIGN testABAggr {
 <- DESIGN testABAggr {
 -> DESIGN testABAggr {
[OK] //    OBJECTS {
 <-     OBJECTS {
 ->     OBJECTS {
[OK] //        NEW common {
 <-         NEW common {
 ->         NEW common {
[OK] //            type = CONTAINERH;
 <-             type = CONTAINERH;
 ->             type = CONTAINERH;
[OK] //            fill = 1;
 <-             fill = 1;
 ->             fill = 1;
[OK] //            NEW leftp {
 <-             NEW leftp {
 ->             NEW leftp {
[OK] //                MOVE BOX(xa);
 <-                 MOVE BOX(xa);
 ->                 MOVE BOX(xa);
[OK] //                MOVE BOX(xad);
 <-                 MOVE BOX(xad);
 ->                 MOVE BOX(xad);
[OK] //                MOVE BOX(xadl);
 <-                 MOVE BOX(xadl);
 ->                 MOVE BOX(xadl);
[OK] //                fill = 1;
 <-                 fill = 1;
 ->                 fill = 1;
[OK] //            }
 <-             }
 ->             }
[OK] //            NEW rightp {
 <-             NEW rightp {
 ->             NEW rightp {
[OK] //                MOVE BOX(xb);
 <-                 MOVE BOX(xb);
 ->                 MOVE BOX(xb);
[OK] //                MOVE BOX(xbd);
 <-                 MOVE BOX(xbd);
 ->                 MOVE BOX(xbd);
[OK] //                fill = 1;
 <-                 fill = 1;
 ->                 fill = 1;
[OK] //            }
 <-             }
 ->             }
[OK] //            NEW rightc {
 <-             NEW rightc {
 ->             NEW rightc {
[OK] //                MOVE BOX(xc);
 <-                 MOVE BOX(xc);
 ->                 MOVE BOX(xc);
[OK] //                MOVE BOX(xcd);
 <-                 MOVE BOX(xcd);
 ->                 MOVE BOX(xcd);
[OK] //                fill = 1;
 <-                 fill = 1;
 ->                 fill = 1;
[OK] //            }
 <-             }
 ->             }
[OK] //        }    
 <-         }    
 ->         }    
[OK] //    }
 <-     }
 ->     }
[OK] //}
 <- }
 -> }
[OK]     htmlLinkInTab(HTMLLINK('https://luxsoft.by/'));
 <- luxsoft.by/'));
 -> luxsoft.by/'));
[OK] //    NEW FORM testABAggr BEFORE tst;
 <-     NEW FORM testABAggr BEFORE tst;
 ->     NEW FORM testABAggr BEFORE tst;
[OK]     EXTERNAL HTTP 'http://localhost:7651/exec?action=doSomething&p=$2&p=$1' PARAMS '1','2';
 <- localhost:7651/exec?action=doSomething&p=$2&p=$1' PARAMS '1','2';
 -> localhost:7651/exec?action=doSomething&p=$2&p=$1' PARAMS '1','2';
[OK] //    EXTERNAL HTTP 'https://en.wikipedia.org/wiki/File:Example.jpg' HEADERS headers[TEXT] COOKIES cookies[TEXT] HEADERSTO headersTo COOKIESTO cookiesTo;
 <-     EXTERNAL HTTP 'https://en.wikipedia.org/wiki/File:Example.jpg' HEADERS headers[TEXT] COOKIES cookies[TEXT] HEADERSTO headersTo COOKIESTO cookiesTo;
 ->     EXTERNAL HTTP 'https://en.wikipedia.org/wiki/File:Example.jpg' HEADERS headers[TEXT] COOKIES cookies[TEXT] HEADERSTO headersTo COOKIESTO cookiesTo;
[OK] GROUP shipment EXTID 'cacdo:DeclarationGoodsShipmentDetails';//: declaration;
 <- : declaration;
 -> : declaration;
crowdout/comment/tryonline/src/main/lsfusion (sources: crowdin/comment/tryonline/src/main/lsfusion) -> samples/tryonline/src/main/lsfusion - translated files:

In samples/tryonline/src/main/lsfusion/Main.lsf of Category comment - Number of lines: 243; Number of occurances: 12

[OK] dbPassword 'Пароль к базе' = DATA BPSTRING[50] () CHARWIDTH 10 NOFLEX; // for postgres user
 <-  for postgres user
 ->  for postgres user
[OK] serverStartCmd 'Команда запуска сервера' = DATA STRING[1000] (); // will be started from some basedir subfolder 
 <-  will be started from some basedir subfolder 
 ->  will be started from some basedir subfolder 
[OK] serverEncoding 'Кодировка консоли' = DATA BPSTRING[10] (); // server console output encoding
 <-  server console output encoding
 ->  server console output encoding
[OK] onStarted() + { // default for linux
 <-  default for linux
 ->  default for linux
[OK]         serverStartCmd() <- 'java -Dlsfusion.server.lightstart=true -Dlsfusion.server.devmode=true -cp .:../server.jar lsfusion.server.logics.BusinessLogicsBootstrap'; // windows : -> ; no double quotes in linux
 <-  windows : -> ; no double quotes in linux
 ->  windows : -> ; no double quotes in linux
[OK]         serverEncoding() <- 'UTF-8'; // for windows may be single-byte (for example cp1251)
 <-  for windows may be single-byte (for example cp1251)
 ->  for windows may be single-byte (for example cp1251)
[OK]     copy(baseDir() + '/log4j.xml', 'file://' + serverDir(server) + '/log4j.xml');
 <- ' + serverDir(server) + '/log4j.xml');
 -> ' + serverDir(server) + '/log4j.xml');
[OK]                   'rmi.port='+port()) TO 'file://' + confDir() + '/settings.properties';
 <- ' + confDir() + '/settings.properties';
 -> ' + confDir() + '/settings.properties';
[OK]     EXTERNAL SQL 'jdbc:postgresql://localhost/tryonline?user=postgres&password='+dbPassword() EXEC 'DROP DATABASE ' + dbName(server) + ';';
 <- localhost/tryonline?user=postgres&password='+dbPassword() EXEC 'DROP DATABASE ' + dbName(server) + ';';
 -> localhost/tryonline?user=postgres&password='+dbPassword() EXEC 'DROP DATABASE ' + dbName(server) + ';';
[OK]         WRITE RAWFILE(TEXTFILE('MODULE Main; ' + code)) TO 'file://' + serverDir(server) + '/Main.lsf';
 <- ' + serverDir(server) + '/Main.lsf';
 -> ' + serverDir(server) + '/Main.lsf';
[OK]     sleep(1000); // will wait a little bit to give process time to write all its text
 <-  will wait a little bit to give process time to write all its text
 ->  will wait a little bit to give process time to write all its text
[OK]                 // removing other tags from text
 <-  removing other tags from text
 ->  removing other tags from text

In samples/tryonline/src/main/lsfusion/tryonline/MapCalendar.lsf of Category comment - Number of lines: 64; Number of occurances: 1

[OK] polygon(Area a) <- '48.885488755596874 2.266616821289063,48.83941303819501 2.2714233398437504,48.81635927146624 2.338027954101563,48.823140892101684 2.4060058593750004,48.869683240775785 2.4183654785156254,48.90354608612111 2.355194091796875' WHEN SET (a IS Area); // minsk
 <-  minsk
 ->  minsk
crowdout/comment/betgame/src/main/lsfusion (sources: crowdin/comment/betgame/src/main/lsfusion) -> samples/betgame/src/main/lsfusion - translated files:

In samples/betgame/src/main/lsfusion/BetGame.lsf of Category comment - Number of lines: 149; Number of occurances: 1

[OK] // Расчет очков
 <-  Расчет очков
 ->  Points calculation
crowdout/strings/mm/src/main/lsfusion (sources: crowdin/strings/mm/src/main/lsfusion) -> samples/mm/src/main/lsfusion - translated files:

In samples/mm/src/main/lsfusion/Item.lsf of Category strings - Number of lines: 23; Number of occurances: 5

[OK] CLASS Item 'Товар';
 <- Товар
 -> Product
[OK] name 'Наименование' = DATA STRING[100](Item) IN base;
 <- Наименование
 -> Name
[OK] barcode 'Штрихкод' = DATA BPSTRING[13](Item) IN base;
 <- Штрихкод
 -> Barcode
[OK] salePrice 'Оптовая цена' = DATA NUMERIC[17,2](Item) IN base;
 <- Оптовая цена
 -> Wholesale price
[OK] FORM items 'Товары'
 <- Товары
 -> Products

In samples/mm/src/main/lsfusion/LegalEntity.lsf of Category strings - Number of lines: 24; Number of occurances: 5

[OK] CLASS LegalEntity 'Организация';
 <- Организация
 -> Organization
[OK] name 'Наименование' = DATA STRING[100](LegalEntity) IN base;
 <- Наименование
 -> Name
[OK] address 'Адрес' = DATA STRING[150](LegalEntity) IN base;
 <- Адрес
 -> Address
[OK] inn 'ИНН' = DATA BPSTRING[9](LegalEntity) IN base;
 <- ИНН
 -> TIN
[OK] FORM legalEntities 'Организации'
 <- Организации
 -> Organization

In samples/mm/src/main/lsfusion/Receipt.lsf of Category strings - Number of lines: 69; Number of occurances: 17

[OK] CLASS Receipt 'Приходная накладная';
 <- Приходная накладная
 -> Receipt
[OK] CLASS ReceiptDetail 'Строка приходной накладной';
 <- Строка приходной накладной
 -> Receipt line
[OK] receipt 'Документ строки' = DATA Receipt (ReceiptDetail) NONULL DELETE;
 <- Документ строки
 -> Line document
[OK] index 'Номер строки' (ReceiptDetail d) =
 <- Номер строки
 -> Line number
[OK] number 'Номер накладной' = DATA BPSTRING[10] (Receipt);
 <- Номер накладной
 -> Receipt number
[OK] date 'Дата накладной' = DATA DATE (Receipt);
 <- Дата накладной
 -> Receipt date
[OK] supplier 'Поставщик' = DATA LegalEntity (Receipt);
 <- Поставщик
 -> Supplier
[OK] nameSupplier 'Наименование поставщика' (Receipt r) = name(supplier(r));
 <- Наименование поставщика
 -> Supplier name
[OK] stock 'Склад' = DATA Stock (Receipt);
 <- Склад
 -> Warehouse
[OK] nameStock 'Наименование склада' (Receipt r) = name(stock(r));
 <- Наименование склада
 -> Warehouse name
[OK] item 'Товар' = DATA Item (ReceiptDetail);
 <- Товар
 -> Product
[OK] nameItem 'Наименование товара' (ReceiptDetail d) = name(item(d));
 <- Наименование товара
 -> Product name
[OK] quantity 'Количество' = DATA NUMERIC[16,4] (ReceiptDetail);
 <- Количество
 -> Quantity
[OK] price 'Цена поставщика' = DATA NUMERIC[17,2] (ReceiptDetail);
 <- Цена поставщика
 -> Supplier price
[OK] sum 'Сумма поставщика' (ReceiptDetail d) = quantity(d) * price(d);
 <- Сумма поставщика
 -> Supplier amount
[OK] FORM receipt 'Приходная накладная'
 <- Приходная накладная
 -> Receipt
[OK] FORM receipts 'Приходные накладные'
 <- Приходные накладные
 -> Receipts

In samples/mm/src/main/lsfusion/Shipment.lsf of Category strings - Number of lines: 68; Number of occurances: 17

[OK] CLASS Shipment 'Расходная накладная';
 <- Расходная накладная
 -> Shipment
[OK] CLASS ShipmentDetail 'Строка расходной накладной';
 <- Строка расходной накладной
 -> Shipment line
[OK] shipment 'Документ строки' = DATA Shipment (ShipmentDetail) NONULL DELETE;
 <- Документ строки
 -> Line document
[OK] index 'Номер строки' (ShipmentDetail d) =
 <- Номер строки
 -> Line number
[OK] number 'Номер накладной' = DATA BPSTRING[10] (Shipment);
 <- Номер накладной
 -> Shipment number
[OK] date 'Дата накладной' = DATA DATE (Shipment);
 <- Дата накладной
 -> Shipment date
[OK] customer 'Покупатель' = DATA LegalEntity (Shipment);
 <- Покупатель
 -> Customer
[OK] nameCustomer 'Наименование покупателя' (Shipment s) = name(customer(s));
 <- Наименование покупателя
 -> Customer name
[OK] stock 'Склад' = DATA Stock(Shipment);
 <- Склад
 -> Warehouse
[OK] nameStock 'Наименование склада' (Shipment s) = name(stock(s));
 <- Наименование склада
 -> Warehouse name
[OK] item 'Товар' = DATA Item (ShipmentDetail);
 <- Товар
 -> Product
[OK] nameItem 'Наименование товара' (ShipmentDetail d) = name(item(d));
 <- Наименование товара
 -> Product name
[OK] quantity 'Количество' = DATA NUMERIC[16,4](ShipmentDetail);
 <- Количество
 -> Quantity
[OK] price 'Цена продажи' = DATA NUMERIC[17,2](ShipmentDetail);
 <- Цена продажи
 -> Selling price
[OK] sum 'Сумма продажи' (ShipmentDetail d) = quantity(d) * price(d);
 <- Сумма продажи
 -> Sale amount
[OK] FORM shipment 'Расходная накладная'
 <- Расходная накладная
 -> Shipment
[OK] FORM shipments 'Расходные накладные'
 <- Расходные накладные
 -> Shipments

In samples/mm/src/main/lsfusion/Stock.lsf of Category strings - Number of lines: 19; Number of occurances: 4

[OK] CLASS Stock 'Склад';
 <- Склад
 -> Warehouse
[OK] name 'Наименование' = DATA STRING[100] (Stock) IN base;
 <- Наименование
 -> Name
[OK] address 'Адрес' = DATA STRING[150] (Stock) IN base;
 <- Адрес
 -> Address
[OK] FORM stocks 'Склады'
 <- Склады
 -> Warehouses

In samples/mm/src/main/lsfusion/StockAccounting.lsf of Category strings - Number of lines: 22; Number of occurances: 2

[OK]     NEW FOLDER masterData 'Справочники' FIRST WINDOW toolbar {
 <- Справочники
 -> Directories
[OK]     NEW FOLDER documents 'Документы' AFTER masterData WINDOW toolbar {
 <- Документы
 -> Documents

In samples/mm/src/main/lsfusion/StockItem.lsf of Category strings - Number of lines: 27; Number of occurances: 5

[OK] receivedQuantity 'Суммарный приход' = GROUP SUM quantity(ReceiptDetail d) BY item(d), stock(receipt(d));
 <- Суммарный приход
 -> Total income
[OK] shippedQuantity 'Суммарный расход' = GROUP SUM quantity(ShipmentDetail d) BY item(d), stock(shipment(d));
 <- Суммарный расход
 -> Total expenses
[OK] currentBalance 'Текущий остаток' (Item i, Stock s) = receivedQuantity (i, s) (-) shippedQuantity (i, s);
 <- Текущий остаток
 -> Current balance
[OK] CONSTRAINT currentBalance(Item i, Stock s) < 0 MESSAGE 'Остаток по товару не может быть отрицательным';
 <- Остаток по товару не может быть отрицательным
 -> The balance of the product cannot be negative
[OK] FORM currentBalanceItemStock 'Текущие остатки'
 <- Текущие остатки
 -> Current balances
crowdout/strings/mm/src/main/lsfusion/tryonline (sources: crowdin/strings/mm/src/main/lsfusion/tryonline) -> samples/mm/src/main/lsfusion/tryonline - translated files:

In samples/mm/src/main/lsfusion/tryonline/ExportItems.lsf of Category strings - Number of lines: 11; Number of occurances: 1

[OK]         	WHERE (name(i) LIKE '%а%' OR salePrice(i) > 10) 
 <- %а%
 -> %а%

In samples/mm/src/main/lsfusion/tryonline/ExportShipment.lsf of Category strings - Number of lines: 21; Number of occurances: 1

[OK]     EXPORT shipment OBJECTS s = (GROUP MAX Shipment s IF number(s) = '12345'); // exporting the shipment with the number 12345
 <- 12345
 -> 12345

In samples/mm/src/main/lsfusion/tryonline/FlowOperations.lsf of Category strings - Number of lines: 20; Number of occurances: 2

[OK]         exportString() <- GROUP CONCAT name(Item i) + ' -> ' + name(LegalEntity l) IF shippedTo(i, l),',\n'; // returning product/customer names separated by commas with newlines 
 <-  -> ' + name(LegalEntity l) IF shippedTo(i, l),',\n
 ->  -> ' + name(LegalEntity l) IF shippedTo(i, l),',\n
[OK]     	exportString() <- 'Слишком мало позиций'; 
 <- Слишком мало позиций
 -> Too few positions

In samples/mm/src/main/lsfusion/tryonline/HelloWorld.lsf of Category strings - Number of lines: 9; Number of occurances: 2

[OK]     exportString() <- 'Hello world!'; // export* properties are the default results of the HTTP request
 <- Hello world!
 -> Hello world!
[OK]     // EXPORT FROM 'Hello world!'; // exports to JSON by default and writes the result as JSONFILE to exportFile 
 <- Hello world!
 -> Hello world!

In samples/mm/src/main/lsfusion/tryonline/ImportShipments.lsf of Category strings - Number of lines: 34; Number of occurances: 6

[OK]     OBJECTS s=Shipment EXTID 'shipments' // using EXTID to keep the short name of the s object, but when exporting, shipments will be considered its name 
 <- shipments
 -> shipments
[OK]     OBJECTS sd=ShipmentDetail EXTID 'detail' // using EXTID to keep the short name of the sd object, but when exporting, detail will be considered its name
 <- detail
 -> detail
[OK]     FOR jsonFile = JSONFILE('\{ shipments : [ ' + // jsonFile must/can be passed in the run parameter, {} must be escaped since braces are used in internationalization
 <- \{ shipments : [ ' + // jsonFile должен / может передаваться в параметре run, {} надо escape
 -> \{ shipments : [ ' + // jsonFile must/can be passed in the run parameter, {} must be escaped
[OK]                 ' \{number : "13423", date : "01.01.2019", inn : "2", detail : [\{ barcode : "141", quantity : 5, price : 10 \}, \{ barcode : "545", quantity : 2, price : 11 \}] \},' + 
 <-  \{number : "13423", date : "01.01.2019", inn : "2", detail : [\{ barcode : "141", quantity : 5, price : 10 \}, \{ barcode : "545", quantity : 2, price : 11 \}] \},
 ->  \{number : "13423", date : "01.01.2019", inn : "2", detail : [\{ barcode : "141", quantity : 5, price : 10 \}, \{ barcode : "545", quantity : 2, price : 11 \}] \},
[OK]                 ' \{number : "12445", date : "01.02.2019", inn : "1", detail : [\{ barcode : "13", quantity : 1, price : 22 \}] \} ]\}')
 <-  \{number : "12445", date : "01.02.2019", inn : "1", detail : [\{ barcode : "13", quantity : 1, price : 22 \}] \} ]\}
 ->  \{number : "12445", date : "01.02.2019", inn : "1", detail : [\{ barcode : "13", quantity : 1, price : 22 \}] \} ]\}
[OK]         exportString() <- IF canceled() THEN applyMessage() ELSE 'Накладная записана успешно';
 <- Накладная записана успешно
 -> The shipment was written successfully

In samples/mm/src/main/lsfusion/tryonline/PrintShipment.lsf of Category strings - Number of lines: 20; Number of occurances: 2

[OK]     PROPERTIES sum 'Сумма' = (quantity(sd) * price(sd)) // printing quantity * price (named sum)    
 <- Сумма
 -> Amount
[OK]     PRINT shipment OBJECTS s = (GROUP MAX Shipment s IF number(s) = '12345') 
 <- 12345
 -> 12345

In samples/mm/src/main/lsfusion/tryonline/SessionOperations.lsf of Category strings - Number of lines: 26; Number of occurances: 2

[OK]     s() <- ''; 
 <- 
 -> 
[OK]             s() <- s() + number(s) + ' : ' + sum(s) + '\n'; // adding the shipment amount to the output (excluding the upper changes)  
 <-  : ' + sum(s) + '\n
 ->  : ' + sum(s) + '\n

In samples/mm/src/main/lsfusion/tryonline/SetOperations.lsf of Category strings - Number of lines: 13; Number of occurances: 1

[OK]     exportNumeric() <- topSum((GROUP MAX Shipment s IF number(s) = '12345'), 3); // displaying the first 3 records, the GROUP operator in a functional style
 <- 12345
 -> 12345
crowdout/strings/documentation/src (sources: crowdin/strings/documentation/src) -> samples/documentation/src - translated files:
crowdout/strings/documentation/src/main (sources: crowdin/strings/documentation/src/main) -> samples/documentation/src/main - translated files:
crowdout/strings/documentation/src/main/lsfusion (sources: crowdin/strings/documentation/src/main/lsfusion) -> samples/documentation/src/main/lsfusion - translated files:

In samples/documentation/src/main/lsfusion/ActionSample.lsf of Category strings - Number of lines: 850; Number of occurances: 101

[OK] showMessage  { MESSAGE 'Hello World!'; } 								// action declaration
 <- Hello World!
 -> Hello World!
[OK] loadImage 'Загрузить изображение'  ABSTRACT ( Item); 	
 <- Загрузить изображение
 -> Upload image
[OK] copy 'Копировать' (Order old)  { 
 <- Копировать
 -> Copy
[OK]     loadDefaultCurrency('USD', 866);
 <- USD
 -> USD
[OK]     loadDefaultCurrency('EUR', 1251);
 <- EUR
 -> EUR
[OK] exportXls 'Выгрузить в Excel'  ABSTRACT CASE ( Order);         // In this case, ABSTRACT CASE OVERRIDE LAST is created
 <- Выгрузить в Excel
 -> Export to Excel
[OK] exportXls (Order o) + WHEN name(currency(o)) == 'USD' THEN { 
 <- USD
 -> USD
[OK]     MESSAGE 'Export USD not implemented';
 <- Export USD not implemented
 -> Export USD not implemented
[OK] run 'Выполнить'  ABSTRACT ( Task);                           // ABSTRACT MULTI EXCLUSIVE
 <- Выполнить
 -> Execute
[OK]     MESSAGE 'Run Task1 ' + name(t);
 <- Run Task1 
 -> Run Task1 
[OK] FORM myForm 'Моя форма'
 <- Моя форма
 -> My form
[OK]             caption = 'Контакты';
 <- Контакты
 -> Contacts
[OK]             caption = 'Последние';
 <- Последние
 -> Recent
[OK] createReceiptDetail 'Добавить строку продажи'(STRING[30] barcode)  { 
 <- Добавить строку продажи
 -> Add sales line
[OK]     IF isActiveForm() THEN MESSAGE 'Example form is active';
 <- Example form is active
 -> Example form is active
[OK]         MESSAGE id(s); // shows '123'
 <- 123
 -> 123
[OK]     ASK 'Вы действительно хотите продолжать ?' DO {
 <- Вы действительно хотите продолжать ?
 -> Are you sure you want to continue?
[OK]         MESSAGE 'Вы продолжили';
 <- Вы продолжили
 -> You continued
[OK]     ASK 'Использовать старые значения ?' useOld = YESNO DO {
 <- Использовать старые значения ?
 -> Use old values?
[OK]             MESSAGE 'Используем старые значения';
 <- Используем старые значения
 -> Using old values
[OK]             MESSAGE 'Используем новые значения';
 <- Используем новые значения
 -> Using new values
[OK]         WHEN test(a) > 7 THEN MESSAGE '>7';
 <- >7
 -> >7
[OK]         WHEN test(a) > 6 THEN MESSAGE '>6';
 <- >6
 -> >6
[OK]         WHEN test(a) > 5 THEN MESSAGE '>5';
 <- >5
 -> >5
[OK] showOnMap 'Показать на карте'  INTERNAL  'lsfusion.server.logics.classes.data.utils.geo.ShowOnMapAction' (DOUBLE, DOUBLE, MapProvider, BPSTRING[100]);
 <- Показать на карте'  INTERNAL  'lsfusion.server.logics.classes.data.utils.geo.ShowOnMapAction
 -> Show on map' INTERNAL 'lsfusion.server.logics.classes.data.utils.geo.ShowOnMapAction
[OK] serviceDBMT 'Обслуживание БД (многопоточно, threadCount, timeout)'  INTERNAL  'lsfusion.server.physics.admin.service.action.ServiceDBMultiThreadAction' (INTEGER, INTEGER) NULL;
 <- Обслуживание БД (многопоточно, threadCount, timeout)'  INTERNAL  'lsfusion.server.physics.admin.service.action.ServiceDBMultiThreadAction
 -> DB maintenance (multithreaded, threadCount, timeout)' INTERNAL 'lsfusion.server.physics.admin.service.action.ServiceDBMultiThreadAction
[OK] printlnAction 'Вывести текст в консоль'  INTERNAL  <{ System.out.println("action test"); }>; 
 <- Вывести текст в консоль'  INTERNAL  <{ System.out.println("action test
 -> Print text to the console'  INTERNAL  <{System.out.println("action test
[OK]         MESSAGE 'Selected sku : ' + id(s);
 <- Selected sku : 
 -> Selected sku : 
[OK] emailUserPassUser 'Напоминание логина' (CustomUser user)  {
 <- Напоминание логина
 -> Login reminder
[OK]     SUBJECT 'Напоминание логина'
 <- Напоминание логина
 -> Login reminder
[OK] justSendEmail 'Отправить письмо' ()  { 
 <- Отправить письмо
 -> Send letter
[OK]     stringToFile('<font color=#FF0000 size=+3>big red text</font>');
 <- <font color=#FF0000 size=+3>big red text</font>
 -> <font color=#FF0000 size=+3>big red text</font>
[OK]     FROM 'luxsoft@adsl.by'
 <- luxsoft@adsl.by
 -> luxsoft@adsl.by
[OK]     SUBJECT 'Тема письма'
 <- Тема письма
 -> Letter subject
[OK]     TO 'xxx@tut.by'
 <- xxx@tut.by
 -> xxx@tut.by
[OK] addProperty  { EVAL ACTION 'MESSAGE \'Hello World\''; }  // source code consisting of one instruction is specified with a string constant
 <- MESSAGE \'Hello World\'
 -> MESSAGE \'Hello World\'
[OK] code 'Исходные код' = DATA BPSTRING[2000] ();              // a property to which the user can enter the source code
 <- Исходные код
 -> Source code
[OK] execute 'Выполнить код'  { EVAL code(); }      // the action executing this code
 <- Выполнить код
 -> Execute code
[OK]     MESSAGE 'Run import for ' + id(sku) + ' ' + customer(order);  
 <- Run import for ' + id(sku) + ' 
 -> Run import for ' + id(sku) + ' 
[OK]     EXPORT DBF CHARSET 'CP866' FROM id(Sku s), name(s), weight(s) WHERE in(store, s); // uploading to DBF all Sku for which in (Store, Sku) is specified for the desired warehouse 
 <- CP866
 -> CP866
[OK]     EXPORT FROM ff='HI'; // uploads JSON {"ff":"HI"}, as by default it gets the name value, and the platform automatically converts the object {"value":"HI"} to 
 <- HI'; // выгружает JSON {"ff":"HI"}, так как по умолчанию получает имя value, а платформа объект {"value":"HI
 -> HI'; // uploads JSON {"ff":"HI"}, as by default it gets the name value, and the platform gets the object {"value":"HI
[OK]     EXPORT FROM 'HI'; // uploads JSON "HI", as by default it gets the name value, and the platform automatically converts the object {"value": "HI"} to "HI"     
 <- HI'; // выгружает JSON "HI", так как по умолчанию получает имя value, а платформа объект {"value":"HI"} автоматически преобразует в "HI
 -> HI'; // uploads JSON "HI", as by default it gets the name value, and the platform automatically converts the object {"value": "HI"} to "HI
[OK]     EXPORT exportSku OBJECTS st = store DBF CHARSET 'CP866'; 
 <- CP866
 -> CP866
[OK]     EXPORT exportSku OBJECTS st = store CSV ','; 
 <- ,
 -> ,
[OK]     EXTERNAL HTTP GET 'https://www.cs.cmu.edu/~chuck/lennapg/len_std.jpg' TO exportFile; 
 <- https://www.cs.cmu.edu/~chuck/lennapg/len_std.jpg
 -> https://www.cs.cmu.edu/~chuck/lennapg/len_std.jpg
[OK]     EXTERNAL HTTP 'http://tryonline.lsfusion.org/exec?action=getExamples' PARAMS JSONFILE ('\{"mode"=1\}') TO exportFile; // braces are escaped as they are used in internationalization
 <- http://tryonline.lsfusion.org/exec?action=getExamples' PARAMS JSONFILE('\{"mode"=1\}') TO exportFile; // фигурные скобки escape
 -> http://tryonline.lsfusion.org/exec?action=getExamples' PARAMS JSONFILE('\{"mode"=1\}') TO exportFile; // braces are escaped
[OK]         MESSAGE 'Example : ' + caption + ', code : ' + code;
 <- Example : ' + caption + ', code : 
 -> Example : ' + caption + ', code : 
[OK]     EXTERNAL HTTP 'http://tryonline.lsfusion.org/exec?action=doSomething&someprm=$1' BODYURL 'otherprm=$2&andonemore=$3' PARAMS 1,2,'3'; // passes the second and third parameters to BODY url-encoded
 <- http://tryonline.lsfusion.org/exec?action=doSomething&someprm=$1' BODYURL 'otherprm=$2&andonemore=$3' PARAMS 1,2,'3
 -> http://tryonline.lsfusion.org/exec?action=doSomething&someprm=$1' BODYURL 'otherprm=$2&andonemore=$3' PARAMS 1,2,'3
[OK]     EXPORT TABLE FROM bc=barcode(Article a) WHERE name(a) LIKE '%Мясо%'; // getting all barcodes of products with the name meat
 <- %Мясо%
 -> %Meat%
[OK]     EXTERNAL SQL 'jdbc:mysql://$1/test?user=root&password=' EXEC 'select price AS pc, articles.barcode AS brc from $2 x JOIN articles ON x.bc=articles.barcode' PARAMS 'localhost',exportFile() TO exportFile; // reading prices for read barcodes
 <- jdbc:mysql://$1/test?user=root&password=' EXEC 'select price AS pc, articles.barcode AS brc from $2 x JOIN articles ON x.bc=articles.barcode' PARAMS 'localhost
 -> jdbc:mysql://$1/test?user=root&password=' EXEC 'select price AS pc, articles.barcode AS brc from $2 x JOIN articles ON x.bc=articles.barcode' PARAMS 'localhost
[OK]     EXTERNAL LSF 'http://localhost:7651' EXEC 'System.testAction[]'; 
 <- http://localhost:7651' EXEC 'System.testAction[]
 -> http://localhost:7651' EXEC 'System.testAction[]
[OK]         MESSAGE 'Sku ' + id(s) + ' was selected';
 <- Sku ' + id(s) + ' was selected
 -> Sku ' + id(s) + ' was selected
[OK]             MESSAGE 'There is Sku ' + id(s) + ' in store ' + name(st); 
 <- There is Sku ' + id(s) + ' in store 
 -> There is Sku ' + id(s) + ' in store 
[OK]         name(s) <- 'New Sku';
 <- New Sku
 -> New Sku
[OK]         MESSAGE '>3';
 <- >3
 -> >3
[OK]         MESSAGE '<=3';
 <- <=3
 -> <=3
[OK]         MESSAGE 'Name is null';
 <- Name is null
 -> Name is null
[OK]             MESSAGE 'field1 value = ' + field1(i);
 <- field1 value = 
 -> field1 value = 
[OK]             MESSAGE 'field2 value = ' + field2(i);
 <- field2 value = 
 -> field2 value = 
[OK]             MESSAGE 'field3 value = ' + field3(i);
 <- field3 value = 
 -> field3 value = 
[OK]             MESSAGE 'field4 value = ' + field4(i);
 <- field4 value = 
 -> field4 value = 
[OK]     EXTERNAL SQL 'jdbc:postgresql://localhost/test?user=postgres&password=12345' EXEC 'SELECT x.a,x.b,x.c,x.d FROM orders x WHERE x.id = $1;' PARAMS '4553' TO t;
 <- jdbc:postgresql://localhost/test?user=postgres&password=12345' EXEC 'SELECT x.a,x.b,x.c,x.d FROM orders x WHERE x.id = $1;' PARAMS '4553
 -> jdbc:postgresql://localhost/test?user=postgres&password=12345' EXEC 'SELECT x.a,x.b,x.c,x.d FROM orders x WHERE x.id = $1;' PARAMS '4553
[OK]         IMPORT CSV '*' HEADER CHARSET 'utf-8' FROM f TO field1 = C, field2, field3 = F, field4 = A;
 <- *' HEADER CHARSET 'utf-8
 -> *' HEADER CHARSET 'utf-8
[OK]         IMPORT XML ROOT 'element' ATTR FROM f TO field1, field2;      
 <- element
 -> element
[OK]             IMPORT DBF MEMO memo FROM f TO field1 = 'DBFField1', field2 = 'DBFField2';
 <- DBFField1', field2 = 'DBFField2
 -> DBFField1', field2 = 'DBFField2
[OK]             MESSAGE 'Customer changed to ' + s;
 <- Customer changed to 
 -> Customer changed to 
[OK]             MESSAGE 'Customer dropped';
 <- Customer dropped
 -> Customer dropped
[OK]         ASK 'Choose from list?' DO
 <- Choose from list?
 -> Choose from list?
[OK] message  { MESSAGE 'Hello World!'; }                                // plain text message
 <- Hello World!
 -> Hello World!
[OK]     MESSAGE IF isGood(i) THEN 'Good' ELSE 'Bad';   // depending on which item will be passed to the action, a window will be shown either with the text 'Good' or with the text 'Bad'
 <- Good' ELSE 'Bad';   // в зависимости от того, какой item будет передан действию, будет показываться окно с текстом 'Good', либо с текстом 'Bad
 -> Good' ELSE 'Bad';   // depending on which item will be passed to the action, a window will be shown either with the text 'Good' or with the text 'Bad
[OK] message (Square s)  { MESSAGE 'Square'; }
 <- Square
 -> Square
[OK] message (Circle c)  { MESSAGE 'Circle'; }
 <- Circle
 -> Circle
[OK]         name(s) <- 'New Sku';
 <- New Sku
 -> New Sku
[OK]         name(Sku s) <- 'aaa';
 <- aaa
 -> aaa
[OK]         APPLY; // in fact, the changes will not be applied to the database, but to the "upper" session
 <- верхнюю
 -> upper
[OK]     MESSAGE (GROUP SUM 1 IF name(Sku s) == 'aaa'); // returns all rows
 <- aaa
 -> aaa
[OK]     MESSAGE (GROUP SUM 1 IF name(Sku s) == 'aaa'); // returns NULL if there was no Sku named aaa in the database before
 <- aaa
 -> aaa
[OK]             // shows the form, but any changes in it will not be applied to the database, but will be saved in the "upper" session
 <- верхней сессии
 -> upper session
[OK]             name(c) <- 'USD';
 <- USD
 -> USD
[OK]     local(Currency c) <- 'Local';
 <- Local
 -> Local
[OK]         MESSAGE (GROUP SUM 1 IF local(Currency c) == 'Local'); // will return NULL
 <- Local
 -> Local
[OK]         MESSAGE (GROUP SUM 1 IF local(Currency c) == 'Local'); // will return the number of objects of class Currency
 <- Local
 -> Local
[OK]             name(s) <- 'New Sku';
 <- New Sku
 -> New Sku
[OK]     //Showing messages 'Message' to all
 <- Сообщение
 -> Message
[OK]         NEWTHREAD MESSAGE 'Сообщение'; CONNECTION conn;
 <- Сообщение
 -> Message
[OK]     NEWTHREAD MESSAGE 'Hello World'; SCHEDULE PERIOD 10000 DELAY 5000;
 <- Hello World
 -> Hello World
[OK]     sheetName() <- 'enctypted';
 <- enctypted
 -> encrypted
[OK]     PRINT printOrder OBJECTS o = o XLS SHEET sheetName PASSWORD 'pass';
 <- pass
 -> pass
[OK]     //PRINT printOrder OBJECTS o = o XLS SHEET 'enctypted' PASSWORD 'pass';
 <- enctypted' PASSWORD 'pass
 -> encrypted' PASSWORD 'pass
[OK]     READ 'ftp://ftp.lsfusion.org/file.xlsx' TO importFile;
 <- ftp://ftp.lsfusion.org/file.xlsx
 -> ftp://ftp.lsfusion.org/file.xlsx
[OK]     READ 'sftp://sftp.lsfusion.org/file.xlsx' TO importFile;
 <- sftp://sftp.lsfusion.org/file.xlsx
 -> sftp://sftp.lsfusion.org/file.xlsx
[OK]     READ 'D://lsfusion/file.xlsx' TO importFile;
 <- D://lsfusion/file.xlsx
 -> D://lsfusion/file.xlsx
[OK]     READ 'file://D://lsfusion/file.xlsx' TO importFile;
 <- file://D://lsfusion/file.xlsx
 -> file://D://lsfusion/file.xlsx
[OK] importXls 'Импортировать надбавки'()  { 
 <- Импортировать надбавки
 -> Import markups
[OK]     READ connectionString() + '@SELECT field1, field2 FROM myTable' TO importFile;
 <- @SELECT field1, field2 FROM myTable
 -> @SELECT field1, field2 FROM myTable
[OK]     lock 'Блокировка'
 <- Блокировка
 -> Blocking
[OK]             MESSAGE 'Lock Obtained';
 <- Lock Obtained
 -> Lock Obtained
[OK]         MESSAGE 'I have a date ' + dateCur();
 <- I have a date 
 -> I have a date 
[OK]         WRITE f TO 'file:///home/user/loadedfile.csv' APPEND;
 <- file:///home/user/loadedfile.csv
 -> file:///home/user/loadedfile.csv
[OK]         WRITE CLIENT f TO '/home/user/loadedfile.txt';
 <- /home/user/loadedfile.txt
 -> /home/user/loadedfile.txt
[OK]         WRITE CLIENT DIALOG f TO 'loadedfile';
 <- loadedfile
 -> loadedfile

In samples/documentation/src/main/lsfusion/AggregationSample.lsf of Category strings - Number of lines: 22; Number of occurances: 5

[OK] CLASS Shipment 'Поставка';
 <- Поставка
 -> Delivery
[OK] CLASS Invoice 'Инвойс';
 <- Инвойс
 -> Invoice
[OK] createShipment 'Создавать поставку' = DATA BOOLEAN (Invoice);
 <- Создавать поставку
 -> Create delivery
[OK] date 'Дата накладной' = DATA DATE (Invoice);
 <- Дата накладной
 -> Shipment date
[OK] CLASS ShipmentInvoice 'Поставка по инвойсу' : Shipment;
 <- Поставка по инвойсу
 -> Delivery by invoice

In samples/documentation/src/main/lsfusion/FormDesignSample.lsf of Category strings - Number of lines: 15; Number of occurances: 3

[OK] CLASS myClass 'myClass';
 <- myClass
 -> myClass
[OK] FORM myForm 'myForm'
 <- myForm
 -> myForm
[OK]         FILTER 'myFilter' myProperty1(myObject)
 <- myFilter
 -> myFilter

In samples/documentation/src/main/lsfusion/FormSample.lsf of Category strings - Number of lines: 429; Number of occurances: 27

[OK] FORM documents 'Документы'
 <- Документы
 -> Documents
[OK] FORM item 'Товар'
 <- Товар
 -> Product
[OK] FORM items 'Товары'
 <- Товары
 -> Products
[OK] FORM shipments 'Поставки'
 <- Поставки
 -> Deliveries
[OK] FORM revenues 'Обороты по товарам'
 <- Обороты по товарам
 -> Product turnovers
[OK]     OBJECTS interval = (dateFrom 'Дата (с)' = DATE, dateTo 'Дата (по)' = DATE) PANEL, // declaring a group of objects, consisting of 2 objects of the Date class with the appropriate captions, which will always be displayed as a panel
 <- Дата (с)' = DATE, dateTo 'Дата (по)
 -> Date (from)' = DATE, dateTo 'Date (to)
[OK] FORM skus 'Sku'
 <- Sku
 -> Sku
[OK] FORM order 'Заказ'
 <- Заказ
 -> Order
[OK] FORM orders 'Заказы'
 <- Заказы
 -> Orders
[OK] // creating a "report" in which orders for a certain interval will be visible in the context of customers in a particular region
 <- отчет
 -> report
[OK] FORM orderReport 'Продажи по складам'
 <- Продажи по складам
 -> Sales by warehouse
[OK]     OBJECTS interval = (dateFrom 'Дата (с)' = DATE, dateTo 'Дата (по)' = DATE) PANEL // declaring a group of objects, consisting of 2 objects of the Date class with the appropriate captions, which will always be displayed as a panel
 <- Дата (с)' = DATE, dateTo 'Дата (по)
 -> Date (from)' = DATE, dateTo 'Date (to)
[OK]                          // specifically not adding a single property so that it is "invisible", but it is needed in order to display customers in columns
 <- невидимым
 -> invisible
[OK] FORM onStock 'Остатки' // creating a form in which the balances of products can be viewed
 <- Остатки
 -> Balances
[OK]         FILTER 'Активные' active(st) 'F11' // adding filter for active warehouses only, which will be applied by pressing F11
 <- Активные' active(st) 'F11
 -> Active' active(st) 'F11
[OK]         FILTER 'Есть на остатках' onStock(st, s) 'F10' DEFAULT // adding a filter that will display only products on stock, which will be selected by pressing F10 and will be automatically selected when the form is opened
 <- Есть на остатках' onStock(st, s) 'F10
 -> Is on stock' onStock (st, s) 'F10
[OK]         FILTER 'Отрицательные остатки' onStock(st, s) < 0 'F9' // adding filter by expression
 <- Отрицательные остатки' onStock(st, s) < 0 'F9
 -> Negative balances' onStock (st, s) < 0 'F9
[OK] showImpossibleMessage()  { MESSAGE 'It\'s impossible'; };
 <- It\'s impossible
 -> It\'s impossible
[OK] FORM invoice 'Инвойс' // creating a form for editing an invoice
 <- Инвойс
 -> Invoice
[OK]         ON OK { posted(i) <- TRUE; }, // specifying that when the user clicks OK, an action should be executed that will execute actions to "post" this invoice
 <- проведению
 -> conduction
[OK] FORM POS 'POS' // declaring the form for product sale to the customer in the salesroom
 <- POS
 -> POS
[OK] printLabelFile (Item i)= OVERRIDE labelFile(i), 'MyModule_printLabel_i.jrxml' IF i IS Item;
 <- MyModule_printLabel_i.jrxml
 -> MyModule_printLabel_i.jrxml
[OK] FORM printLabel 'Печать ценника'
 <- Печать ценника
 -> Price tag printing
[OK]                         caption = 'Дата редактируемого заказа'; // "overriding" the property caption in the form design (instead of the standard one)
 <- Дата редактируемого заказа'; // "перегружаем
 -> Date of the edited order'; // "override
[OK]                         toolTip = 'Введите сюда дату, когда был сделан заказ'; //setting a hint for the order date property
 <- Введите сюда дату, когда был сделан заказ
 -> Input here the date the order was made
[OK]                 caption = 'Строки'; // setting the caption of the tab panel
 <- Строки
 -> Lines
[OK]                 caption = 'Подбор';
 <- Подбор
 -> Selection

In samples/documentation/src/main/lsfusion/GroupHierarchySample.lsf of Category strings - Number of lines: 20; Number of occurances: 1

[OK] FORM myForm 'myForm'
 <- myForm
 -> myForm

In samples/documentation/src/main/lsfusion/InstructionSample.lsf of Category strings - Number of lines: 317; Number of occurances: 45

[OK] GROUP base : root; // The caption of this group will be 'base'
 <- base
 -> base
[OK] GROUP local 'Локальные свойства'; // The parent group of local will be System.private
 <- Локальные свойства
 -> Local properties
[OK]         MESSAGE 'Changed ' + (GROUP SUM 1 IF changedName(Sku s)) + ' skus!!!'; 
 <- Changed ' + (GROUP SUM 1 IF changedName(Sku s)) + ' skus!!!
 -> Changed ' + (GROUP SUM 1 IF changedName(Sku s)) + ' skus!!!
[OK]     FOR CHANGED(customer(Order o)) AND name(customer(o)) == 'Best customer' DO
 <- Best customer
 -> Best customer
[OK]       EMAIL SUBJECT 'Остаток стал отрицательным по товару ' + name(s) + ' на складе ' + name(st);
 <- Остаток стал отрицательным по товару ' + name(s) + ' на складе 
 -> The balance has become negative for the item ' + name(s) + ' in the warehouse 
[OK] WHEN LOCAL CHANGED(customer(Order o)) AND name(customer(o)) == 'Best customer' DO
 <- Best customer
 -> Best customer
[OK]     MESSAGE 'Остаток не может быть отрицательным для ' + (GROUP CONCAT 'Товар : ' + name(Sku ss) + ' Склад : ' + name(Stock sst), '\n' IF SET(balance(ss, sst) < 0));
 <- Остаток не может быть отрицательным для ' + (GROUP CONCAT 'Товар : ' + name(Sku ss) + ' Склад : ' + name(Stock sst), '\n
 -> The balance cannot be negative for ' + (GROUP CONCAT 'Product: ' + name(Sku ss) + ' Warehouse: ' + name(Stock sst), '\n
[OK] // "emulating" security policy
 <- эмуляция
 -> emulation
[OK] CONSTRAINT DROPCHANGED(barcode(Sku s)) AND name(currentUser()) != 'admin' MESSAGE 'Изменять штрих-код для уже созданного товара разрешено только администратору';
 <- admin' MESSAGE 'Изменять штрих-код для уже созданного товара разрешено только администратору
 -> admin' MESSAGE 'Only the administrator is allowed to change the barcode for an already created product
[OK]     MESSAGE 'В заказе выбран недоступный пользователю товар для выбранного покупателя';
 <- В заказе выбран недоступный пользователю товар для выбранного покупателя
 -> In the order, a product unavailable to the user is selected for the selected customer
[OK] CLASS ABSTRACT Document; // The caption of this class will be 'Document'
 <- Document
 -> Document
[OK] CLASS IncomeDocument 'Приход' : Document;
 <- Приход
 -> Income
[OK] CLASS OutcomeDocument 'Расход' : Document;
 <- Расход
 -> Expenses
[OK] CLASS Barcode 'Штрих-код'; // The parent class of Barcode will be the System.Object class
 <- Штрих-код
 -> Barcode
[OK]     portrait 'Книжная',
 <- Книжная
 -> Portrait
[OK]     landscape 'Альбомная'
 <- Альбомная
 -> Landscape
[OK] hello()  { MESSAGE 'Hello world'; }
 <- Hello world
 -> Hello world
[OK] hi()  { MESSAGE 'Hi'; }
 <- Hi
 -> Hi
[OK]     NEW FOLDER catalogs 'Справочники' WINDOW toolbar { // creating a new navigator folder and making all its descendants appear in a window with a vertical toolbar
 <- Справочники
 -> Directories
[OK]         NEW FORM stocksNavigator 'Склады' = stocks; // creating a stocksNavigator form element for the stocks form and adding the last element to the catalogs folder
 <- Склады
 -> Warehouses
[OK]     NEW FOLDER documents 'Документы' WINDOW toolbar { // creating another folder, the elements of which will also be displayed in a window with a vertical toolbar
 <- Документы
 -> Documents
[OK] WINDOW root 'Корень' TOOLBAR HIDETITLE HIDESCROLLBARS HORIZONTAL POSITION(0, 0, 100, 6);
 <- Корень
 -> Root
[OK] WINDOW toolbar 'Тулбар' TOOLBAR HIDETITLE VERTICAL POSITION(0, 6, 20, 64);
 <- Тулбар
 -> Toolbar
[OK] WINDOW tree 'Дерево' TOOLBAR HIDETITLE POSITION(0, 6, 20, 64);
 <- Дерево
 -> Tree
[OK] 	point 'Точка',
 <- Точка
 -> Dot
[OK] 	segment 'Отрезок'
 <- Отрезок
 -> Line segment
[OK] 	circle 'Окружность'
 <- Окружность
 -> Circle
[OK] name(BClass b) = 'B' + innerName(b);
 <- B
 -> B
[OK] name(CClass c) = 'C' + innerName(c);
 <- C
 -> C
[OK] name(DClass d) += 'DClass' + innerName(d) IF d IS DClass;
 <- DClass
 -> DClass
[OK] whoAmI (Dog d) + {  MESSAGE 'I am a dog!'; }
 <- I am a dog!
 -> I am a dog!
[OK] whoAmI (Cat c) + {  MESSAGE 'I am a сat!'; }
 <- I am a сat!
 -> I am a сat!
[OK]     name(Sku s) <- '1';
 <- 1
 -> 1
[OK]     name(Sku s) <- '2';
 <- 2
 -> 2
[OK] testName (Human h) + WHEN name(h) == 'John' THEN {  MESSAGE 'I am John'; } 
 <- John' THEN {  MESSAGE 'I am John
 -> John' THEN {  MESSAGE 'I am John
[OK] testName (Human h) + WHEN name(h) == 'Bob' THEN {  MESSAGE 'I am Bob'; } 
 <- Bob' THEN {  MESSAGE 'I am Bob
 -> Bob' THEN {  MESSAGE 'I am Bob
[OK]     object##Name 'Имя'##caption = DATA BPSTRING[100](###object); // capitalizing the first letter
 <- Имя
 -> Name
[OK]     object##Type 'Тип'##caption = DATA type (###object);
 <- Тип
 -> Type
[OK]     object##Value 'Стоимость'##caption = DATA INTEGER (###object);
 <- Стоимость
 -> Cost
[OK]     @objectProperties(object, type, '');
 <- 
 -> 
[OK] @objectProperties(book, INTEGER, 'Книга');
 <- Книга
 -> Book
[OK] BEFORE changeName(Sku s, STRING[100] name) DO MESSAGE 'Changing user name'; // The message will be shown before each call to changeName
 <- Changing user name
 -> Changing user name
[OK] AFTER changePrice(Sku s, DATE d, NUMERIC[10,2] price) DO MESSAGE 'Price was changed'; // A message will be shown after each call to changePrice
 <- Price was changed
 -> Price was changed
[OK]     yes 'Да',
 <- Да
 -> Yes
[OK]     no 'Нет'
 <- Нет
 -> No

In samples/documentation/src/main/lsfusion/MetaSample.lsf of Category strings - Number of lines: 32; Number of occurances: 4

[OK]     object##Name 'Имя '##caption = DATA BPSTRING[100](object);
 <- Имя 
 -> Name 
[OK]     object##Type 'Тип '##caption = DATA Type (object);
 <- Тип 
 -> Type 
[OK]     object##Value 'Стоимость '##caption = DATA INTEGER (object);
 <- Стоимость 
 -> Cost 
[OK] @objectProperties(Document, 'документа');
 <- документа
 -> of the document

In samples/documentation/src/main/lsfusion/MetaSampleResult.lsf of Category strings - Number of lines: 25; Number of occurances: 3

[OK] DocumentName 'Имя документа' = DATA BPSTRING[100](Document);
 <- Имя документа
 -> Document name
[OK] DocumentType 'Тип документа' = DATA Type (Document);
 <- Тип документа
 -> Document type
[OK] DocumentValue 'Стоимость документа' = DATA INTEGER (Document);
 <- Стоимость документа
 -> Document cost

In samples/documentation/src/main/lsfusion/ModuleSample.lsf of Category strings - Number of lines: 9; Number of occurances: 2

[OK] CLASS Employee 'Сотрудник';	// Creating a class
 <- Сотрудник
 -> Employee
[OK] CLASS Position 'Должность'; // Creating another class
 <- Должность
 -> Position

In samples/documentation/src/main/lsfusion/OperatorPropertySample.lsf of Category strings - Number of lines: 371; Number of occurances: 34

[OK] backgroundSku 'Цвет' (d) = ABSTRACT CASE FULL COLOR (InvoiceDetail); // In this case, ABSTRACT CASE OVERRIDE LAST is created, and if there are
 <- Цвет
 -> Color
[OK] FORM tabbedForm 'Форма с табами'
 <- Форма с табами
 -> Tabbed form
[OK]             caption = 'Контакты';
 <- Контакты
 -> Contacts
[OK]             caption = 'Последние';
 <- Последние
 -> Recent
[OK] //If the 'Recent' tab is active
 <- Последние
 -> Recent
[OK] background 'Цвет' (Color c) = CASE
 <- Цвет
 -> Color
[OK]     WHEN id(c) == 'Black' THEN RGB(0,0,0)
 <- Black
 -> Black
[OK]     WHEN id(c) == 'Red' THEN RGB(255,0,0)
 <- Red
 -> Red
[OK]     WHEN id(c) == 'Green' THEN RGB(0,255,0)
 <- Green
 -> Green
[OK] fullName(Person p) = CONCAT ' ', firstName(p), middleName(p), lastName(p);     // if some part of the name is not specified, then this part will be skipped along with a space
 <-  
 ->  
[OK] background 'Цвет' (INTEGER i) = EXCLUSIVE RGB(255,238,165) IF i <= 5,
 <- Цвет
 -> Color
[OK] name(Human h) = EXCLUSIVE 'Male' IF h IS Male, 'Female' IF h IS Female;
 <- Male' IF h IS Male, 'Female
 -> Male' IF h IS Male, 'Female
[OK] round(number, digits) = FORMULA 'round(CAST(($1) as numeric),$2)';  // a property with two parameters: a rounded number and the number of decimal places
 <- round(CAST(($1) as numeric),$2)
 -> round(CAST(($1) as numeric),$2)
[OK] toString15(str) = FORMULA BPSTRING[15] 'CAST($1 AS character(15))';   // a property that converts the value passed as an argument to a 15-character string. 
 <- CAST($1 AS character(15))
 -> CAST($1 AS character(15))
[OK] jumpWorkdays = FORMULA NULL DATE PG 'jumpWorkdays($1, $2, $3)', MS 'dbo.jumpWorkdays($1, $2, $3)'; // a property with two different implementations for different SQL dialects
 <- jumpWorkdays($1, $2, $3)', MS 'dbo.jumpWorkdays($1, $2, $3)
 -> jumpWorkdays($1, $2, $3)', MS 'dbo.jumpWorkdays($1, $2, $3)
[OK] tags(Book b) = GROUP CONCAT name(Tag t) IF in(b, t), ', ' ORDER name(t), t;
 <- , 
 -> , 
[OK] sex (Human h) = IF h IS Male THEN 'Male' ELSE ('Female' IF h IS Female); // if h is of another class, it will be NULL
 <- Male' ELSE ('Female
 -> Male' ELSE ('Female
[OK] formatted(INTEGER a, INTEGER b) = [FORMULA BPSTRING[255] ' CAST($1 AS TEXT) || \' / \' || CAST($2 AS TEXT)'](count(a), name(b));
 <-  CAST($1 AS TEXT) || \' / \' || CAST($2 AS TEXT)
 ->  CAST($1 AS TEXT) || \' / \' || CAST($2 AS TEXT)
[OK] outcome 'Остаток (неотрицательный)' (Item i) = MAX balance(i), 0;
 <- Остаток (неотрицательный)
 -> Balance (non-negative)
[OK] nameMulti (Human h) = MULTI 'Male' IF h IS Male, 'Female' IF h IS Female;
 <- Male' IF h IS Male, 'Female
 -> Male' IF h IS Male, 'Female
[OK] place 'Место' (Team team) = PARTITION SUM 1 ORDER DESC points(team), gamesWon(team) BY conference(team);
 <- Место
 -> Place
[OK] index 'Номер' (Object o) = PARTITION SUM 1 IF o IS Object ORDER o;
 <- Номер
 -> Number
[OK] transportSum 'Транспортные расходы' = DATA NUMERIC[10,2] (Order);
 <- Транспортные расходы
 -> Freight costs
[OK] transportSum 'Транспортные расходы по строке' (OrderDetail d) = PARTITION UNGROUP transportSum
 <- Транспортные расходы по строке
 -> Freight costs by line
[OK] discountSum 'Скидка' = DATA NUMERIC[10,2] (Order);
 <- Скидка
 -> Discount
[OK] discountSum 'Скидка по строке' (OrderDetail d) =
 <- Скидка по строке
 -> Discount by line
[OK]         MESSAGE 'In this session f(a) changed from ' + PREV(f(a)) + ' TO ' + f(a);
 <- In this session f(a) changed from ' + PREV(f(a)) + ' TO 
 -> In this session f(a) changed from ' + PREV(f(a)) + ' TO 
[OK] pathes 'Кол-во путей' (a, b) = RECURSION 1 AND a IS Node AND b==a STEP 1 IF edge(b, $b);
 <- Кол-во путей
 -> Number of paths
[OK] level 'Уровень' (Group child, Group parent) = RECURSION 1 IF child IS Group AND parent == child
 <- Уровень
 -> Level
[OK] stringStruct() = STRUCT(1, 'two', 3.0);
 <- two
 -> two
[OK] countF 'Кол-во фильтр. складов' = GROUP SUM 1 IF [ VIEW stores.s](Store s);
 <- Кол-во фильтр. складов
 -> Number of filtered warehouses
[OK] orderF 'Порядок в группе объектов' (Store s) = PARTITION SUM 1 IF [ FILTER stores.s](s) ORDER [ ORDER stores.s](s), s;
 <- Порядок в группе объектов
 -> Order in an object group
[OK] setNameX 'Добавить X к имени'()  { 
 <- Добавить X к имени
 -> Add X to name
[OK]         name(s) <- 'X' + k() + name(s);
 <- X
 -> X

In samples/documentation/src/main/lsfusion/PropertySample.lsf of Category strings - Number of lines: 56; Number of occurances: 5

[OK] cost 'Стоимость' (i) = DATA NUMERIC[12,3] (Item);		// property defined by the context-independent DATA property operator
 <- Стоимость
 -> Cost
[OK] weightedSum 'Взвешенная сумма' (a, b) = 2*a + 3*b; 		// property defined by expression 
 <- Взвешенная сумма
 -> Weighted amount
[OK] diff = a - b; 											// the caption of this property will be 'diff' and the parameters will be (a, b)
 <- diff
 -> diff
[OK] teamName 'Название команды' = DATA BPSTRING[30](Team) IN baseGroup TABLE team; // property defined by DATA operator with additional property options
 <- Название команды
 -> Team name
[OK] age 'Возраст' = DATA INTEGER (Man);
 <- Возраст
 -> Age

In samples/documentation/src/main/lsfusion/StaticObjectSample.lsf of Category strings - Number of lines: 25; Number of occurances: 6

[OK] CLASS Direction 'Направление'
 <- Направление
 -> Direction
[OK]     north 'Север',
 <- Север
 -> North
[OK]     east 'Восток',
 <- Восток
 -> East
[OK]     south 'Юг',
 <- Юг
 -> South
[OK]     west 'Запад'   
 <- Запад
 -> West
[OK] FORM directions 'Направления'
 <- Направления
 -> Directions

In samples/documentation/src/main/lsfusion/UseCaseActionBook.lsf of Category strings - Number of lines: 9; Number of occurances: 1

[OK] overCopy  ABSTRACT ( Book, Book); // abstract action that takes an input two books and is "a point of input", to which other modules can add realization
 <- точкой входа
 -> entry point

In samples/documentation/src/main/lsfusion/UseCaseActionShape.lsf of Category strings - Number of lines: 24; Number of occurances: 2

[OK]         MESSAGE 'I am a rectangle';
 <- I am a rectangle
 -> I am a rectangle
[OK]         MESSAGE 'I am a circle';
 <- I am a circle
 -> I am a circle

In samples/documentation/src/main/lsfusion/UseCaseAssign.lsf of Category strings - Number of lines: 61; Number of occurances: 16

[OK] CLASS Order 'Заказ';
 <- Заказ
 -> Order
[OK] CLASS Customer 'Покупатель';
 <- Покупатель
 -> Customer
[OK] date 'Дата' = DATA DATE (Order);
 <- Дата
 -> Date
[OK] customer 'Покупатель' = DATA Customer (Order);
 <- Покупатель
 -> Customer
[OK] nameCustomer 'Покупатель' (Order o) = name(customer(o));
 <- Покупатель
 -> Customer
[OK] discount 'Скидка, %' = DATA NUMERIC[5,2] (Order);
 <- Скидка, %
 -> Discount, %
[OK] setDateDiscount 'Применить скидку (поздняя поставка)' (Order o)  { 
 <- Применить скидку (поздняя поставка)
 -> Apply discount (late delivery)
[OK] CLASS Book 'Книга';
 <- Книга
 -> Book
[OK] name 'Наименование' = DATA ISTRING[50] (Book);
 <- Наименование
 -> Name
[OK] price 'Текущая цена' (Book b) = DATA NUMERIC[14,2] (Book);
 <- Текущая цена
 -> Current price
[OK] CLASS OrderDetail 'Строка заказа';
 <- Строка заказа
 -> Order line
[OK] order 'Заказ' = DATA Order (OrderDetail) NONULL DELETE;
 <- Заказ
 -> Order
[OK] book 'Книга' = DATA Book (OrderDetail);
 <- Книга
 -> Book
[OK] nameBook 'Книга' (OrderDetail d) = name(book(d));
 <- Книга
 -> Book
[OK] price 'Цена' = DATA NUMERIC[14,2] (OrderDetail);
 <- Цена
 -> Price
[OK] fillPrice 'Установить текущие цены' (Order o)  { 
 <- Установить текущие цены
 -> Set current prices

In samples/documentation/src/main/lsfusion/UseCaseCIO.lsf of Category strings - Number of lines: 84; Number of occurances: 31

[OK] CLASS Color 'Цвет' {
 <- Цвет
 -> Color
[OK]     white 'Белый',
 <- Белый
 -> White
[OK]     black 'Черный'
 <- Черный
 -> Black
[OK] CLASS Book 'Книга';
 <- Книга
 -> Book
[OK] color 'Цвет' = DATA Color (Book);
 <- Цвет
 -> Color
[OK] nameColor1 'Цвет' (Book b) = staticCaption(color(b));
 <- Цвет
 -> Color
[OK] nameColor2 'Цвет' (Book b) = IF color(b) == Color.white THEN 'Белый' ELSE 'Черный';
 <- Цвет' (Book b) = IF color(b) == Color.white THEN 'Белый' ELSE 'Черный
 -> Color' (Book b) = IF color(b) == Color.white THEN 'White' ELSE 'Black
[OK] CLASS Order 'Заказ';
 <- Заказ
 -> Order
[OK] sent 'Отправлен' = DATA BOOLEAN (Order);
 <- Отправлен
 -> Sent
[OK] agreed 'Согласован' = DATA BOOLEAN (Order);
 <- Согласован
 -> Agreed
[OK] accepted 'Принят' = DATA BOOLEAN (Order);
 <- Принят
 -> Accepted
[OK] nameStatus1 'Статус' (Order o) = CASE WHEN accepted(o) THEN 'Принят'
 <- Статус' (Order o) = CASE WHEN accepted(o) THEN 'Принят
 -> Status' (Order o) = CASE WHEN accepted(o) THEN 'Accepted
[OK]                                      WHEN agreed(o) THEN 'Согласован'
 <- Согласован
 -> Agreed
[OK]                                      WHEN sent(o) THEN 'Отправлен'
 <- Отправлен
 -> Sent
[OK]                                 ELSE 'Новый';
 <- Новый
 -> New
[OK] CLASS Status 'Статус' {
 <- Статус
 -> Status
[OK]     new 'Новый',
 <- Новый
 -> New
[OK]     sent 'Отправлен',
 <- Отправлен
 -> Sent
[OK]     agreed 'Согласован',
 <- Согласован
 -> Agreed
[OK]     accepted 'Принят'
 <- Принят
 -> Accepted
[OK] status 'Статус' (Order o) = CASE WHEN accepted(o) THEN Status.accepted
 <- Статус
 -> Status
[OK] nameStatus2 'Статус' (Order o) = staticCaption(status(o));
 <- Статус
 -> Status
[OK] dataMarkup 'Надбавка, %' = DATA NUMERIC[6,2] (Book);
 <- Надбавка, %
 -> Markup, %
[OK] defaultMarkup 'Надбавка по умолчанию' = DATA NUMERIC[6,2] ();
 <- Надбавка по умолчанию
 -> Default markup
[OK] markup1 'Надбавка, %' (Book b) = OVERRIDE dataMarkup(b), defaultMarkup();
 <- Надбавка, %
 -> Markup, %
[OK] markup2 'Надбавка, %' (Book b) = IF dataMarkup(b) THEN dataMarkup(b) ELSE defaultMarkup();
 <- Надбавка, %
 -> Markup, %
[OK] CLASS Category 'Категория';
 <- Категория
 -> Category
[OK] category 'Категория' = DATA Category (Book);
 <- Категория
 -> Category
[OK] markup 'Надбавка, %' = DATA NUMERIC[6,2] (Category);
 <- Надбавка, %
 -> Markup, %
[OK] markup 'Надбавка, %' (Book b) = OVERRIDE dataMarkup(b), markup(category(b));
 <- Надбавка, %
 -> Markup, %
[OK] number 'Номер' = DATA INTEGER (Book);
 <- Номер
 -> Number

In samples/documentation/src/main/lsfusion/UseCaseClassMyModule.lsf of Category strings - Number of lines: 16; Number of occurances: 1

[OK] EXTEND CLASS MyClass : MySuperClass; // inheriting MyClass from MySuperClass, while MyClass will "receive" all the properties that are declared for the MySuperClass class
 <- получит
 -> will receive

In samples/documentation/src/main/lsfusion/UseCaseColumns.lsf of Category strings - Number of lines: 80; Number of occurances: 19

[OK] CLASS Book 'Книга';
 <- Книга
 -> Book
[OK] name 'Наименование' = DATA ISTRING[50] (Book) IN id;
 <- Наименование
 -> Name
[OK] CLASS Customer 'Покупатель';
 <- Покупатель
 -> Customer
[OK] name 'Наименование' = DATA ISTRING[50] (Customer) IN id;
 <- Наименование
 -> Name
[OK] price 'Цена' = DATA NUMERIC[14,2] (Book, Customer);
 <- Цена
 -> Price
[OK] FORM prices 'Цены'
 <- Цены
 -> Prices
[OK] gracePeriod 'Отсрочка, дней' = DATA INTEGER (Book, Customer); 
 <- Отсрочка, дней
 -> Delay, days
[OK] selected 'Отм' = DATA BOOLEAN (Customer);
 <- Отм
 -> Mark
[OK] headerName 'Заголовок цены' (Customer c) = name(c) + ': Цена';
 <- Заголовок цены' (Customer c) = name(c) + ': Цена
 -> Price header' (Customer c) = name(c) + ': Price
[OK] headerGrace 'Заголовок отсрочки' (Customer c) = name(c) + ': Отсрочка, дней';
 <- Заголовок отсрочки' (Customer c) = name(c) + ': Отсрочка, дней
 -> Dealy header' (Customer c) = name(c) + ': Delay, days
[OK] FORM pricesAndGracePeriods 'Цены и отсрочки'
 <- Цены и отсрочки
 -> Prices and delays
[OK]                price(b, c) COLUMNS 'priceAndGrace' (c) HEADER headerName(c), 
 <- priceAndGrace
 -> priceAndGrace
[OK]                gracePeriod(b, c) COLUMNS 'priceAndGrace' (c) HEADER headerGrace(c)
 <- priceAndGrace
 -> priceAndGrace
[OK] in 'Вкл' = DATA BOOLEAN (INTEGER, INTEGER);
 <- Вкл
 -> On
[OK] row 'Заголовок ряда' (INTEGER r) = 'Ряд ' + (r AS INTEGER);
 <- Заголовок ряда' (INTEGER r) = 'Ряд 
 -> Row header' (INTEGER r) = 'Row 
[OK] column 'Заголовок колонки' (INTEGER c) = 'Колонка ' + (c AS INTEGER);
 <- Заголовок колонки' (INTEGER c) = 'Колонка 
 -> Column header' (INTEGER c) = 'Column 
[OK] FORM matrix 'Матрица'
 <- Матрица
 -> Matrix
[OK]     PROPERTY(rs) { caption = 'Кол-во рядов'; }
 <- Кол-во рядов
 -> Number of rows
[OK]     PROPERTY(cs) { caption = 'Кол-во колонок'; }
 <- Кол-во колонок
 -> Number of columns

In samples/documentation/src/main/lsfusion/UseCaseConcat.lsf of Category strings - Number of lines: 29; Number of occurances: 12

[OK] CLASS Book 'Книга';
 <- Книга
 -> Book
[OK] CLASS Tag 'Тэг';
 <- Тэг
 -> Tag
[OK] name 'Наименование' = DATA ISTRING[10] (Tag);
 <- Наименование
 -> Name
[OK] in 'Вкл' = DATA BOOLEAN (Tag, Book);
 <- Вкл
 -> On
[OK] tags 'Тэги' (Book b) = GROUP CONCAT name(Tag t) IF in(t, b), ',' ORDER name(t), t CHARWIDTH 10;
 <- Тэги' (Book b) = GROUP CONCAT name(Tag t) IF in(t, b), ',
 -> Tags' (Book b) = GROUP CONCAT name(Tag t) IF in(t, b), ',
[OK] CLASS Category 'Категория';
 <- Категория
 -> Category
[OK] CLASS Author 'Автор';
 <- Автор
 -> Author
[OK] name 'Автор' = DATA ISTRING[20] (Author);
 <- Автор
 -> Author
[OK] category 'Категория' = DATA Category (Book);
 <- Категория
 -> Category
[OK] author 'Автор' = DATA Author (Book);
 <- Автор
 -> Author
[OK] countBooks 'Кол-во книг' (Author a, Category c) = GROUP SUM 1 BY author(Book b), category(b);
 <- Кол-во книг
 -> Number of books
[OK] authors 'Авторы' (Category c) = GROUP CONCAT name(Author a) IF countBooks(a, c) ORDER DESC countBooks(a, c), a;
 <- Авторы
 -> Authors

In samples/documentation/src/main/lsfusion/UseCaseConstraint.lsf of Category strings - Number of lines: 82; Number of occurances: 25

[OK] CLASS Book 'Книга';
 <- Книга
 -> Book
[OK] name 'Наименование' = DATA ISTRING[50] (Book) IN id;
 <- Наименование
 -> Name
[OK] price 'Цена' = DATA NUMERIC[14,2] (Book);
 <- Цена
 -> Price
[OK]     MESSAGE 'Цена книги не может быть больше 100 рублей';
 <- Цена книги не может быть больше 100 рублей
 -> The book price cannot be more than 100 rubles
[OK]     MESSAGE 'Цена книги не может быть больше 100 рублей';
 <- Цена книги не может быть больше 100 рублей
 -> The book price cannot be more than 100 rubles
[OK] CLASS Order 'Заказ';
 <- Заказ
 -> Order
[OK] date 'Дата' = DATA DATE (Order) IN id;
 <- Дата
 -> Date
[OK] number 'Номер' = DATA INTEGER (Order) IN id;
 <- Номер
 -> Number
[OK] posted 'Проведен' = DATA BOOLEAN (Order) IN id; 
 <- Проведен
 -> Completed
[OK]     MESSAGE 'Запрещено менять дату у проведенного заказа'; 
 <- Запрещено менять дату у проведенного заказа
 -> It is forbidden to change the date of a completed order
[OK]     MESSAGE 'Запрещено удалять старые заказы';
 <- Запрещено удалять старые заказы
 -> It is forbidden to delete old orders
[OK] CLASS OrderDetail 'Строка заказа';
 <- Строка заказа
 -> Order line
[OK] order 'Заказ' = DATA Order (OrderDetail) NONULL DELETE;
 <- Заказ
 -> Order
[OK] book 'Книга' = DATA Book (OrderDetail) NONULL;
 <- Книга
 -> Book
[OK] nameBook 'Книга' (OrderDetail d) = name(book(d)) IN id;
 <- Книга
 -> Book
[OK] price 'Цена' = DATA NUMERIC[14,2] (OrderDetail);
 <- Цена
 -> Price
[OK]     MESSAGE 'Цена в заказе не может превышать цену книги на 10%';
 <- Цена в заказе не может превышать цену книги на 10%
 -> The price in the order cannot exceed the price of the book by 10%
[OK] CLASS Customer 'Покупатель';
 <- Покупатель
 -> Customer
[OK] name 'Имя' = DATA ISTRING[100] (Customer);
 <- Имя
 -> Name
[OK] in 'Вкл' = DATA BOOLEAN (Customer, Book);
 <- Вкл
 -> On
[OK] customer 'Покупатель' = DATA Customer (OrderDetail);
 <- Покупатель
 -> Customer
[OK]     MESSAGE 'В строке заказа выбрана книга, которая не разрешена для покупателя';
 <- В строке заказа выбрана книга, которая не разрешена для покупателя
 -> A book is selected in the order line that is not allowed for the customer
[OK]            MESSAGE 'Цена в заказе не может превышать цену книги на 10%';
 <- Цена в заказе не может превышать цену книги на 10%
 -> The price in the order cannot exceed the price of the book by 10%
[OK]     MESSAGE 'В строке заказа выбрана книга, которая не разрешена для покупателя по строкам : \n' + 
 <- В строке заказа выбрана книга, которая не разрешена для покупателя по строкам : \n
 -> A book is selected in the order line that is not allowed for the customer by lines: \n
[OK]             (GROUP CONCAT ('Дата ' + date(order(OrderDetail d)) + '; Номер ' + number(order(d))) IF constraintBook(d), ',') NOWAIT;
 <- Дата ' + date(order(OrderDetail d)) + '; Номер ' + number(order(d))) IF constraintBook(d), ',
 -> Date ' + date(order(OrderDetail d)) + '; Number ' + number(order(d))) IF constraintBook(d), ',

In samples/documentation/src/main/lsfusion/UseCaseCreate.lsf of Category strings - Number of lines: 137; Number of occurances: 29

[OK] CLASS Book 'Книга';
 <- Книга
 -> Book
[OK] name 'Наименование' = DATA ISTRING[50] (Book) IN id;
 <- Наименование
 -> Name
[OK] price 'Цена' = DATA NUMERIC[14,2] (Book); 
 <- Цена
 -> Price
[OK] FORM book 'Книга'
 <- Книга
 -> Book
[OK] FORM books 'Книги'
 <- Книги
 -> Books
[OK] copy 'Копировать' (Book book)  { 
 <- Копировать
 -> Copy
[OK] CLASS Order 'Заказ';
 <- Заказ
 -> Order
[OK] date 'Дата' = DATA DATE (Order);
 <- Дата
 -> Date
[OK] number 'Номер' = DATA INTEGER (Order);
 <- Номер
 -> Number
[OK] CLASS OrderDetail 'Строка заказа';
 <- Строка заказа
 -> Order line
[OK] order 'Заказ' = DATA Order (OrderDetail) NONULL DELETE;
 <- Заказ
 -> Order
[OK] book 'Книга' = DATA Book (OrderDetail) NONULL;
 <- Книга
 -> Book
[OK] nameBook 'Книга' (OrderDetail d) = name(book(d));
 <- Книга
 -> Book
[OK] quantity 'Количество' = DATA INTEGER (OrderDetail);
 <- Количество
 -> Quantity
[OK] price 'Цена' = DATA NUMERIC[14,2] (OrderDetail);
 <- Цена
 -> Price
[OK] FORM order 'Заказ'
 <- Заказ
 -> Order
[OK] FORM orders 'Заказы'
 <- Заказы
 -> Orders
[OK] CLASS Invoice 'Счет';
 <- Счет
 -> Invoice
[OK] date 'Дата' = DATA DATE (Invoice);
 <- Дата
 -> Date
[OK] number 'Номер' = DATA INTEGER (Invoice);
 <- Номер
 -> Number
[OK] CLASS InvoiceDetail 'Строка счета';
 <- Строка счета
 -> Invoice line
[OK] invoice 'Счет' = DATA Invoice (InvoiceDetail) NONULL DELETE;
 <- Счет
 -> Invoice
[OK] book 'Книга' = DATA Book (InvoiceDetail) NONULL;
 <- Книга
 -> Book
[OK] nameBook 'Книга' (InvoiceDetail d) = name(book(d));
 <- Книга
 -> Book
[OK] quantity 'Количество' = DATA INTEGER (InvoiceDetail);
 <- Количество
 -> Quantity
[OK] price 'Цена' = DATA NUMERIC[14,2] (InvoiceDetail);
 <- Цена
 -> Price
[OK] FORM invoice 'Счет'
 <- Счет
 -> Invoice
[OK] createInvoice 'Создать счет' (Order o)  { 
 <- Создать счет
 -> Create invoice
[OK] fillOrder 'Заполнить по заказу' (Invoice i)  { 
 <- Заполнить по заказу
 -> Fill in by order

In samples/documentation/src/main/lsfusion/UseCaseCRUD.lsf of Category strings - Number of lines: 76; Number of occurances: 15

[OK] CLASS Type 'Тип' {
 <- Тип
 -> Type
[OK]     novel 'Роман',
 <- Роман
 -> Novel
[OK]     thriller 'Триллер',
 <- Триллер
 -> Thriller
[OK]     fiction 'Фантастика'
 <- Фантастика
 -> Fiction
[OK] name 'Наименование' (Type g) = staticCaption(g) IF g IS Type;
 <- Наименование
 -> Name
[OK] FORM types 'Список типов'
 <- Список типов
 -> List of types
[OK] CLASS Book 'Книга';
 <- Книга
 -> Book
[OK] name 'Наименование' = DATA ISTRING[30] (Book) IN id;
 <- Наименование
 -> Name
[OK] FORM book 'Книга' // form for displaying the book card
 <- Книга' // форма для отображения "карточки
 -> Book' // form for displaying "card
[OK] FORM books 'Книги'
 <- Книги
 -> Books
[OK] CLASS Genre 'Жанр';
 <- Жанр
 -> Genre
[OK] name 'Наименование' = DATA ISTRING[30] (Genre);
 <- Наименование
 -> Name
[OK] FORM genre 'Жанр'
 <- Жанр
 -> Genre
[OK] FORM genres 'Жанры'
 <- Жанры
 -> Genres
[OK] FORM dialogGenre 'Жанры'
 <- Жанры
 -> Genres

In samples/documentation/src/main/lsfusion/UseCaseDBModel.lsf of Category strings - Number of lines: 24; Number of occurances: 6

[OK] CLASS Animal 'Животное';
 <- Животное
 -> Animal
[OK] name 'Наименование' = DATA STRING[50] (Animal);
 <- Наименование
 -> Name
[OK] CLASS Country 'Страна';
 <- Страна
 -> Country
[OK] population 'Численность' = DATA INTEGER (Animal, Country);
 <- Численность
 -> Number
[OK] averageAge 'Средний возраст' = DATA NUMERIC[8,2] (Animal, Country) TABLE ageAnimalCountry;
 <- Средний возраст
 -> Average age
[OK] totalPopulation 'Общая численность' (Animal a) = GROUP SUM population(a, Country c) MATERIALIZED;
 <- Общая численность
 -> Total number

In samples/documentation/src/main/lsfusion/UseCaseDelete.lsf of Category strings - Number of lines: 34; Number of occurances: 8

[OK] CLASS Order 'Заказ';
 <- Заказ
 -> Order
[OK] CLASS Book 'Книга';
 <- Книга
 -> Book
[OK] name 'Наименование' = DATA ISTRING[50] (Book);
 <- Наименование
 -> Name
[OK] CLASS OrderDetail 'Строка заказа';
 <- Строка заказа
 -> Order line
[OK] order 'Заказ' = DATA Order (OrderDetail) NONULL DELETE;
 <- Заказ
 -> Order
[OK] book 'Книга' = DATA Book (OrderDetail);
 <- Книга
 -> Book
[OK] nameBook 'Книга' (OrderDetail d) = name(book(d));
 <- Книга
 -> Book
[OK]         MESSAGE 'Запрещено удалять книгу, так как по ней есть заказ';
 <- Запрещено удалять книгу, так как по ней есть заказ
 -> It is forbidden to delete a book, as there is an order for it

In samples/documentation/src/main/lsfusion/UseCaseDependentProperties.lsf of Category strings - Number of lines: 60; Number of occurances: 13

[OK] CLASS Country 'Страна';
 <- Страна
 -> Country
[OK] name 'Имя' = DATA ISTRING[100] (Country) IN id;
 <- Имя
 -> Name
[OK] CLASS Region 'Регион';
 <- Регион
 -> Region
[OK] name 'Имя' = DATA ISTRING[100] (Region) IN id;
 <- Имя
 -> Name
[OK] country 'Страна' = DATA Country (Region) NONULL DELETE;
 <- Страна
 -> Country
[OK] nameCountry 'Страна' (Region r)= name(country(r)) IN id;
 <- Страна
 -> Country
[OK] CLASS City 'Город';
 <- Город
 -> City
[OK] name 'Имя' = DATA ISTRING[100] (City);
 <- Имя
 -> Name
[OK] country 'Страна' = DATA Country (City) NONULL DELETE;
 <- Страна
 -> Country
[OK] region 'Регион' = DATA Region (City);
 <- Регион
 -> Region
[OK] FORM cities 'Города'
 <- Города
 -> Cities
[OK] CONSTRAINT country(City c) != country(region(c)) CHECKED BY region[City] MESSAGE 'Страна региона города должна совпадать со страной города';
 <- Страна региона города должна совпадать со страной города
 -> The country of the city region must match the country of the city
[OK] CONSTRAINT region(City c) AND NOT country(c) = country(region(c)) CHECKED BY region[City] MESSAGE 'Страна региона города должна совпадать со страной города';
 <- Страна региона города должна совпадать со страной города
 -> The country of the city region must match the country of the city

In samples/documentation/src/main/lsfusion/UseCaseDesign.lsf of Category strings - Number of lines: 108; Number of occurances: 28

[OK] CLASS Book 'Книга';
 <- Книга
 -> Book
[OK] name 'Наименование' = DATA ISTRING[100] (Book);
 <- Наименование
 -> Name
[OK] CLASS Order 'Заказ';
 <- Заказ
 -> Order
[OK] date 'Дата' = DATA DATE (Order);
 <- Дата
 -> Date
[OK] number 'Номер' = DATA INTEGER (Order);
 <- Номер
 -> Number
[OK] CLASS OrderDetail 'Строка заказа';
 <- Строка заказа
 -> Order line
[OK] order 'Заказ' = DATA Order (OrderDetail) NONULL DELETE;
 <- Заказ
 -> Order
[OK] book 'Книга' = DATA Book (OrderDetail) NONULL;
 <- Книга
 -> Book
[OK] nameBook 'Книга' (OrderDetail d) = name(book(d));
 <- Книга
 -> Book
[OK] quantity 'Количество' = DATA INTEGER (OrderDetail);
 <- Количество
 -> Quantity
[OK] price 'Цена' = DATA NUMERIC[14,2] (OrderDetail);
 <- Цена
 -> Price
[OK] CLASS Payment 'Оплата';
 <- Оплата
 -> Payment
[OK] order 'Заказ' = DATA Order (Payment) NONULL DELETE;
 <- Заказ
 -> Order
[OK] date 'Дата' = DATA DATE (Payment);
 <- Дата
 -> Date
[OK] sum 'Сумма' = DATA NUMERIC[14,2] (Payment);
 <- Сумма
 -> Amount
[OK] FORM orders 'Заказы'
 <- Заказы
 -> Orders
[OK]         fill = 1; // marking that this container should "stretch" in the upper container
 <- растягиваться
 -> stretch
[OK]                 caption = 'Состав заказа';
 <- Состав заказа
 -> Order content
[OK]                 caption = 'Проведенные оплаты';
 <- Проведенные оплаты
 -> Payments made
[OK] CLASS Customer 'Покупатель';
 <- Покупатель
 -> Customer
[OK] name 'Наименование' = DATA ISTRING[100] (Customer);
 <- Наименование
 -> Name
[OK] customer 'Покупатель' = DATA Customer (Order);
 <- Покупатель
 -> Customer
[OK] nameCustomer 'Покупатель' (Order o) = name(customer(o));
 <- Покупатель
 -> Customer
[OK] nameFilterCustomer 'Покупатель' = name(filterCustomer());
 <- Покупатель
 -> Customer
[OK]             fill = 1; // it is necessary to make it "stretch" inside the orderList, as it will have a list of orders 
 <- растягивался
 -> stretched
[OK]                 caption = 'Фильтры';
 <- Фильтры
 -> Filters
[OK]                     caption = 'Дата с';
 <- Дата с
 -> Date from
[OK]                     caption = 'Дата по';
 <- Дата по
 -> Date to

In samples/documentation/src/main/lsfusion/UseCaseDocument.lsf of Category strings - Number of lines: 216; Number of occurances: 44

[OK] CLASS Book 'Книга';
 <- Книга
 -> Book
[OK] name 'Наименование' = DATA ISTRING[100] (Book) IN id;
 <- Наименование
 -> Name
[OK] CLASS Order 'Заказ';
 <- Заказ
 -> Order
[OK] date 'Дата' = DATA DATE (Order);
 <- Дата
 -> Date
[OK] number 'Номер' = DATA STRING[10] (Order);
 <- Номер
 -> Number
[OK] CLASS OrderDetail 'Строка заказа';
 <- Строка заказа
 -> Order line
[OK] order 'Заказ' = DATA Order (OrderDetail) NONULL DELETE;
 <- Заказ
 -> Order
[OK] book 'Книга' = DATA Book (OrderDetail) NONULL;
 <- Книга
 -> Book
[OK] nameBook 'Книга' (OrderDetail d) = name(book(d));
 <- Книга
 -> Book
[OK] quantity 'Количество' = DATA INTEGER (OrderDetail);
 <- Количество
 -> Quantity
[OK] price 'Цена' = DATA NUMERIC[14,2] (OrderDetail);
 <- Цена
 -> Price
[OK] FORM order 'Заказ'
 <- Заказ
 -> Order
[OK] FORM orders 'Заказы'
 <- Заказы
 -> Orders
[OK] posted 'Проведен' = DATA BOOLEAN (Order);
 <- Проведен
 -> Completed
[OK] reserved 'Зарезервировано' (Book b) = GROUP SUM quantity(OrderDetail d) IF posted(order(d)) BY book(d);
 <- Зарезервировано
 -> Reserved
[OK] post 'Провести' (Order o)  { posted(o) <- TRUE; }
 <- Провести
 -> Complete
[OK]         caption = 'Провести';
 <- Провести
 -> Complete
[OK] quantity 'Кол-во' (Order o, Book b) = GROUP SUM quantity(OrderDetail d) BY order(d), book(d);
 <- Кол-во
 -> Qty
[OK] lastOrderDetail 'Последняя строка' (Order o, Book b) = GROUP LAST OrderDetail d ORDER d BY order(d), book(d);
 <- Последняя строка
 -> Last line
[OK] changeQuantity 'Изменить кол-во' (Order o, Book b)  { 
 <- Изменить кол-во
 -> Change quantity
[OK]                 caption = 'Подбор';
 <- Подбор
 -> Selection
[OK] CLASS ABSTRACT Invoice 'Счет';
 <- Счет
 -> Invoice
[OK] date 'Дата' = ABSTRACT DATE (Invoice);
 <- Дата
 -> Date
[OK] number 'Номер' = ABSTRACT STRING[10] (Invoice);
 <- Номер
 -> Number
[OK] CLASS ABSTRACT InvoiceDetail 'Строка счета';
 <- Строка счета
 -> Invoice line
[OK] invoice 'Счет' = ABSTRACT Invoice (InvoiceDetail);
 <- Счет
 -> Invoice
[OK] book 'Книга' = ABSTRACT Book (InvoiceDetail);
 <- Книга
 -> Book
[OK] quantity 'Количество' = ABSTRACT INTEGER (InvoiceDetail);
 <- Количество
 -> Quantity
[OK] price 'Цена' = ABSTRACT NUMERIC[14,2] (InvoiceDetail);
 <- Цена
 -> Price
[OK] FORM invoices 'Счета'
 <- Счета
 -> Invoices
[OK] CLASS UserInvoice 'Пользовательский счет' : Invoice;
 <- Пользовательский счет
 -> Custom invoice
[OK] date 'Дата' = DATA DATE (UserInvoice);
 <- Дата
 -> Date
[OK] number 'Номер' = DATA STRING[10] (UserInvoice);
 <- Номер
 -> Number
[OK] CLASS UserInvoiceDetail 'Строка пользовательского счета' : InvoiceDetail;
 <- Строка пользовательского счета
 -> Custom invoice line
[OK] userInvoice 'Пользовательский счет' = DATA UserInvoice (UserInvoiceDetail); 
 <- Пользовательский счет
 -> Custom invoice
[OK] book 'Книга' = DATA Book (UserInvoiceDetail);
 <- Книга
 -> Book
[OK] nameBook 'Книга' (UserInvoiceDetail d) = name(book(d));
 <- Книга
 -> Book
[OK] quantity 'Количество' = DATA INTEGER (UserInvoiceDetail);
 <- Количество
 -> Quantity
[OK] price 'Цена' = DATA NUMERIC[14,2] (UserInvoiceDetail);
 <- Цена
 -> Price
[OK] FORM userInvoice 'Счет (пользовательский)'
 <- Счет (пользовательский)
 -> Invoice (custom)
[OK] createInvoice 'Создать счет' = DATA BOOLEAN (Order);
 <- Создать счет
 -> Create invoice
[OK] CLASS OrderInvoice 'Счет на основе заказа' : Invoice; 
 <- Счет на основе заказа
 -> Invoice based on order
[OK] createInvoiceDetail 'Создать строку счета' (OrderDetail d) = createInvoice(order(d));
 <- Создать строку счета
 -> Create invoice line
[OK] CLASS OrderInvoiceDetail 'Строка счета на основе заказа' : InvoiceDetail;
 <- Строка счета на основе заказа
 -> Invoice line based on order

In samples/documentation/src/main/lsfusion/UseCaseEvents.lsf of Category strings - Number of lines: 79; Number of occurances: 19

[OK] CLASS Order 'Заказ';
 <- Заказ
 -> Order
[OK] isClosed 'Закрыт' = DATA BOOLEAN (Order);
 <- Закрыт
 -> Closed
[OK] date 'Дата' = DATA DATE (Order);
 <- Дата
 -> Date
[OK] number 'Номер' = DATA INTEGER (Order);
 <- Номер
 -> Number
[OK] CLASS OrderDetail 'Строка заказа';
 <- Строка заказа
 -> Order line
[OK] order 'Заказ' = DATA Order (OrderDetail) NONULL DELETE;
 <- Заказ
 -> Order
[OK] quantity 'Кол-во' = DATA NUMERIC[15,3] (OrderDetail);
 <- Кол-во
 -> Qty
[OK] price 'Цена' = DATA NUMERIC[14,2] (OrderDetail);
 <- Цена
 -> Price
[OK] sum 'Сумма' = DATA NUMERIC[16,2] (OrderDetail);
 <- Сумма
 -> Amount
[OK] CLASS Book 'Книга';
 <- Книга
 -> Book
[OK] name 'Наименование' = DATA ISTRING[50] (Book);
 <- Наименование
 -> Name
[OK] price 'Цена' = DATA NUMERIC[14,2] (Book);
 <- Цена
 -> Price
[OK] book 'Книга' = DATA Book (OrderDetail);
 <- Книга
 -> Book
[OK] nameBook 'Книга' (OrderDetail d) = name(book(d));
 <- Книга
 -> Book
[OK] CLASS OrderLog 'Лог удаления заказа';
 <- Лог удаления заказа
 -> Order deletion log
[OK] date 'Дата заказа' = DATA DATE (OrderLog);
 <- Дата заказа
 -> Order date
[OK] number 'Номер заказа' = DATA INTEGER (OrderLog);
 <- Номер заказа
 -> Order number
[OK] dateTime 'Дата' = DATA DATETIME (OrderLog);
 <- Дата
 -> Date
[OK] user 'Пользователь' = DATA User (OrderLog);
 <- Пользователь
 -> User

In samples/documentation/src/main/lsfusion/UseCaseExec.lsf of Category strings - Number of lines: 43; Number of occurances: 10

[OK] CLASS Category 'Категория';
 <- Категория
 -> Category
[OK] name 'Наименование' = DATA ISTRING[50] (Category);
 <- Наименование
 -> Name
[OK] id 'Код' = DATA INTEGER (Category);
 <- Код
 -> Code
[OK] saleDate 'Дата начала продаж' = DATA DATE (Category);
 <- Дата начала продаж
 -> Sales start date
[OK] createCategory 'Создать категорию' (ISTRING[50] name, INTEGER id, DATE saleDate)  { 
 <- Создать категорию
 -> Create category
[OK] create3Categories 'Создать 3 категории' ()  { 
 <- Создать 3 категории
 -> Create 3 categories
[OK]     createCategory('Категория 1', 1, 2010_02_14);
 <- Категория 1
 -> Category 1
[OK]     createCategory('Категория 2', 2, 2011_03_08);
 <- Категория 2
 -> Category 2
[OK]     createCategory('Категория 3', 3, 2014_07_01);
 <- Категория 3
 -> Category 3
[OK] parent 'Родитель' = DATA Category (Category); // if the value is NULL, then there is no parent
 <- Родитель
 -> Parent

In samples/documentation/src/main/lsfusion/UseCaseExport.lsf of Category strings - Number of lines: 125; Number of occurances: 30

[OK] CLASS Book 'Книга';
 <- Книга
 -> Book
[OK] name 'Наименование' = DATA ISTRING[100] (Book) IN id;
 <- Наименование
 -> Name
[OK] CLASS Customer 'Покупатель';
 <- Покупатель
 -> Customer
[OK] name 'Наименование' = DATA ISTRING[50] (Customer) IN id;
 <- Наименование
 -> Name
[OK] address 'Адрес' = DATA ISTRING[50] (Customer) IN base;
 <- Адрес
 -> Address
[OK] CLASS Currency 'Валюта';
 <- Валюта
 -> Currency
[OK] name 'Наименование' = DATA ISTRING[50] (Currency) IN id;  
 <- Наименование
 -> Name
[OK] CLASS Order 'Заказ';
 <- Заказ
 -> Order
[OK] date 'Дата' = DATA DATE (Order);
 <- Дата
 -> Date
[OK] number 'Номер' = DATA STRING[10] (Order);
 <- Номер
 -> Number
[OK] customer 'Покупатель' = DATA Customer (Order);
 <- Покупатель
 -> Customer
[OK] nameCustomer 'Покупатель' (Order o) = name(customer(o));
 <- Покупатель
 -> Customer
[OK] CLASS OrderDetail 'Строка заказа';
 <- Строка заказа
 -> Order line
[OK] order 'Заказ' = DATA Order (OrderDetail) NONULL DELETE;
 <- Заказ
 -> Order
[OK] book 'Книга' = DATA Book (OrderDetail) NONULL;
 <- Книга
 -> Book
[OK] nameBook 'Книга' (OrderDetail d) = name(book(d));
 <- Книга
 -> Book
[OK] quantity 'Количество' = DATA INTEGER (OrderDetail);
 <- Количество
 -> Quantity
[OK] price 'Цена' = DATA NUMERIC[14,2] (OrderDetail);
 <- Цена
 -> Price
[OK] currency 'Валюта' = DATA Currency (OrderDetail);
 <- Валюта
 -> Currency
[OK] nameCurrency 'Валюта' (OrderDetail d) = name(currency(d)); 
 <- Валюта
 -> Currency
[OK] FORM order 'Заказ'
 <- Заказ
 -> Order
[OK] FORM orders 'Заказы'
 <- Заказы
 -> Orders
[OK]     PROPERTIES IN Customer nameCustomer(order) EXTID 'name', =address(customer(order)) EXTID 'address'
 <- name', =address(customer(order)) EXTID 'address
 -> name', =address(customer(order)) EXTID 'address
[OK]                        nameCurrency IN price EXTID 'currency' ATTR, price IN price EXTID 'value'
 <- currency' ATTR, price IN price EXTID 'value
 -> currency' ATTR, price IN price EXTID 'value
[OK] exportToXML 'Экспорт в XML' (Order o) {
 <- Экспорт в XML
 -> Export to XML
[OK] exportToJSON 'Экспорт в JSON' (Order o) {
 <- Экспорт в JSON
 -> Export to JSON
[OK]     WRITE CLIENT DIALOG file() TO 'orders';
 <- orders
 -> orders
[OK] FORM exportParameters 'Параметры'
 <- Параметры
 -> Parameters
[OK]     PROPERTIES(d) 'Дата' = VALUE
 <- Дата
 -> Date
[OK] exportToCSV 'Экспорт в CSV' () {
 <- Экспорт в CSV
 -> Export to CSV

In samples/documentation/src/main/lsfusion/UseCaseExternal.lsf of Category strings - Number of lines: 229; Number of occurances: 32

[OK] CLASS Country 'Страна';
 <- Страна
 -> Country
[OK] id 'Код' = DATA STRING[20] (Country) IN id;
 <- Код
 -> Code
[OK] name 'Имя' = DATA ISTRING[100] (Country) IN id;
 <- Имя
 -> Name
[OK] CLASS City 'Город';
 <- Город
 -> City
[OK] name 'Имя' = DATA ISTRING[100] (City) IN id;
 <- Имя
 -> Name
[OK] country 'Страна' = DATA Country (City);
 <- Страна
 -> Country
[OK] nameCountry 'Страна' (City c) = name(country(c));
 <- Страна
 -> Country
[OK] FORM cities 'Города'
 <- Города
 -> Cities
[OK] postCity 'Отправить' (City c)  { 
 <- Отправить
 -> Send
[OK]     EXTERNAL HTTP 'http://localhost=7651/exec?action=Location.importOrderNew' PARAMS exportFile() TO result;
 <- http://localhost:7651/exec?action=Location.createCity
 -> http://localhost:7651/exec?action=Location.createCity
[OK]     IF NOT code() == '0' THEN {
 <- 0
 -> 0
[OK]         MESSAGE 'Ошибка: ' + message();
 <- Ошибка: 
 -> Error: 
[OK]         EXPORT JSON FROM code = '1', message = 'Некорректный код страны';
 <- 1', message = 'Некорректный код страны
 -> 1', message = 'Invalid country code
[OK]     EXPORT JSON FROM code = '0', message = 'OK';
 <- 0', message = 'OK
 -> 0', message = 'OK
[OK] CLASS Book 'Книга';
 <- Книга
 -> Book
[OK] id 'Код' = DATA STRING[10] (Book) IN id;
 <- Код
 -> Code
[OK] name 'Наименование' = DATA ISTRING[100] (Book) IN id;
 <- Наименование
 -> Name
[OK] CLASS Order 'Заказ';
 <- Заказ
 -> Order
[OK] date 'Дата' = DATA DATE (Order);
 <- Дата
 -> Date
[OK] number 'Номер' = DATA STRING[10] (Order);
 <- Номер
 -> Number
[OK] CLASS OrderDetail 'Строка заказа';
 <- Строка заказа
 -> Order line
[OK] order 'Заказ' = DATA Order (OrderDetail) NONULL DELETE;
 <- Заказ
 -> Order
[OK] book 'Книга' = DATA Book (OrderDetail) NONULL;
 <- Книга
 -> Book
[OK] nameBook 'Книга' (OrderDetail d) = name(book(d));
 <- Книга
 -> Book
[OK] quantity 'Количество' = DATA INTEGER (OrderDetail);
 <- Количество
 -> Quantity
[OK] price 'Цена' = DATA NUMERIC[14,2] (OrderDetail);
 <- Цена
 -> Price
[OK] FORM order 'Заказ'
 <- Заказ
 -> Order
[OK] FORM orders 'Заказы'
 <- Заказы
 -> Orders
[OK] exportOrder 'Отправить' (Order o)  { 
 <- Отправить
 -> Send
[OK]     EXTERNAL HTTP 'http://localhost:7651/exec?action=Location.importOrder' PARAMS exportFile() TO result;
 <- http://localhost:7651/exec?action=Location.importOrder
 -> http://localhost:7651/exec?action=Location.importOrder
[OK] exportOrderNew 'Отправить (новый)' (Order o)  { 
 <- Отправить (новый)
 -> Send (new)
[OK]     EXTERNAL HTTP 'http://localhost:7651/exec?action=Location.importOrderNew' PARAMS exportFile() TO result;
 <- http://localhost:7651/exec?action=Location.importOrderNew
 -> http://localhost:7651/exec?action=Location.importOrderNew

In samples/documentation/src/main/lsfusion/UseCaseFilter.lsf of Category strings - Number of lines: 76; Number of occurances: 20

[OK] CLASS Book 'Книга';
 <- Книга
 -> Book
[OK] name 'Наименование' = DATA ISTRING[100] (Book);
 <- Наименование
 -> Name
[OK] CLASS Stock 'Склад';
 <- Склад
 -> Warehouse
[OK] name 'Наименование' = DATA ISTRING[100] (Stock);
 <- Наименование
 -> Name
[OK] balance 'Остаток' = DATA INTEGER (Book, Stock); // for example it is made a data property, although usually it is calculated
 <- Остаток
 -> Balance
[OK] FORM onStockObject 'Остатки'
 <- Остатки
 -> Balances
[OK]         FILTER 'С положительным остатком' balance(b, s) > 0 'F10'
 <- С положительным остатком' balance(b, s) > 0 'F10
 -> With positive balance' balance(b, s) > 0 'F10
[OK]         FILTER 'С отрицательными остатком' balance(b, s) < 0 'F9'
 <- С отрицательными остатком' balance(b, s) < 0 'F9
 -> With negative balance' balance(b, s) < 0 'F9
[OK]         FILTER 'С остатком' balance(b, s) 'F8' DEFAULT
 <- С остатком' balance(b, s) 'F8
 -> With balance' balance(b, s) 'F8
[OK]         FILTER 'Без остатка' NOT balance(b, s) 'F7'
 <- Без остатка' NOT balance(b, s) 'F7
 -> No remainder' NOT balance (b, s) 'F7
[OK] nameFilterStock 'Склад' = name(filterStock());
 <- Склад
 -> Warehouse
[OK] FORM onStockLocal 'Остатки'
 <- Остатки
 -> Balances
[OK] CLASS Customer 'Покупатель';
 <- Покупатель
 -> Customer
[OK] name 'Наименование' = DATA ISTRING[100] (Customer);
 <- Наименование
 -> Name
[OK] CLASS Order 'Заказ';
 <- Заказ
 -> Order
[OK] date 'Дата' = DATA DATE (Order);
 <- Дата
 -> Date
[OK] customer 'Покупатель' = DATA Customer (Order);
 <- Покупатель
 -> Customer
[OK] nameCustomer 'Покупатель' (Order o) = name(customer(o));
 <- Покупатель
 -> Customer
[OK] nameFilterCustomer 'Покупатель' = name(filterCustomer());
 <- Покупатель
 -> Customer
[OK] FORM orders 'Заказы'
 <- Заказы
 -> Orders

In samples/documentation/src/main/lsfusion/UseCaseFor.lsf of Category strings - Number of lines: 98; Number of occurances: 20

[OK] CLASS Book 'Книга';
 <- Книга
 -> Book
[OK] name 'Наименование' = DATA ISTRING[50] (Book);
 <- Наименование
 -> Name
[OK] FORM books 'Книги'
 <- Книги
 -> Books
[OK] findNemo 'Найти книгу' ()  { 
 <- Найти книгу
 -> Find book
[OK]     FOR isSubstring(name(Book b), 'Nemo') DO {
 <- Nemo
 -> Nemo
[OK]         MESSAGE 'Найдена книга ' + name(b) + ' с внутренним кодом ' + b;
 <- Найдена книга ' + name(b) + ' с внутренним кодом 
 -> Found book ' + name (b) + ' with internal code 
[OK] add100Books 'Добавить 100 книг' ()  { 
 <- Добавить 100 книг
 -> Add 100 books
[OK]         name(b) <- 'Книга ' + i;
 <- Книга 
 -> Book 
[OK]             name(b) <- 'Книга ' + i;
 <- Книга 
 -> Book 
[OK] CLASS Order 'Заказ';
 <- Заказ
 -> Order
[OK] CLASS OrderDetail 'Строка заказа';
 <- Строка заказа
 -> Order line
[OK] order 'Заказ' = DATA Order (OrderDetail) NONULL DELETE;
 <- Заказ
 -> Order
[OK] book 'Книга' = DATA Book (OrderDetail);
 <- Книга
 -> Book
[OK] nameBook 'Книга' (OrderDetail d) = name(book(d));
 <- Книга
 -> Book
[OK] price 'Цена' = DATA NUMERIC[14,2] (OrderDetail);
 <- Цена
 -> Price
[OK] discount 'Скидка, %' = DATA NUMERIC[8,2] (OrderDetail);
 <- Скидка, %
 -> Discount, %
[OK] discountPrice 'Цена со скидкой' = DATA NUMERIC[14,2] (OrderDetail); 
 <- Цена со скидкой
 -> Discount price
[OK] makeDiscount 'Сделать скидку' (Order o)  { 
 <- Сделать скидку
 -> Make discount
[OK] price 'Цена' = DATA NUMERIC[14,2] (Book);
 <- Цена
 -> Price
[OK] addSelectedBooks 'Добавить отмеченные книги' (Order o)  { 
 <- Добавить отмеченные книги
 -> Add marked books

In samples/documentation/src/main/lsfusion/UseCaseFormProperties.lsf of Category strings - Number of lines: 36; Number of occurances: 8

[OK] CLASS Book 'Книга';
 <- Книга
 -> Book
[OK] name 'Наименование' = DATA ISTRING[50] (Book) IN id;
 <- Наименование
 -> Name
[OK] genre 'Жанр' = DATA ISTRING[30] (Book) IN id;
 <- Жанр
 -> Genre
[OK] price 'Цена' = DATA NUMERIC[12,2] (Book) IN id;
 <- Цена
 -> Price
[OK] FORM books 'Книги'
 <- Книги
 -> Books
[OK] filtered 'Книга отфильтрована' (Book b) = FILTER books.b; 
 <- Книга отфильтрована
 -> Book filtered
[OK] filteredCount 'Кол-во книг' = GROUP SUM 1 IF filtered(Book b);
 <- Кол-во книг
 -> Number of books
[OK] index 'Порядок' (Book b) = PARTITION SUM 1 IF filtered(b) ORDER [ ORDER books.b](b); 
 <- Порядок
 -> Order

In samples/documentation/src/main/lsfusion/UseCaseFormSku.lsf of Category strings - Number of lines: 20; Number of occurances: 2

[OK] name 'Наименование' = DATA BPSTRING[100] (Sku); // creating a name property for it
 <- Наименование
 -> Name
[OK] FORM sku 'Sku' // creating the Item form
 <- Sku
 -> Sku

In samples/documentation/src/main/lsfusion/UseCaseFormula.lsf of Category strings - Number of lines: 66; Number of occurances: 13

[OK] CLASS Order 'Заказ';
 <- Заказ
 -> Order
[OK] date 'Дата' = DATA DATE (Order);
 <- Дата
 -> Date
[OK] number 'Номер' = DATA STRING[30] (Order);
 <- Номер
 -> Number
[OK] FORM orders 'Заказы на закупку'
 <- Заказы на закупку
 -> Purchase orders
[OK] toISO = FORMULA STRING[10] 'to_char($1,\'YYYY-MM-DD\')';
 <- to_char($1,\'YYYY-MM-DD\')
 -> to_char($1,\'YYYY-MM-DD\')
[OK] exportToCSV 'Экспорт в CSV' () {
 <- Экспорт в CSV
 -> Export to CSV
[OK] quantity 'Кол-во' = DATA NUMERIC[14,3] (OrderDetail);
 <- Кол-во
 -> Qty
[OK] sum 'Сумма' = DATA NUMERIC[14,2] (OrderDetail);
 <- Сумма
 -> Amount
[OK] toString = FORMULA TEXT 'to_char($1,$2)';
 <- to_char($1,$2)
 -> to_char($1,$2)
[OK] exportToCSV 'Экспорт в CSV' (Order o) {
 <- Экспорт в CSV
 -> Export to CSV
[OK]     EXPORT CSV FROM toISO(date(o)), number(o), toString(quantity(OrderDetail d), '999 999.999'), toString(sum(d), '999 999.99') WHERE order(d) = o TO file;
 <- 999 999.999'), toString(sum(d), '999 999.99
 -> 999 999.999'), toString(sum(d), '999 999.99
[OK] onlyDigits = FORMULA NULL BOOLEAN 'CASE WHEN trim($1) ~ \'^[0-9]*$\' THEN 1 ELSE NULL END';
 <- CASE WHEN trim($1) ~ \'^[0-9]*$\' THEN 1 ELSE NULL END
 -> CASE WHEN trim($1) ~ \'^[0-9]*$\' THEN 1 ELSE NULL END
[OK]     PROPERTIES 'Только цифры' = onlyDigits(number(o))
 <- Только цифры
 -> Only numbers

In samples/documentation/src/main/lsfusion/UseCaseIfCase.lsf of Category strings - Number of lines: 41; Number of occurances: 11

[OK] CLASS Book 'Книга';
 <- Книга
 -> Book
[OK] name 'Наименование' = DATA ISTRING[50] (Book);
 <- Наименование
 -> Name
[OK] CLASS Category 'Категория' {
 <- Категория
 -> Category
[OK]     novel 'Роман',
 <- Роман
 -> Novel
[OK]     thriller 'Триллер',
 <- Триллер
 -> Thriller
[OK]     fiction 'Фантастика'
 <- Фантастика
 -> Fiction
[OK] category 'Категория' = DATA Category (Book);
 <- Категория
 -> Category
[OK] price 'Цена' = DATA NUMERIC[14,2] (Book);
 <- Цена
 -> Price
[OK] setPriceIf 'Установить цену' (Book b)  { 
 <- Установить цену
 -> Set price
[OK]         MESSAGE 'Не выбрана категория для книги';
 <- Не выбрана категория для книги
 -> No category selected for the book
[OK] setPriceCase 'Установить цену' (Book b)  { 
 <- Установить цену
 -> Set price

In samples/documentation/src/main/lsfusion/UseCaseImport.lsf of Category strings - Number of lines: 190; Number of occurances: 28

[OK] CLASS Book 'Книга';
 <- Книга
 -> Book
[OK] name 'Наименование' = DATA ISTRING[100] (Book) IN id;
 <- Наименование
 -> Name
[OK] id 'Код' = DATA STRING[20] (Book) IN id;
 <- Код
 -> Code
[OK] book 'Книга' (STRING[20] id) = GROUP AGGR Book b BY id(b);
 <- Книга
 -> Book
[OK] CLASS Order 'Заказ';
 <- Заказ
 -> Order
[OK] date 'Дата' = DATA DATE (Order);
 <- Дата
 -> Date
[OK] number 'Номер' = DATA STRING[10] (Order);
 <- Номер
 -> Number
[OK] CLASS OrderDetail 'Строка заказа';
 <- Строка заказа
 -> Order line
[OK] order 'Заказ' = DATA Order (OrderDetail) NONULL DELETE;
 <- Заказ
 -> Order
[OK] book 'Книга' = DATA Book (OrderDetail) NONULL;
 <- Книга
 -> Book
[OK] nameBook 'Книга' (OrderDetail d) = name(book(d));
 <- Книга
 -> Book
[OK] quantity 'Количество' = DATA INTEGER (OrderDetail);
 <- Количество
 -> Quantity
[OK] price 'Цена' = DATA NUMERIC[14,2] (OrderDetail);
 <- Цена
 -> Price
[OK] FORM order 'Заказ'
 <- Заказ
 -> Order
[OK] FORM orders 'Заказы'
 <- Заказы
 -> Orders
[OK] importXlsx 'Импортировать из XLS' (Order o)  { 
 <- Импортировать из XLS
 -> Import from XLS
[OK] serverDirectory 'Директорий на сервере, из которого импортировать заказы' = DATA STRING[100] ();
 <- Директорий на сервере, из которого импортировать заказы
 -> Directory on the server from which orders should be imported
[OK] importOrders 'Импортировать заказы из директория' ()  { 
 <- Импортировать заказы из директория
 -> Import orders from directory
[OK]     listFiles('file://' + serverDirectory());  
 <- file://
 -> file://
[OK]         READ 'file://' + serverDirectory() + '/' + f TO file;
 <- file://' + serverDirectory() + '/
 -> file://' + serverDirectory() + '/
[OK]         IMPORT CSV '|' NOHEADER CHARSET 'CP1251' FROM file() TO date, number, bookId, quantity, price;
 <- |' NOHEADER CHARSET 'CP1251
 -> |' NOHEADER CHARSET 'CP1251
[OK]         move('file://' + serverDirectory() + '/' + f, 'file://' + serverDirectory() + '/' + (IF canceled() THEN 'error/' ELSE 'success/') + f);
 <- file://' + serverDirectory() + '/' + f, 'file://' + serverDirectory() + '/' + (IF canceled() THEN 'error/' ELSE 'success/
 -> file://' + serverDirectory() + '/' + f, 'file://' + serverDirectory() + '/' + (IF canceled() THEN 'error/' ELSE 'success/
[OK] importBooks 'Импортировать книги' ()  { 
 <- Импортировать книги
 -> Import books
[OK]     READ 'jdbc:sqlserver://localhost;databaseName=books;User=import;Password=password@SELECT id, name FROM books' TO file;
 <- jdbc:sqlserver://localhost;databaseName=books;User=import;Password=password@SELECT id, name FROM books
 -> jdbc:sqlserver://localhost;databaseName=books;User=import;Password=password@SELECT id, name FROM books
[OK] CLASS OrderDetailInfo 'Строка заказа (расшифровка)';
 <- Строка заказа (расшифровка)
 -> Order line (transcript)
[OK]     PROPERTIES(detail) IN item idItem EXTID 'id'
 <- id
 -> id
[OK]     OBJECTS detailInfo = OrderDetailInfo IN item EXTID 'info'
 <- info
 -> info
[OK] importOrderFromJSON 'Импорт из JSON' () {
 <- Импорт из JSON
 -> Import from JSON

In samples/documentation/src/main/lsfusion/UseCaseInheritance.lsf of Category strings - Number of lines: 103; Number of occurances: 31

[OK] CLASS Item 'Товар';
 <- Товар
 -> Product
[OK] name 'Имя' = DATA ISTRING[50] (Item) IN id;
 <- Имя
 -> Name
[OK] FORM items 'Товары'
 <- Товары
 -> Products
[OK] CLASS Receipt 'Поступление';
 <- Поступление
 -> Arrival
[OK] date 'Дата' = DATA DATE (Receipt) IN id;
 <- Дата
 -> Date
[OK] item 'Товар' = DATA Item (Receipt);
 <- Товар
 -> Product
[OK] nameItem 'Товар' (Receipt r) = name(item(r)) IN id;
 <- Товар
 -> Product
[OK] posted 'Проведен' = DATA BOOLEAN (Receipt);
 <- Проведен
 -> Completed
[OK] FORM receipts 'Поступления'
 <- Поступления
 -> Arrivals
[OK] CLASS Production 'Производство';
 <- Производство
 -> Production
[OK] date 'Дата' = DATA DATE (Production) IN id;
 <- Дата
 -> Date
[OK] item 'Товар' = DATA Item (Production);
 <- Товар
 -> Product
[OK] nameItem 'Товар' (Production p) = name(item(p)) IN id;
 <- Товар
 -> Product
[OK] posted 'Проведен' = DATA BOOLEAN (Production);
 <- Проведен
 -> Completed
[OK] FORM productions 'Производства'
 <- Производства
 -> Production
[OK] CLASS ABSTRACT Batch 'Партия';
 <- Партия
 -> Batch
[OK] date 'Дата' = ABSTRACT DATE (Batch) IN id;
 <- Дата
 -> Date
[OK] item 'Товар' = ABSTRACT Item (Batch);
 <- Товар
 -> Product
[OK] nameItem 'Товар' (Batch b) = name(item(b));
 <- Товар
 -> Product
[OK] type 'Тип' = ABSTRACT STRING[30] (Batch);
 <- Тип
 -> Type
[OK] FORM batches 'Партии'
 <- Партии
 -> Batches
[OK] CLASS ReceiptBatch 'Партия на основе поступления';
 <- Партия на основе поступления
 -> Arrival based batch
[OK] type(ReceiptBatch rb) += 'Поступление' IF rb IS ReceiptBatch;
 <- Поступление
 -> Arrival
[OK] CLASS ProductionBatch 'Партия на основе производства';
 <- Партия на основе производства
 -> Production based batch
[OK] type(ProductionBatch rb) += 'Производство' IF rb IS ProductionBatch;
 <- Производство
 -> Production
[OK] CLASS UserBatch 'Партия, созданная пользователем вручную';
 <- Партия, созданная пользователем вручную
 -> Manually created batch
[OK] date 'Дата' = DATA DATE (UserBatch) IN id;
 <- Дата
 -> Date
[OK] item 'Товар' = DATA Item (UserBatch);
 <- Товар
 -> Product
[OK] nameItem 'Товар' (UserBatch b) = name(item(b));
 <- Товар
 -> Product
[OK] FORM userBatches 'Партии (ручные)'
 <- Партии (ручные)
 -> Batches (manual)
[OK] type(UserBatch ub) += 'Ручные' IF ub IS UserBatch; <- Ручные
 -> Manual

In samples/documentation/src/main/lsfusion/UseCaseInput.lsf of Category strings - Number of lines: 84; Number of occurances: 15

[OK] CLASS Book 'Книга';
 <- Книга
 -> Book
[OK] name 'Наименование' = DATA ISTRING[100] (Book);
 <- Наименование
 -> Name
[OK]      INPUT s = ISTRING[100] // inputting ISTRING[100] "into the parameter" s (automatically wrapped in REQUEST, that is, group adjustments, PASTE, etc. are available)
 <- в параметр
 -> to parameter
[OK] CLASS Genre 'Жанр';
 <- Жанр
 -> Genre
[OK] name 'Наименование' = DATA ISTRING[100] (Genre);
 <- Наименование
 -> Name
[OK] genre 'Жанр' = DATA Genre (Book);
 <- Жанр
 -> Genre
[OK] isForbidden 'Запрет' = DATA BOOLEAN (Book);
 <- Запрет
 -> Prohibition
[OK] CLASS Order 'Заказ';
 <- Заказ
 -> Order
[OK] book 'Книга' = DATA Book (Order);
 <- Книга
 -> Book
[OK] nameBook 'Наименование книги' (Order o) = name(book(o));
 <- Наименование книги
 -> Book name
[OK] date 'Дата' = DATA DATE (Order);
 <- Дата
 -> Date
[OK] number 'Номер' = DATA STRING[100] (Order);
 <- Номер
 -> Number
[OK]     CHECKED BY book MESSAGE 'Запрещено выбирать эту книгу';
 <- Запрещено выбирать эту книгу
 -> It is forbidden to choose this book
[OK] FORM orders 'Заказы'
 <- Заказы
 -> Orders
[OK]                     // INPUT b NULL - returning the value of this object "in the parameter" bk (return NULL is allowed, that is, there will be a reset button). Since the TO option is not specified, the result will be written to the requestedObject
 <- в параметр
 -> to parameter

In samples/documentation/src/main/lsfusion/UseCaseInternal.lsf of Category strings - Number of lines: 70; Number of occurances: 11

[OK] getIPJava INTERNAL 'GetIP';
 <- GetIP
 -> GetIP
[OK] showIPJava 'Показать имя компьютера (Java)' {
 <- Показать имя компьютера (Java)
 -> Show computer name (Java)
[OK] FORM info 'Информация'
 <- Информация
 -> Information
[OK] getIPFusion INTERNAL <{ findProperty("ip").change((Object)java.net.InetAddress.getLocalHost().toString(), context); }>;
 <- ip
 -> ip
[OK] showIPFusion 'Показать имя компьютера (Fusion)' {
 <- Показать имя компьютера (Fusion)
 -> Show computer name (Fusion)
[OK] calculateGCD 'Рассчитать НОД' INTERNAL 'CalculateGCD' (INTEGER, INTEGER);
 <- Рассчитать НОД' INTERNAL 'CalculateGCD
 -> Calculate GCD' INTERNAL 'CalculateGCD
[OK] FORM gcd 'НОД'
 <- НОД
 -> GCD
[OK]     PROPERTIES 'A' = VALUE(a), 'B' = VALUE(b)
 <- A' = VALUE(a), 'B
 -> A' = VALUE(a), 'B
[OK] calculateGCD 'Рассчитать НОД' INTERNAL 'CalculateGCDObject' (Calculation);
 <- Рассчитать НОД' INTERNAL 'CalculateGCDObject
 -> Calculate GCD' INTERNAL 'CalculateGCDObject
[OK] beep INTERNAL 'Beep';
 <- Beep
 -> Beep
[OK] FORM beep 'Сигнал'
 <- Сигнал
 -> Signal

In samples/documentation/src/main/lsfusion/UseCaseInternationalization.lsf of Category strings - Number of lines: 24; Number of occurances: 5

[OK] CLASS Book '{use.case.i18n.book}';
 <- {use.case.i18n.book}
 -> {use.case.i18n.book}
[OK] name '{use.case.i18n.book.name}' = DATA STRING[40] (Book);
 <- {use.case.i18n.book.name}
 -> {use.case.i18n.book.name}
[OK] price '{use.case.i18n.book.price}' = DATA STRING[40] (Book);
 <- {use.case.i18n.book.price}
 -> {use.case.i18n.book.price}
[OK] FORM books '{use.case.i18n.books}'
 <- {use.case.i18n.books}
 -> {use.case.i18n.books}
[OK] description '{use.case.i18n.book.description}' (Book b) = STRING[60] (name(b) + ', {use.case.i18n.book.price} : ' + price(b));
 <- {use.case.i18n.book.description}' (Book b) = STRING[60] (name(b) + ', {use.case.i18n.book.price} : 
 -> {use.case.i18n.book.description}' (Book b) = STRING[60] (name(b) + ', {use.case.i18n.book.price} : 

In samples/documentation/src/main/lsfusion/UseCaseLast.lsf of Category strings - Number of lines: 58; Number of occurances: 14

[OK] CLASS Book 'Книга';
 <- Книга
 -> Book
[OK] CLASS Category 'Категория';
 <- Категория
 -> Category
[OK] category 'Категория' = DATA Category (Book);
 <- Категория
 -> Category
[OK] date 'Дата прихода' = DATA DATE (Book);
 <- Дата прихода
 -> Arrival date
[OK] book 'Последняя книга' (Category c) = GROUP LAST Book b ORDER date(b), b BY category(b);
 <- Последняя книга
 -> Last book
[OK] CLASS Author 'Автор';
 <- Автор
 -> Author
[OK] CLASS Genre 'Жанр';
 <- Жанр
 -> Genre
[OK] author 'Автор' = DATA Author (Book);
 <- Автор
 -> Author
[OK] genre 'Жанр' = DATA Genre (Book);
 <- Жанр
 -> Genre
[OK] in 'Вкл' = DATA BOOLEAN (Book, Genre);
 <- Вкл
 -> On
[OK] countBooks 'Кол-во книг' (Category c, Author a, Genre g) = GROUP SUM 1 IF in(Book b, g) BY category(b), author(b);
 <- Кол-во книг
 -> Number of books
[OK] CLASS Stock 'Склад';
 <- Склад
 -> Warehouse
[OK] CLASS Ledger 'Изменение цены';
 <- Изменение цены
 -> Price change
[OK] dateTo 'Действует по (включительно)' = DATA DATE (Ledger);
 <- Действует по (включительно)
 -> Valid until (inclusive)

In samples/documentation/src/main/lsfusion/UseCaseLedger.lsf of Category strings - Number of lines: 138; Number of occurances: 39

[OK] CLASS SKU 'SKU';
 <- SKU
 -> SKU
[OK] CLASS Stock 'Склад';
 <- Склад
 -> Warehouse
[OK] CLASS ABSTRACT SKULedger 'Регистр изменения остатка товара';
 <- Регистр изменения остатка товара
 -> Register of changes in the product balance
[OK] posted 'Проведен' = ABSTRACT BOOLEAN (SKULedger);
 <- Проведен
 -> Completed
[OK] dateTime 'Дата/время' = ABSTRACT DATETIME (SKULedger);
 <- Дата/время
 -> Date/time
[OK] sku 'SKU' = ABSTRACT SKU (SKULedger);
 <- SKU
 -> SKU
[OK] stock 'Склад' = ABSTRACT Stock (SKULedger);
 <- Склад
 -> Warehouse
[OK] quantity 'Кол-во' = ABSTRACT NUMERIC[14,2] (SKULedger);
 <- Кол-во
 -> Qty
[OK] balance 'Остаток' = GROUP SUM quantity(SKULedger l) IF posted(l) BY stock(l), sku(l);
 <- Остаток
 -> Balance
[OK] balance 'Остаток на дату/время' = GROUP SUM quantity(SKULedger l) IF posted(l) AND dateTime(l) <= DATETIME dt BY stock(l), sku(l), dateTime(l);
 <- Остаток на дату/время
 -> Balance as of date/time
[OK] CLASS Receipt 'Поступление на склад';
 <- Поступление на склад
 -> Warehouse arrival
[OK] posted 'Проведен' = DATA BOOLEAN (Receipt);
 <- Проведен
 -> Completed
[OK] dateTime 'Дата/время' = DATA DATETIME (Receipt);
 <- Дата/время
 -> Date/time
[OK] stock 'Склад' = DATA Stock (Receipt); 
 <- Склад
 -> Warehouse
[OK] CLASS ReceiptDetail 'Строка поступления на склад';
 <- Строка поступления на склад
 -> Warehouse arrival line
[OK] receipt 'Поступление' = DATA Receipt (ReceiptDetail) NONULL DELETE;
 <- Поступление
 -> Arrival
[OK] sku 'SKU' = DATA SKU (ReceiptDetail);
 <- SKU
 -> SKU
[OK] quantity 'Кол-во' = DATA NUMERIC[14,2] (ReceiptDetail);
 <- Кол-во
 -> Qty
[OK] price 'Цена' = DATA NUMERIC[14,2] (ReceiptDetail);
 <- Цена
 -> Price
[OK] CLASS Transfer 'Перемещение со склада на склад';
 <- Перемещение со склада на склад
 -> Moving from warehouse to warehouse
[OK] posted 'Проведен' = DATA BOOLEAN (Transfer);
 <- Проведен
 -> Completed
[OK] dateTime 'Дата/время' = DATA DATETIME (Transfer);
 <- Дата/время
 -> Date/time
[OK] fromStock 'Склад (откуда)' = DATA Stock (Transfer); 
 <- Склад (откуда)
 -> Warehouse (from)
[OK] toStock 'Склад (куда)' = DATA Stock (Transfer); 
 <- Склад (куда)
 -> Warehouse (to)
[OK] CLASS TransferDetail 'Строка отгрузки со склада';
 <- Строка отгрузки со склада
 -> Warehouse shipment line
[OK] transfer 'Поступление' = DATA Transfer (TransferDetail) NONULL DELETE;
 <- Поступление
 -> Arrival
[OK] sku 'SKU' = DATA SKU (TransferDetail);
 <- SKU
 -> SKU
[OK] quantity 'Кол-во' = DATA NUMERIC[14,2] (TransferDetail);
 <- Кол-во
 -> Qty
[OK] price 'Цена' = DATA NUMERIC[14,2] (TransferDetail);
 <- Цена
 -> Price
[OK] CLASS TransferSKULedger 'Перемещение на склад (регистр)' : SKULedger; 
 <- Перемещение на склад (регистр)
 -> Moving to warehouse (register)
[OK] CLASS ABSTRACT PriceLedger 'Регистр изменения цены поступления';
 <- Регистр изменения цены поступления
 -> Receipt price change register
[OK] posted 'Проведен' = ABSTRACT BOOLEAN (PriceLedger);
 <- Проведен
 -> Completed
[OK] dateTime 'Дата/время' = ABSTRACT DATETIME (PriceLedger);
 <- Дата/время
 -> Date/time
[OK] sku 'SKU' = ABSTRACT SKU (PriceLedger);
 <- SKU
 -> SKU
[OK] stock 'Склад' = ABSTRACT Stock (PriceLedger);
 <- Склад
 -> Warehouse
[OK] price 'Цена' = ABSTRACT NUMERIC[14,2] (PriceLedger);
 <- Цена
 -> Price
[OK] price 'Цена' (Stock stock, SKU sku, DATETIME dateTime) = 
 <- Цена
 -> Price
[OK] price 'Цена' (Stock stock, SKU sku) =
 <- Цена
 -> Price
[OK] price 'Цена' (SKU sku, DATETIME dateTime) = 
 <- Цена
 -> Price

In samples/documentation/src/main/lsfusion/UseCaseMeta.lsf of Category strings - Number of lines: 38; Number of occurances: 3

[OK]     name 'Наименование' = DATA ISTRING[100] (class);
 <- Наименование
 -> Name
[OK] @defineObject(book, b, 'Книга', 'Книги');
 <- Книга', 'Книги
 -> Book', 'Books
[OK] @defineObject(magazine, m, 'Журнал', 'Журналы');
 <- Журнал', 'Журналы
 -> Magazine', 'Magazines

In samples/documentation/src/main/lsfusion/UseCaseMetaResult.lsf of Category strings - Number of lines: 57; Number of occurances: 9

[OK] CLASS Book 'Книга';
 <- Книга
 -> Book
[OK] name 'Наименование' = DATA ISTRING[100] (Book);
 <- Наименование
 -> Name
[OK] FORM book 'Книга'
 <- Книга
 -> Book
[OK] FORM books 'Книги'
 <- Книги
 -> Books
[OK] CLASS Magazine 'Журнал';
 <- Журнал
 -> Magazine
[OK] name 'Наименование' = DATA ISTRING[100] (Magazine);
 <- Наименование
 -> Name
[OK] FORM magazine 'Журнал'
 <- Журнал
 -> Magazine
[OK] FORM magazines 'Журналы'
 <- Журналы
 -> Magazines
[OK] genre 'Жанр' = DATA ISTRING[20] (Book);
 <- Жанр
 -> Genre

In samples/documentation/src/main/lsfusion/UseCaseMMA.lsf of Category strings - Number of lines: 42; Number of occurances: 14

[OK] CLASS Book 'Книга';
 <- Книга
 -> Book
[OK] id 'Номер' = DATA INTEGER (Book);
 <- Номер
 -> Number
[OK] maxId 'Максимальный номер' () = GROUP MAX id(Book b);
 <- Максимальный номер
 -> Maximum number
[OK] book1 'Книга' (INTEGER i) = GROUP MAX Book b BY id(b);
 <- Книга
 -> Book
[OK] book2 'Книга' (INTEGER i) = GROUP AGGR Book b BY id(b);
 <- Книга
 -> Book
[OK] CLASS Category 'Категория';
 <- Категория
 -> Category
[OK] category 'Категория' = DATA Category (Book);
 <- Категория
 -> Category
[OK] price 'Цена' = DATA NUMERIC[10,2] (Book);
 <- Цена
 -> Price
[OK] minPrice 'Максимальный номер' (Category c) = GROUP MIN price(Book b) BY category(b);
 <- Максимальный номер
 -> Maximum number
[OK] CLASS Shipment 'Отгрузка';
 <- Отгрузка
 -> Shipment
[OK] CLASS ShipmentDetail 'Строка отгрузки';
 <- Строка отгрузки
 -> Shipment line
[OK] shipment 'Отгрузка' = DATA Shipment (ShipmentDetail) NONULL DELETE;
 <- Отгрузка
 -> Shipment
[OK] book 'Книга' = DATA Book (ShipmentDetail);
 <- Книга
 -> Book
[OK] shipmentDetail 'Строка отгрузки' (Shipment s, Book b) = GROUP MAX ShipmentDetail d BY shipment(d), book(d);
 <- Строка отгрузки
 -> Shipment line

In samples/documentation/src/main/lsfusion/UseCaseNamePurchase.lsf of Category strings - Number of lines: 18; Number of occurances: 4

[OK] CLASS Order 'Заказ';
 <- Заказ
 -> Order
[OK] date 'Дата' = DATA DATE (Order);
 <- Дата
 -> Date
[OK] number 'Номер' = DATA INTEGER (Order);
 <- Номер
 -> Number
[OK] FORM orders 'Заказы на закупку'
 <- Заказы на закупку
 -> Purchase orders

In samples/documentation/src/main/lsfusion/UseCaseNameSale.lsf of Category strings - Number of lines: 19; Number of occurances: 4

[OK] CLASS Order 'Заказ';
 <- Заказ
 -> Order
[OK] date 'Дата' = DATA DATE (Order);
 <- Дата
 -> Date
[OK] number 'Номер' = DATA INTEGER (Order);
 <- Номер
 -> Number
[OK] FORM orders 'Заказы на продажу'
 <- Заказы на продажу
 -> Sales orders

In samples/documentation/src/main/lsfusion/UseCaseNameTest.lsf of Category strings - Number of lines: 19; Number of occurances: 2

[OK] messagePurchaseCount 'Вывести кол-во заказов на закупку' {
 <- Вывести кол-во заказов на закупку
 -> Display the number of purchase orders
[OK] messageSaleCount 'Вывести кол-во заказов на продажу' {
 <- Вывести кол-во заказов на продажу
 -> Display the number of sales orders

In samples/documentation/src/main/lsfusion/UseCaseNameTest2.lsf of Category strings - Number of lines: 25; Number of occurances: 2

[OK] messagePurchaseCount 'Вывести кол-во заказов на закупку' {
 <- Вывести кол-во заказов на закупку
 -> Display the number of purchase orders
[OK] messageSaleCount 'Вывести кол-во заказов на продажу' {
 <- Вывести кол-во заказов на продажу
 -> Display the number of sales orders

In samples/documentation/src/main/lsfusion/UseCaseNavigator.lsf of Category strings - Number of lines: 26; Number of occurances: 4

[OK] FORM categories 'Категории';
 <- Категории
 -> Categories
[OK] FORM books 'Книги';
 <- Книги
 -> Books
[OK]     NEW FOLDER application 'Приложение' WINDOW toolbar FIRST {
 <- Приложение
 -> Application
[OK]         NEW FOLDER masterData 'Справочники' {
 <- Справочники
 -> Directories

In samples/documentation/src/main/lsfusion/UseCaseNew.lsf of Category strings - Number of lines: 48; Number of occurances: 13

[OK] CLASS Order 'Заказ';
 <- Заказ
 -> Order
[OK] CLASS Customer 'Покупатель';
 <- Покупатель
 -> Customer
[OK] date 'Дата' = DATA DATE (Order);
 <- Дата
 -> Date
[OK] customer 'Покупатель' = DATA Customer (Order);
 <- Покупатель
 -> Customer
[OK] nameCustomer 'Покупатель' (Order o) = name(customer(o));
 <- Покупатель
 -> Customer
[OK] copyOrder 'Копировать' (Order o)  { 
 <- Копировать
 -> Copy
[OK] CLASS Book 'Книга';
 <- Книга
 -> Book
[OK] name 'Наименование' = DATA ISTRING[50] (Book);
 <- Наименование
 -> Name
[OK] CLASS OrderDetail 'Строка заказа';
 <- Строка заказа
 -> Order line
[OK] order 'Заказ' = DATA Order (OrderDetail) NONULL DELETE;
 <- Заказ
 -> Order
[OK] book 'Книга' = DATA Book (OrderDetail);
 <- Книга
 -> Book
[OK] nameBook 'Книга' (OrderDetail d) = name(book(d));
 <- Книга
 -> Book
[OK] price 'Цена' = DATA NUMERIC[14,2] (OrderDetail);
 <- Цена
 -> Price

In samples/documentation/src/main/lsfusion/UseCaseNewSession.lsf of Category strings - Number of lines: 106; Number of occurances: 13

[OK] CLASS Order 'Заказ';
 <- Заказ
 -> Order
[OK] isPosted 'Проведен' = DATA BOOLEAN (Order);
 <- Проведен
 -> Completed
[OK] number 'Номер' = DATA INTEGER (Order);
 <- Номер
 -> Number
[OK] post 'Провести' (Order o)  { 
 <- Провести
 -> Complete
[OK] selected 'Отм' = DATA LOCAL BOOLEAN (Order);
 <- Отм
 -> Mark
[OK] deleteSelectedOrders 'Удалить отмеченные заказы' ()  { 
 <- Удалить отмеченные заказы
 -> Delete marked orders
[OK]         ASK 'Вы собираетесь удалить ' + (GROUP SUM 1 IF DROPPED(Order o)) + ' заказов. Продолжить ?' DO {
 <- Вы собираетесь удалить ' + (GROUP SUM 1 IF DROPPED(Order o)) + ' заказов. Продолжить ?
 -> You are about to delete ' + (GROUP SUM 1 IF DROPPED (Order o)) + ' orders. Continue?
[OK] CLASS Payment 'Платеж';
 <- Платеж
 -> Payment
[OK] date 'Дата' = DATA DATE (Payment);
 <- Дата
 -> Date
[OK] sum 'Сумма' = DATA NUMERIC[14,2] (Payment);
 <- Сумма
 -> Amount
[OK] order 'Заказ' = DATA Order (Payment);
 <- Заказ
 -> Order
[OK] FORM orderPayments 'Платежи по заказу'
 <- Платежи по заказу
 -> Order payments
[OK] editPayments 'Редактировать платежи' (Order o)  { 
 <- Редактировать платежи
 -> Edit payments

In samples/documentation/src/main/lsfusion/UseCaseNumerating.lsf of Category strings - Number of lines: 49; Number of occurances: 11

[OK] CLASS Book 'Книга';
 <- Книга
 -> Book
[OK] number 'Номер' = DATA INTEGER (Book) IN id;
 <- Номер
 -> Number
[OK] name 'Название' = DATA ISTRING[50] (Book) IN id;
 <- Название
 -> Name
[OK]         MESSAGE 'Книга с номером ' + number + ' существует. Ее название : ' + name(book(number)); 
 <- Книга с номером ' + number + ' существует. Ее название : 
 -> The book with the number ' + number + ' exists. Its name : 
[OK]         MESSAGE 'Книги с номером ' + number + ' не существует';
 <- Книги с номером ' + number + ' не существует
 -> The book with the number ' + number + ' does not exist
[OK] CLASS Numerator 'Нумератор';
 <- Нумератор
 -> Numerator
[OK] name 'Наименование' = DATA ISTRING[50] (Numerator) IN id;
 <- Наименование
 -> Name
[OK] CLASS Order 'Заказ';
 <- Заказ
 -> Order
[OK] number 'Номер' = DATA INTEGER (Order) IN id;
 <- Номер
 -> Number
[OK] numerator 'Нумератор' = DATA Numerator (Order);  
 <- Нумератор
 -> Numerator
[OK] defaultNumerator 'Нумератор по умолчанию' = DATA Numerator();
 <- Нумератор по умолчанию
 -> Default numerator

In samples/documentation/src/main/lsfusion/UseCaseOverride.lsf of Category strings - Number of lines: 74; Number of occurances: 16

[OK] CLASS Category 'Категория';
 <- Категория
 -> Category
[OK] name 'Наименование' = DATA ISTRING[50] (Category) IN id;
 <- Наименование
 -> Name
[OK] parent 'Родитель' = DATA Category (Category) AUTOSET;
 <- Родитель
 -> Parent
[OK] nameParent 'Родитель' (Category c) = name(parent(c)) IN id;
 <- Родитель
 -> Parent
[OK] markup 'Надбавка' = DATA NUMERIC[8,2] (Category);
 <- Надбавка
 -> Markup
[OK] level 'Уровень' (Category child, Category parent) = RECURSION 1l IF child IS Category AND parent == child
 <- Уровень
 -> Level
[OK] nearestGroupLevel 'Ближайший уровень, для которого задана надбавка' (Category child) = 
 <- Ближайший уровень, для которого задана надбавка
 -> The closest level for which the markup is set
[OK] nearestGroup 'Ближайшая группа, для которой задана надбавка' (Category category) = parent(category, nearestGroupLevel(category));
 <- Ближайшая группа, для которой задана надбавка
 -> The closest group for which the markup is set
[OK] overMarkup 'Надбавка перегруженная' (Category category) = markup(nearestGroup(category));
 <- Надбавка перегруженная
 -> Overidden markup
[OK] CLASS Book 'Книга';
 <- Книга
 -> Book
[OK] name 'Наименование' = DATA ISTRING[100] (Book) IN id;
 <- Наименование
 -> Name
[OK] category 'Категория' = DATA Category (Book) AUTOSET;
 <- Категория
 -> Category
[OK] nameCategory 'Категория' (Book b) = name(category(b)) IN id; 
 <- Категория
 -> Category
[OK] markup 'Надбавка для товара' = DATA NUMERIC[8,2] (Book);
 <- Надбавка для товара
 -> Product markup
[OK] overMarkup 'Надбавка перегруженная' (Book b) = OVERRIDE markup(b), overMarkup(category(b));
 <- Надбавка перегруженная
 -> Overidden markup
[OK] FORM markups 'Надбавки'
 <- Надбавки
 -> Markups

In samples/documentation/src/main/lsfusion/UseCasePartition.lsf of Category strings - Number of lines: 43; Number of occurances: 15

[OK] CLASS Order 'Заказ';
 <- Заказ
 -> Order
[OK] CLASS OrderDetail 'Строка заказа';
 <- Строка заказа
 -> Order line
[OK] order 'Заказ' = DATA Order (OrderDetail) NONULL DELETE;
 <- Заказ
 -> Order
[OK] index 'Номер строки' (OrderDetail d) = PARTITION SUM 1 ORDER d BY order(d) CHARWIDTH 4;
 <- Номер строки
 -> Line number
[OK] date 'Дата' = DATA DATE (Order);
 <- Дата
 -> Date
[OK] CLASS Customer 'Покупатель';
 <- Покупатель
 -> Customer
[OK] customer 'Покупатель' = DATA Customer (Order);
 <- Покупатель
 -> Customer
[OK] prevOrderDate 'Предыдущий заказ' (Order o) = PARTITION PREV date(o) ORDER date(o), o BY customer(o);
 <- Предыдущий заказ
 -> Previous order
[OK] CLASS Book 'Книга';
 <- Книга
 -> Book
[OK] CLASS Batch 'Партия';
 <- Партия
 -> Batch
[OK] book 'Книга' = DATA Book (Batch);
 <- Книга
 -> Book
[OK] date 'Дата прихода' = DATA DATE (Batch);
 <- Дата прихода
 -> Arrival date
[OK] CLASS Stock 'Склад';
 <- Склад
 -> Warehouse
[OK] currentBalance 'Остаток' = DATA INTEGER (Batch, Stock); // The balance is made data for the example. This is usually a calculated property.
 <- Остаток
 -> Balance
[OK] quantityFIFO 'Кол-во по партии FIFO' (Batch b, Stock s) = PARTITION UNGROUP quantity
 <- Кол-во по партии FIFO
 -> Quantity by FIFO batch

In samples/documentation/src/main/lsfusion/UseCasePropertyShape.lsf of Category strings - Number of lines: 26; Number of occurances: 5

[OK] square 'Площадь' = ABSTRACT DOUBLE (Shape);
 <- Площадь
 -> Area
[OK] width 'Ширина' = DATA DOUBLE (Rectangle);
 <- Ширина
 -> Width
[OK] height 'Высота' = DATA DOUBLE (Rectangle);
 <- Высота
 -> Height
[OK] radius 'Радиус окружности' = DATA DOUBLE (Circle);
 <- Радиус окружности
 -> Circle radius
[OK] overSquareCircle 'Перегруженная площадь' = ABSTRACT DOUBLE (Circle);
 <- Перегруженная площадь
 -> Overridden area

In samples/documentation/src/main/lsfusion/UseCaseReports.lsf of Category strings - Number of lines: 190; Number of occurances: 44

[OK] CLASS Category 'Категория';
 <- Категория
 -> Category
[OK] name 'Наименование' = DATA ISTRING[50] (Category) IN id;
 <- Наименование
 -> Name
[OK] CLASS Book 'Книга';
 <- Книга
 -> Book
[OK] name 'Наименование' = DATA ISTRING[100] (Book) IN id;
 <- Наименование
 -> Name
[OK] category 'Категория' = DATA Category (Book) AUTOSET;
 <- Категория
 -> Category
[OK] nameCategory 'Категория' (Book b) = name(category(b)) IN id;
 <- Категория
 -> Category
[OK] countBooks 'Кол-во книг' (Category c) = GROUP SUM 1 BY category(Book b);
 <- Кол-во книг
 -> Number of books
[OK] FORM books 'Книги'
 <- Книги
 -> Books
[OK] FORM booksByCategories 'Книги по категориям'
 <- Книги по категориям
 -> Books by category
[OK] printBooksByCategories 'Книги по категориям' ()  { 
 <- Книги по категориям
 -> Books by category
[OK] xlsxBooksByCategories 'Книги по категориям (XLSX)' ()  { 
 <- Книги по категориям (XLSX)
 -> Books by category (XLSX)
[OK] CLASS Invoice 'Счет';
 <- Счет
 -> Invoice
[OK] date 'Дата' = DATA DATE (Invoice);
 <- Дата
 -> Date
[OK] number 'Номер' = DATA STRING[10] (Invoice);
 <- Номер
 -> Number
[OK] CLASS InvoiceDetail 'Строка счета';
 <- Строка счета
 -> Invoice line
[OK] invoice 'Счет' = DATA Invoice (InvoiceDetail) NONULL DELETE;
 <- Счет
 -> Invoice
[OK] book 'Книга' = DATA Book (InvoiceDetail) NONULL;
 <- Книга
 -> Book
[OK] nameBook 'Книга' (InvoiceDetail d) = name(book(d));
 <- Книга
 -> Book
[OK] quantity 'Количество' = DATA INTEGER (InvoiceDetail);
 <- Количество
 -> Quantity
[OK] price 'Цена' = DATA NUMERIC[14,2] (InvoiceDetail);
 <- Цена
 -> Price
[OK] FORM invoice 'Счет'
 <- Счет
 -> Invoice
[OK] FORM invoices 'Счета'
 <- Счета
 -> Invoices
[OK] print 'Печать' (Invoice i)  { 
 <- Печать
 -> Print
[OK] printWord 'Печать (DOCX)' (Invoice i)  { 
 <- Печать (DOCX)
 -> Print (DOCX)
[OK] CLASS Customer 'Покупатель';
 <- Покупатель
 -> Customer
[OK] name 'Наименование' = DATA ISTRING[50] (Customer) IN id;
 <- Наименование
 -> Name
[OK] FORM customers 'Покупатели'
 <- Покупатели
 -> Customers
[OK] customer 'Покупатель' = DATA Customer (Invoice);
 <- Покупатель
 -> Customer
[OK] nameCustomer 'Покупатель' (Invoice i) = name(customer(i));
 <- Покупатель
 -> Customer
[OK] CLASS Order 'Заказ';
 <- Заказ
 -> Order
[OK] date 'Дата' = DATA DATE (Order);
 <- Дата
 -> Date
[OK] number 'Номер' = DATA STRING[10] (Order);
 <- Номер
 -> Number
[OK] customer 'Покупатель' = DATA Customer (Order);
 <- Покупатель
 -> Customer
[OK] nameCustomer 'Покупатель' (Order o) = name(customer(o));
 <- Покупатель
 -> Customer
[OK] CLASS OrderDetail 'Строка заказа';
 <- Строка заказа
 -> Order line
[OK] order 'Заказ' = DATA Order (OrderDetail) NONULL DELETE;
 <- Заказ
 -> Order
[OK] book 'Книга' = DATA Book (OrderDetail) NONULL;
 <- Книга
 -> Book
[OK] nameBook 'Книга' (OrderDetail d) = name(book(d));
 <- Книга
 -> Book
[OK] quantity 'Количество' = DATA INTEGER (OrderDetail);
 <- Количество
 -> Quantity
[OK] price 'Цена' = DATA NUMERIC[14,2] (OrderDetail);
 <- Цена
 -> Price
[OK] FORM order 'Заказ'
 <- Заказ
 -> Order
[OK] FORM orders 'Заказы'
 <- Заказы
 -> Orders
[OK] FORM customerInfo 'Информация по клиенту'
 <- Информация по клиенту
 -> Customer information
[OK] printInfo 'Распечатать информацию' (Customer c)  { 
 <- Распечатать информацию
 -> Print information

In samples/documentation/src/main/lsfusion/UseCaseSeek.lsf of Category strings - Number of lines: 122; Number of occurances: 20

[OK] CLASS Category 'Категория';
 <- Категория
 -> Category
[OK] name 'Наименование' = DATA ISTRING[50] (Category) IN id;
 <- Наименование
 -> Name
[OK] CLASS Book 'Книга';
 <- Книга
 -> Book
[OK] name 'Наименование' = DATA ISTRING[50] (Book) IN id;
 <- Наименование
 -> Name
[OK] category 'Категория' = DATA Category (Book) NONULL;
 <- Категория
 -> Category
[OK] nameCategory 'Категория' (Book b) = name(category(b));
 <- Категория
 -> Category
[OK] FORM book 'Книга'
 <- Книга
 -> Book
[OK] FORM books 'Книги'
 <- Книги
 -> Books
[OK] createBook 'Создать книгу' (Category c)  { 
 <- Создать книгу
 -> Create book
[OK] CLASS Customer 'Покупатель';
 <- Покупатель
 -> Customer
[OK] name 'Наименование' = DATA ISTRING[50] (Customer) IN id;
 <- Наименование
 -> Name
[OK] price 'Цена' = DATA NUMERIC[14,2] (Customer, Book);
 <- Цена
 -> Price
[OK] FORM prices 'Цены'
 <- Цены
 -> Prices
[OK] defaultCustomer 'Покупатель по умолчанию' = DATA Customer ();
 <- Покупатель по умолчанию
 -> Default customer
[OK] nameDefaultCustomer 'Покупатель по умолчанию' () = name(defaultCustomer());
 <- Покупатель по умолчанию
 -> Default customer
[OK] FORM report 'Отчет'
 <- Отчет
 -> Report
[OK] setReportLastWeek 'Последняя неделя' ()  { 
 <- Последняя неделя
 -> Last week
[OK] setReportCurrentMonth 'Текущий месяц' ()  { 
 <- Текущий месяц
 -> Current month
[OK] setReportLastMonth 'Последний месяц' ()  { 
 <- Последний месяц
 -> Last month
[OK] FORM customers 'Покупатели'
 <- Покупатели
 -> Customers

In samples/documentation/src/main/lsfusion/UseCaseSum.lsf of Category strings - Number of lines: 55; Number of occurances: 18

[OK] CLASS Book 'Книга';
 <- Книга
 -> Book
[OK] CLASS Category 'Категория';
 <- Категория
 -> Category
[OK] category 'Категория' = DATA Category (Book);
 <- Категория
 -> Category
[OK] countBooks 'Количество книг' (Category c) = GROUP SUM 1 BY category(Book book);
 <- Количество книг
 -> Number of books
[OK] CLASS Tag 'Тег';
 <- Тег
 -> Tag
[OK] in 'Вкл' = DATA BOOLEAN (Tag, Book);
 <- Вкл
 -> On
[OK] countBooks 'Количество книг' (Tag t) = GROUP SUM 1 IF in(t, Book b);
 <- Количество книг
 -> Number of books
[OK] CLASS Stock 'Склад';
 <- Склад
 -> Warehouse
[OK] CLASS Ledger 'Движение';
 <- Движение
 -> Movement
[OK] book 'Книга' = DATA Book (Ledger);
 <- Книга
 -> Book
[OK] stock 'Склад' = DATA Stock (Ledger);
 <- Склад
 -> Warehouse
[OK] quantity 'Кол-во' = DATA INTEGER (Ledger);
 <- Кол-во
 -> Qty
[OK] out 'Расход' = DATA BOOLEAN (Ledger);
 <- Расход
 -> Expenses
[OK] currentBalance 'Текущий остаток' (Book b, Stock s) = GROUP SUM IF out(Ledger l) THEN -quantity(l) ELSE quantity(l) BY book(l), stock(l) MATERIALIZED;
 <- Текущий остаток
 -> Current balance
[OK] date 'Дата' = DATA DATE (Ledger) INDEXED; // it is better to add an index to filter by date quickly
 <- Дата
 -> Date
[OK] balance1 'Остаток на дату' (Book b, Stock s, DATE d) = GROUP SUM (IF out(Ledger l) THEN -quantity(l) ELSE quantity(l)) IF date(l) < d BY book(l), stock(l);
 <- Остаток на дату
 -> Balance as of date
[OK] balance2 'Остаток на дату' (Book b, Stock s, DATE d) = currentBalance(b, s) (-) [ GROUP SUM (IF out(Ledger l) THEN -quantity(l) ELSE quantity(l)) IF date(l) >= d BY book(l), stock(l)](b, s);
 <- Остаток на дату
 -> Balance as of date
[OK] currentBalance 'Текущий остаток' (Book b) = GROUP SUM currentBalance(b, Stock s);
 <- Текущий остаток
 -> Current balance

In samples/documentation/src/main/lsfusion/UseCaseTree.lsf of Category strings - Number of lines: 52; Number of occurances: 10

[OK] CLASS Category 'Категория';
 <- Категория
 -> Category
[OK] name 'Наименование' = DATA ISTRING[50] (Category);
 <- Наименование
 -> Name
[OK] CLASS Book 'Книга';
 <- Книга
 -> Book
[OK] name 'Наименование' = DATA ISTRING[50] (Book);
 <- Наименование
 -> Name
[OK] category 'Категория' = DATA Category (Book);
 <- Категория
 -> Category
[OK] FORM books 'Книги'
 <- Книги
 -> Books
[OK] parent 'Родитель' = DATA Category (Category);
 <- Родитель
 -> Parent
[OK] FORM categories 'Категории'
 <- Категории
 -> Categories
[OK] level 'Уровень' (Category child, Category parent) = RECURSION 1l IF child IS Category AND parent == child
 <- Уровень
 -> Level
[OK] FORM categoryBooks 'Книги по категориям'
 <- Книги по категориям
 -> Books by category

In samples/documentation/src/main/lsfusion/UseCaseTyping.lsf of Category strings - Number of lines: 15; Number of occurances: 3

[OK] CLASS Order 'Заказ';
 <- Заказ
 -> Order
[OK] CLASS OrderDetail 'Заказ';
 <- Заказ
 -> Order
[OK] CONSTRAINT sum(Order o) < 0 MESSAGE 'Сумма заказа должна быть положительной';
 <- Сумма заказа должна быть положительной
 -> The order amount must be positive

In samples/documentation/src/main/lsfusion/UseCaseWhile.lsf of Category strings - Number of lines: 86; Number of occurances: 17

[OK] CLASS Order 'Заказ';
 <- Заказ
 -> Order
[OK] date 'Дата' = DATA DATE (Order);
 <- Дата
 -> Date
[OK] messageCountOrders 'Посчитать кол-во заказов' (DATE dFrom, DATE dTo)  { 
 <- Посчитать кол-во заказов
 -> Count the number of orders
[OK]         MESSAGE 'Кол-во заказов за ' + date() + ' : ' + OVERRIDE countOrders(date()), 0.0;
 <- Кол-во заказов за ' + date() + ' : 
 -> Number of orders for ' + date () + ' : 
[OK]         MESSAGE 'Кол-во заказов за ' + date + ' : ' + OVERRIDE countOrders(date()), 0.0;
 <- Кол-во заказов за ' + date + ' : 
 -> Number of orders for ' + date + ' : 
[OK] CLASS OrderDetail 'Строка заказа';
 <- Строка заказа
 -> Order line
[OK] order 'Заказ' = DATA Order (OrderDetail) NONULL DELETE;
 <- Заказ
 -> Order
[OK] sum 'Сумма' = DATA NUMERIC[14,2] (OrderDetail);
 <- Сумма
 -> Amount
[OK] discountSum 'Сумма скидки' = DATA NUMERIC[14,2] (OrderDetail);
 <- Сумма скидки
 -> Discount amount
[OK] distributeDiscount 'Распределить скидку' (Order o, NUMERIC[14,2] discount)  { 
 <- Распределить скидку
 -> Distribute discount
[OK]         FOR OrderDetail d == [ GROUP LAST OrderDetail od ORDER leftSum(od), od BY order(od)](o) DO { // finding the row with the largest "remaining" amount
 <- оставшейся
 -> remaining
[OK] CLASS Book 'Книга';
 <- Книга
 -> Book
[OK] CLASS Ledger 'Изменение остатка';
 <- Изменение остатка
 -> Change balance
[OK] date 'Дата' = DATA DATE (Ledger);
 <- Дата
 -> Date
[OK] book 'Книга' = DATA Book (Ledger);
 <- Книга
 -> Book
[OK] quantity 'Кол-во' = DATA NUMERIC[14,2] (Ledger);
 <- Кол-во
 -> Qty
[OK]         MESSAGE 'Накопленный остаток по книге ' + b + ' : ' + cumBalance(b);
 <- Накопленный остаток по книге ' + b + ' : 
 -> Accumulated balance for book ' + b + ' : 
crowdout/strings/hockeystats/src (sources: crowdin/strings/hockeystats/src) -> samples/hockeystats/src - translated files:
crowdout/strings/hockeystats/src/main (sources: crowdin/strings/hockeystats/src/main) -> samples/hockeystats/src/main - translated files:

In samples/hockeystats/src/main/lsfusion/HockeyStats.lsf of Category strings - Number of lines: 152; Number of occurances: 31

[OK] CLASS Team 'Команда';
 <- Команда
 -> Team
[OK] name 'Название команды' = DATA STRING[30] (Team) IN base;
 <- Название команды
 -> Team name
[OK] CLASS Game 'Игра';
 <- Игра
 -> Game
[OK] date 'Дата' = DATA DATE (Game);
 <- Дата
 -> Date
[OK] hostTeamName 'Хозяева' (Game game) = name(hostTeam(game));
 <- Хозяева
 -> Hosts
[OK] guestTeamName 'Гости' (Game game) = name(guestTeam(game));
 <- Гости
 -> Guests
[OK] CONSTRAINT hostTeam(Game team) = guestTeam(team) CHECKED BY hostTeam, guestTeam MESSAGE 'Хозяйская и гостевая команды должны быть разными';
 <- Хозяйская и гостевая команды должны быть разными
 -> Host and guest teams must be different
[OK] hostGoals 'Х голы' = DATA INTEGER (Game);
 <- Х голы
 -> H goals
[OK] guestGoals 'Г голы' = DATA INTEGER (Game);
 <- Г голы
 -> G goals
[OK] CONSTRAINT hostGoals(Game game) = guestGoals(game) MESSAGE 'Игра не может закончиться вничью';
 <- Игра не может закончиться вничью
 -> The game cannot end in a draw
[OK] CLASS GameResult 'Р/И' {
 <- Р/И
 -> G/R
[OK]     win 'П',
 <- П
 -> W
[OK]     winOT 'ПО',
 <- ПО
 -> LO
[OK]     winSO 'ПБ'
 <- ПБ
 -> LB
[OK] resultName 'Имя' (GameResult game) = staticCaption(game) IF game IS GameResult IN base;
 <- Имя
 -> Name
[OK] resultName 'Р/И' (Game game) = resultName(result(game));
 <- Р/И
 -> G/R
[OK]     MESSAGE 'Результат игры определен автоматически';
 <- Результат игры определен автоматически
 -> The result of the game is determined automatically
[OK]     MESSAGE 'Укажите результат игры';
 <- Укажите результат игры
 -> Specify the result of the game
[OK] gamesPlayed 'И' (Team team) = hostGamesPlayed(team) (+) guestGamesPlayed(team);
 <- И
 -> G
[OK] gamesWon 'В' (Team team) = gamesWonBy(team, GameResult.win);
 <- В
 -> W
[OK] gamesWonOT 'ВО' (Team team) = gamesWonBy(team, GameResult.winOT);
 <- ВО
 -> WO
[OK] gamesWonSO 'ВБ' (Team team) = gamesWonBy(team, GameResult.winSO);
 <- ВБ
 -> WB
[OK] gamesLost 'П' (Team team) = gamesLostBy(team, GameResult.win);
 <- П
 -> L
[OK] gamesLostOT 'ПО' (Team team) = gamesLostBy(team, GameResult.winOT);
 <- ПО
 -> LO
[OK] gamesLostSO 'ПБ' (Team team) = gamesLostBy(team, GameResult.winSO);
 <- ПБ
 -> LB
[OK] points 'Очки' (Team team) = gamesWon(team) * 3 + (gamesWonSO(team) + gamesWonOT(team)) * 2 + gamesLostOT(team) + gamesLostSO(team);
 <- Очки
 -> Points
[OK] goalsScored 'Кол-во забитых голов' (Team team) = OVERRIDE hostGoalsScored(team) (+) guestGoalsScored(team), 0 IF team IS Team;
 <- Кол-во забитых голов
 -> Scored goals
[OK] goalsConceded 'Кол-во пропущенных голов' (Team team) = OVERRIDE hostGoalsConceded(team) (+) guestGoalsConceded(team), 0 IF team IS Team;
 <- Кол-во пропущенных голов
 -> Conceded goals
[OK] place 'Место' (Team team) = PARTITION SUM 1 ORDER DESC points(team), gamesWon(team), gamesWonOT(team), gamesWonSO(team),
 <- Место
 -> Rank
[OK] FORM MainForm 'Турнирная таблица'
 <- Турнирная таблица
 -> Score table
[OK] FORM MainFormSingle 'Турнирная таблица'
 <- Турнирная таблица
 -> Score table
crowdout/strings/euroleague/src/main/lsfusion (sources: crowdin/strings/euroleague/src/main/lsfusion) -> samples/euroleague/src/main/lsfusion - translated files:

In samples/euroleague/src/main/lsfusion/APIFootball.lsf of Category strings - Number of lines: 160; Number of occurances: 16

[OK] host = 'api-football-v1.p.rapidapi.com';
 <- api-football-v1.p.rapidapi.com
 -> api-football-v1.p.rapidapi.com
[OK] key 'Ключ к API Football' = DATA STRING () CHARWIDTH 50;
 <- Ключ к API Football
 -> Football API Key
[OK] url = 'https://' + host() + '/v2';
 <- https://' + host() + '/v2
 -> https://' + host() + '/v2
[OK]     WHEN name = 'x-rapidapi-host' THEN host()
 <- x-rapidapi-host
 -> x-rapidapi-host
[OK]     WHEN name = 'x-rapidapi-key' THEN key();
 <- x-rapidapi-key
 -> x-rapidapi-key
[OK] importLeagues 'Импортировать лиги' () {
 <- Импортировать лиги
 -> Import leagues
[OK]     EXTERNAL HTTP GET url() + '/leagues' HEADERS headers TO result;
 <- /leagues
 -> /leagues
[OK] importTeams 'Импортировать клубы' (League l) {
 <- Импортировать клубы
 -> Import clubs
[OK]     EXTERNAL HTTP GET url() + '/teams/league/' + id(l) HEADERS headers TO result;
 <- /teams/league/
 -> /teams/league/
[OK]                          homeTeamId IN homeTeam EXTID 'team_id',
 <- team_id
 -> team_id
[OK]                          awayTeamId IN awayTeam EXTID 'team_id',
 <- team_id
 -> team_id
[OK] importMatches 'Импортировать матчи' (League l) {
 <- Импортировать матчи
 -> Import matches
[OK]     EXTERNAL HTTP GET url() + '/fixtures/league/' + id(l) HEADERS headers TO result;
 <- /fixtures/league/
 -> /fixtures/league/
[OK]         MESSAGE 'Не найдена домашний клуб с кодом ' + id;
 <- Не найдена домашний клуб с кодом 
 -> No home club found with code 
[OK]         MESSAGE 'Не найдена гостевой клуб с кодом ' + id;
 <- Не найдена гостевой клуб с кодом 
 -> No guest club found with code 
[OK]         dateTime(m) <- toDateTimeFormat(left(dateTime(i),19), 'yyyy-MM-ddThh24:mi:ss');
 <- yyyy-MM-ddThh24:mi:ss
 -> yyyy-MM-ddThh24:mi:ss

In samples/euroleague/src/main/lsfusion/League.lsf of Category strings - Number of lines: 44; Number of occurances: 7

[OK] CLASS League 'Лига';
 <- Лига
 -> League
[OK] id 'Код' = DATA INTEGER (League);
 <- Код
 -> Code
[OK] nameTournament 'Турнир' (League l)= name(tournament(l));
 <- Турнир
 -> Tournament
[OK] nameSeason 'Сезон' (League l)= name(season(l));
 <- Сезон
 -> Season
[OK] FORM league 'Лига'
 <- Лига
 -> League
[OK] FORM leagues 'Лиги'
 <- Лиги
 -> Leagues
[OK] FORM dialogLeagues 'Лиги'
 <- Лиги
 -> Leagues

In samples/euroleague/src/main/lsfusion/Master.lsf of Category strings - Number of lines: 53; Number of occurances: 8

[OK]     id 'Код' = DATA INTEGER (###object);
 <- Код
 -> Code
[OK]     name 'Имя' = DATA ISTRING (###object) CHARWIDTH nameLength;
 <- Имя
 -> Name
[OK] @defineMasterObject(tournament, 'Турнир', 'Турниры', 20);
 <- Турнир', 'Турниры
 -> Tournament', 'Tournaments
[OK] @defineMasterObject(season, 'Сезон', 'Сезоны', 5);
 <- Сезон', 'Сезоны
 -> Season', 'Seasons
[OK] @defineMasterObject(round, 'Раунд', 'Раунды', 15);
 <- Раунд', 'Раунды
 -> Round', 'Rounds
[OK] @defineMasterObject(country, 'Страна', 'Страны', 10);
 <- Страна', 'Страны
 -> Country', 'Countries
[OK] @defineMasterObject(team, 'Клуб', 'Клубы', 20);
 <- Клуб', 'Клубы
 -> Club', 'Clubs
[OK] nameCountry 'Страна' (Team t) = name(country(t));
 <- Страна
 -> Country

In samples/euroleague/src/main/lsfusion/Match.lsf of Category strings - Number of lines: 57; Number of occurances: 12

[OK] CLASS Match 'Матч';
 <- Матч
 -> Match
[OK] id 'Код' = DATA INTEGER (Match);
 <- Код
 -> Code
[OK] dateTime 'Время' = DATA DATETIME (Match);  
 <- Время
 -> Time
[OK] nameTournament 'Турнир' (Match m) = name(tournament(m));  
 <- Турнир
 -> Tournament
[OK] nameSeason 'Сезон' (Match m) = name(season(m));  
 <- Сезон
 -> Season
[OK] nameRound 'Раунд' (Match m) = name(round(m));
 <- Раунд
 -> Round
[OK] nameHomeTeam 'Хозяева' (Match m) = name(homeTeam(m));
 <- Хозяева
 -> Hosts
[OK] nameAwayTeam 'Гости' (Match m) = name(awayTeam(m));
 <- Гости
 -> Guests
[OK] goalsHome 'Голы (хозяева)' = DATA INTEGER (Match);
 <- Голы (хозяева)
 -> Goals (hosts)
[OK] goalsAway 'Голы (гости)' = DATA INTEGER (Match);
 <- Голы (гости)
 -> Goals (guests)
[OK] FORM match 'Матч'
 <- Матч
 -> Match
[OK] FORM matches 'Матчи'
 <- Матчи
 -> Matches

In samples/euroleague/src/main/lsfusion/UEFA.lsf of Category strings - Number of lines: 95; Number of occurances: 19

[OK] isCL (Tournament t) = name(t) = 'Champions League';
 <- Champions League
 -> Champions League
[OK] isEL (Tournament t) = name(t) = 'Europa League';
 <- Europa League
 -> Europa League
[OK] matchCoeff 'Коэффициент матчей' (Round r) = OVERRIDE dataMatchCoeff(r), 1.0;
 <- Коэффициент матчей
 -> Match odds
[OK] wonPoints 'Очки за победы' (Season s, Team t) = 
 <- Очки за победы
 -> Points for victories
[OK] drawPoints 'Очки за ничью' (Season s, Team t) = 
 <- Очки за ничью
 -> Points for a draw
[OK] matchPoints 'Очки за матчи' (Season s, Team t) = wonPoints(s, t) (+) drawPoints(s, t) MATERIALIZED;
 <- Очки за матчи
 -> Points for matches
[OK] played 'Играл' (Season s, Tournament t, Round r, Team tm) = 
 <- Играл
 -> Played
[OK] bonusPoints 'Бонус за проход' = DATA NUMERIC[10,1] (Tournament, Round);
 <- Бонус за проход
 -> Pass bonus
[OK] bonusPoints 'Бонусные очки' (Season s, Team tm) = GROUP SUM bonusPoints(Tournament t, Round r) IF played(s, t, r, tm) MATERIALIZED;
 <- Бонусные очки
 -> Bonus points
[OK] points 'Очки' (Season s, Team tm) = matchPoints(s, tm) (+) bonusPoints(s, tm);
 <- Очки
 -> Points
[OK] matchesUL 'Матчей в еврокубках' (Season s, Team t) = GROUP SUM 1 IF played(t, Match m) AND season(m) = s AND isUL(m);
 <- Матчей в еврокубках
 -> Matches in European competition
[OK] teams 'Клубов' (Season s, Country c) = GROUP SUM 1 IF matchesUL(s, Team t) AND country(t) = c;
 <- Клубов
 -> Clubs
[OK] totalPoints 'Очки (всего)' (Season s, Country c) = GROUP SUM points(s, Team t) IF country(t) = c;
 <- Очки (всего)
 -> Points (total)
[OK] points 'Очки' (Season s, Country c) = trunc(NUMERIC[13,4](totalPoints(s, c)) / teams(s, c), 3);
 <- Очки
 -> Points
[OK] index 'Индекс' (Season s) = PARTITION SUM 1 IF s IS Season ORDER DESC s;
 <- Индекс
 -> Index
[OK] rating 'Рейтинг' (Country c) = GROUP SUM points(Season s, c) IF index(s) <= 5;
 <- Рейтинг
 -> Rating
[OK] FORM countryCoefficientUEFA 'Коэффициент стран UEFA'
 <- Коэффициент стран UEFA
 -> UEFA country odds
[OK]     PROPERTIES(s, c) COLUMNS (s) points HEADER 'Очки : ' + name(s), teams HEADER 'Клубы : ' + name(s)
 <- Очки : ' + name(s), teams HEADER 'Клубы : 
 -> Points: ' + name(s), teams HEADER 'Clubs: 
[OK]         FILTER 'По стране' country(t) = c DEFAULT
 <- По стране
 -> By country
crowdout/strings/features/src (sources: crowdin/strings/features/src) -> samples/features/src - translated files:
crowdout/strings/features/src/main (sources: crowdin/strings/features/src/main) -> samples/features/src/main - translated files:
crowdout/strings/features/src/main/lsfusion (sources: crowdin/strings/features/src/main/lsfusion) -> samples/features/src/main/lsfusion - translated files:

In samples/features/src/main/lsfusion/FeaturesScript.lsf of Category strings - Number of lines: 3519; Number of occurances: 513

[OK] // GROUP name ['caption'] [: parentGroup];
 <- caption
 -> caption
[OK] GROUP base 'Основная группа' : System.base;
 <- Основная группа
 -> Main group
[OK] // CLASS [ABSTRACT] name ['caption']
 <- caption
 -> caption
[OK] //      instanceName1 ['instanceCaption1'],
 <- instanceCaption1
 -> instanceCaption1
[OK] //      instanceNameN ['instanceCaptionN']
 <- instanceCaptionN
 -> instanceCaptionN
[OK] CLASS ABSTRACT Named 'Объект с именем' ;
 <- Объект с именем
 -> Object named
[OK] CLASS Article 'Товар' : Named;
 <- Товар
 -> Product
[OK] CLASS ArticleGroup 'Группа товаров' : Named;
 <- Группа товаров
 -> Product group
[OK] CLASS Store 'Склад' : Named;
 <- Склад
 -> Warehouse
[OK] CLASS SubStore 'СубСклад' : Store;
 <- СубСклад
 -> SubWarehouse
[OK] CLASS ABSTRACT Document 'Документ';
 <- Документ
 -> Document
[OK] CLASS IncomeDocument 'Приход' : Document;
 <- Приход
 -> Income
[OK] CLASS OutcomeDocument 'Расход' : Document, EmptyClass;
 <- Расход
 -> Expenses
[OK] CONSTRAINT name(Named o) = '-TEST-' MESSAGE 'STRANGE NAME';
 <- -TEST-' MESSAGE 'STRANGE NAME
 -> -TEST-' MESSAGE 'STRANGE NAME
[OK] nameParent 'Родительский объект' = nameArticle(parent(ArticleGroup articleGroup)) IN base;
 <- Родительский объект
 -> Parent object
[OK] level 'Уровень' (ArticleGroup child, ArticleGroup parent) = RECURSION 1l IF child IS ArticleGroup AND parent = child
 <- Уровень
 -> Level
[OK] levelRoot 'Уровень' (ArticleGroup child, ArticleGroup parent) = PARTITION SUM 1 IF level(child, parent)
 <- Уровень
 -> Level
[OK] isParent 'Является потомком' (ArticleGroup child, ArticleGroup parent) = TRUE IF level(child, parent);
 <- Является потомком
 -> Descendant of
[OK] childNumber 'Кол-во непосредственных потомков' (articleGroup) = GROUP SUM 1 BY parent(ArticleGroup child) MATERIALIZED;
 <- Кол-во непосредственных потомков
 -> Number of children
[OK] descendantNumber 'Кол-во всех потомков' (ArticleGroup parent) = GROUP SUM 1 IF isParent(ArticleGroup child, parent) MATERIALIZED;
 <- Кол-во всех потомков
 -> Number of all descendants
[OK] isLeaf 'Лист' (ArticleGroup articleGroup) = articleGroup IS ArticleGroup AND NOT childNumber(articleGroup) MATERIALIZED;
 <- Лист
 -> Sheet
[OK] canonicalName 'Полное имя' (ArticleGroup articleGroup) = STRING[255](
 <- Полное имя
 -> Full name
[OK]                        (GROUP CONCAT nameArticle(ArticleGroup parent), ' / ' ORDER DESC level(articleGroup, parent)))
 <-  / 
 ->  / 
[OK] WHEN LOCAL Article a IS Article DO name(a) <- 'Товар ' + INTEGER(a);
 <- Товар 
 -> Product 
[OK] WHEN LOCAL ArticleGroup a IS ArticleGroup DO name(a) <- 'Группа товаров ' + INTEGER(a);
 <- Группа товаров 
 -> Product group 
[OK] WHEN LOCAL Store s IS Store DO name(s) <- 'Склад ' + INTEGER(s);
 <- Склад 
 -> Warehouse 
[OK] CLASS StoreSize 'Размер склада' {} : Named;
 <- Размер склада
 -> Warehouse size
[OK]     huge 'огромный',
 <- огромный
 -> huge
[OK]     big 'большой'
 <- большой
 -> big
[OK] //      instanceName1 ['instanceCaption1']
 <- instanceCaption1
 -> instanceCaption1
[OK] //      instanceNameN ['instanceCaptionN']
 <- instanceCaptionN
 -> instanceCaptionN
[OK]     medium 'средний',
 <- средний
 -> medium
[OK]     small 'маленький'
 <- маленький
 -> small
[OK] // name ['caption'] [(namedParam1, ..., namedParamN)] = propertyExpression [IN group] [MATERIALIZED] [TABLE <table name>]
 <- caption
 -> caption
[OK] //                                                                                                 [IMAGE 'name'] [CHANGEKEY '<key code>' [SHOW | HIDE]] [AUTOSET] [CONFIRM]
 <- name'] [CHANGEKEY '<key code>
 -> name'] [CHANGEKEY '<key code>
[OK] //                                                                                                 [REGEXP '<expression>' ['<regExp message>']] [LOGGABLE] [ECHO] [INDEXED]
 <- <expression>' ['<regExp message>
 -> <expression>' ['<regExp message>
[OK] //                                                                                                 [EVENTID 'id'];
 <- id
 -> id
[OK] stime 'Время' (store) = DATA TIME (Store) IN base;
 <- Время
 -> Time
[OK] sdate 'Дата' (store) = DATA DATE (Store) IN base;
 <- Дата
 -> Date
[OK] sdatetime 'ДатаВремя' (store) = DATA DATETIME (Store) IN base;
 <- ДатаВремя
 -> DateTime
[OK] sword 'Word' (store) = DATA WORDFILE (Store) IN base;
 <- Word
 -> Word
[OK] simage 'Image' (store) = DATA IMAGEFILE (Store) IN base;
 <- Image
 -> Image
[OK] spdf 'PDF' (store) = DATA PDFFILE (Store) IN base;
 <- PDF
 -> PDF
[OK] scustom 'Custom file' (store) = DATA FILE (Store) IN base;
 <- Custom file
 -> Custom file
[OK] sexcel 'Excel' (store) = DATA EXCELFILE (Store) IN base;
 <- Excel
 -> Excel
[OK] scolor 'Color' (store) = DATA COLOR (Store) IN base;
 <- Color
 -> Color
[OK] sinteger 'Integer' (store) = DATA INTEGER (Store);
 <- Integer
 -> Integer
[OK] slong 'Long' (store) = DATA LONG (Store);
 <- Long
 -> Long
[OK] sdouble 'Double' (store) = DATA DOUBLE (Store);
 <- Double
 -> Double
[OK] snumeric 'Numeric' (store) = DATA NUMERIC[14,3] (Store);
 <- Numeric
 -> Numeric
[OK] sboolean 'Boolean' (store) = DATA BOOLEAN (Store);
 <- Boolean
 -> Boolean
[OK] stext 'Text' (store) = DATA TEXT (Store);
 <- Text
 -> Text
[OK] srichtext 'RichText' (store) = DATA RICHTEXT (Store);
 <- RichText
 -> RichText
[OK] srawrichtext 'RawRichText' (Store store) = TEXT(srichtext(store));
 <- RawRichText
 -> RawRichText
[OK] sbpstring 'BPString' (store) = DATA BPSTRING[300] (Store);
 <- BPString
 -> BPString
[OK] sstring 'String (no rtrim)' (store) = DATA STRING[300] (Store);
 <- String (no rtrim)
 -> String (no rtrim)
[OK] ssinteger 'Session Integer' (store) = DATA LOCAL INTEGER (Store);
 <- Session Integer
 -> Session Integer
[OK] sslong 'Session Long' (store) = DATA LOCAL LONG (Store);
 <- Session Long
 -> Session Long
[OK] ssdouble 'Session Double' (store) = DATA LOCAL DOUBLE (Store);
 <- Session Double
 -> Session Double
[OK] ssboolean 'Session Boolean' (store) = DATA LOCAL BOOLEAN (Store);
 <- Session Boolean
 -> Session Boolean
[OK] sstext 'Session Text' (store) = DATA LOCAL TEXT (Store);
 <- Session Text
 -> Session Text
[OK] ssrichtext 'Session RichText' (store) = DATA LOCAL RICHTEXT (Store);
 <- Session RichText
 -> Session RichText
[OK] ssrawrichtext 'Session RawRichText' (Store store) = TEXT(srichtext(store));
 <- Session RawRichText
 -> Session RawRichText
[OK] ssbpstring 'Session BPString' (store) = DATA LOCAL BPSTRING[300] (Store);
 <- Session BPString
 -> Session BPString
[OK] ssstring 'Session String (no rtrim)' (store) = DATA LOCAL STRING[300] (Store);
 <- Session String (no rtrim)
 -> Session String (no rtrim)
[OK] ainteger 'Integer' (article) = DATA INTEGER (Article);
 <- Integer
 -> Integer
[OK] along 'Long' (article) = DATA LONG (Article);
 <- Long
 -> Long
[OK] aboolean 'Boolean' (article) = DATA BOOLEAN (Article);
 <- Boolean
 -> Boolean
[OK] aginteger 'Integer' (articleGroup) = DATA INTEGER (ArticleGroup);
 <- Integer
 -> Integer
[OK] barcode 'Штрихкод' (article) = DATA BPSTRING[15] (Article);
 <- Штрихкод
 -> Barcode
[OK] // [JOIN] (name | '[' propertyDefinition ']') (param1, ..., paramN)
 <- [' propertyDefinition ']
 -> [' propertyDefinition ']
[OK] storeName 'Склад' (Document document) = JOIN name(store(document)) IN base;
 <- Склад
 -> Warehouse
[OK] storeSizeName = staticCaption(storeSize(Store store)) IN base; // we can omit named parameters to the left of '=', but still use them
 <- =
 -> =
[OK] lastQuantity 'lastQ' (store, Article article) = GROUP LAST inQuantity(IncomeDocument d, article) ORDER oq(d,article), date(d) WHERE inQuantity(d, article) > 5 BY store(d);
 <- lastQ
 -> lastQ
[OK] allNames() = GROUP CONCAT name(Named obj) IF obj IS Named, ', ' ORDER DESC name(obj);
 <- , 
 -> , 
[OK] documentTypeString 'Тип документа' (Document doc) = IF doc IS IncomeDocument
 <- Тип документа
 -> Document type
[OK]                                                 THEN 'Приход'
 <- Приход
 -> Income
[OK]                                                 ELSE 'Расход' IF doc IS OutcomeDocument;
 <- Расход
 -> Expenses
[OK] sizeCode 'Размер склада (код)' (StoreSize ss) = CASE
 <- Размер склада (код)
 -> Warehouse size (code)
[OK]                                           WHEN ss = StoreSize.huge THEN 'HUGE'
 <- HUGE
 -> HUGE
[OK]                                           WHEN ss = StoreSize.big THEN 'BIG'
 <- BIG
 -> BIG
[OK]                                           WHEN ss = StoreSize.medium THEN 'MEDIUM'
 <- MEDIUM
 -> MEDIUM
[OK]                                           WHEN ss = StoreSize.small THEN 'SMALL'
 <- SMALL
 -> SMALL
[OK] overrideTest 'OVERRIDE' (a) = OVERRIDE caseData3(a), caseData2(a), caseData1(a);
 <- OVERRIDE
 -> OVERRIDE
[OK] exclusiveTest 'EXCLUSIVE' (a) = EXCLUSIVE caseData3(a), caseData2(a), caseData1(a);
 <- EXCLUSIVE
 -> EXCLUSIVE
[OK] overrideTestA 'OVERRIDE A' = ABSTRACT VALUE INTEGER (CaseA);
 <- OVERRIDE A
 -> OVERRIDE A
[OK] exclusiveTestA 'EXCLUSIVE A' = ABSTRACT VALUE EXCLUSIVE INTEGER (CaseA);
 <- EXCLUSIVE A
 -> EXCLUSIVE A
[OK] multiTest 'MULTI' (a) = MULTI caseDataB(a), caseDataC(a);
 <- MULTI
 -> MULTI
[OK] multiTest2 'MULTI OVER' (a) = MULTI OVERRIDE caseData1(a), caseData2(a);
 <- MULTI OVER
 -> MULTI OVER
[OK] 	                        WHEN testInt(a) > 7 THEN { MESSAGE '>7'; }
 <- >7
 -> >7
[OK] 	                        WHEN testInt(a) > 6 THEN { MESSAGE '>6'; }
 <- >6
 -> >6
[OK] 	                        WHEN testInt(a) > 5 THEN { MESSAGE '>5'; }
 <- >5
 -> >5
[OK] 	                        WHEN testInt(a) > 7 THEN { MESSAGE '>7'; }
 <- >7
 -> >7
[OK] 	                        WHEN testInt(a) > 6 THEN { MESSAGE '>6'; }
 <- >6
 -> >6
[OK] 	                        WHEN testInt(a) > 5 THEN { MESSAGE '>5'; }
 <- >5
 -> >5
[OK] caseActionTestA(a) + WHEN testInt(a) > 7 THEN {  MESSAGE '>7'; } 
 <- >7
 -> >7
[OK] caseActionTestA(a) + WHEN testInt(a) > 6 THEN {  MESSAGE '>6'; } 
 <- >6
 -> >6
[OK] caseActionTestA(a) + WHEN testInt(a) > 5 THEN {  MESSAGE '>5'; } 
 <- >5
 -> >5
[OK] caseActionTestA(a) + WHEN testInt(a) > 6 THEN {  MESSAGE '>6'; }
 <- >6
 -> >6
[OK] caseActionTestA(a) + WHEN testInt(a) = 6 THEN {  MESSAGE '=6'; }
 <- =6
 -> =6
[OK] caseActionTestA(a) + WHEN testInt(a) < 6 THEN {  MESSAGE '<6'; }
 <- <6
 -> <6
[OK] caseAM()  { FOR IF scase() THEN TEXT s = '{classes.image}' ELSE s = '{classes.image.link}' DO MESSAGE s; };
 <- {classes.image}' ELSE s = '{classes.image.link}
 -> {classes.image}' ELSE s = '{classes.image.link}
[OK] caseAMN  { MESSAGE 'Hello world!' NOWAIT; }
 <- Hello world!
 -> Hello world!
[OK] FORM TestCase 'Тест CASE'
 <- Тест CASE
 -> CASE test
[OK] storeSizeCode 'Размер склада (код)' (Store s) = sizeCode(storeSize(s)) CHARWIDTH 50;
 <- Размер склада (код)
 -> Warehouse size (code)
[OK] onlyIncomeQuantity 'Test STRUCT' (Store store, Article article) = ioQuantity(store, article)[1];
 <- Test STRUCT
 -> Test STRUCT
[OK] testAbstractAction(Store store) + {  IF store IS Store THEN MESSAGE 'testing store'; }
 <- testing store
 -> testing store
[OK] testAbstractAction(Store store) + {  IF store IS Store THEN MESSAGE 'testing store2'; }
 <- testing store2
 -> testing store2
[OK] testAbstractAction(Document document) + {  IF document IS Document THEN MESSAGE 'testing document'; }
 <- testing document
 -> testing document
[OK] testAbstractAction(Document document) + {  IF document IS Document THEN MESSAGE 'testing document2'; }
 <- testing document2
 -> testing document2
[OK] // FORMULA [primitiveType] 'formula text $1 + $2'
 <- formula text $1 + $2
 -> formula text $1 + $2
[OK] sum12 = FORMULA DOUBLE '($1)+($2)*2';
 <- ($1)+($2)*2
 -> ($1)+($2)*2
[OK] // Instances: 5, 5L, 6.35, 6.35d, TRUE, 'some string', class.object, 2011_10_25, 2011_10_25_18:00, 18:00, NULL, #ff0000, RGB(255, 0, 0)
 <- some string
 -> some string
[OK] // if not - one should do 'EXEC apply();' explicitly.
 <- EXEC apply();
 -> EXEC apply();
[OK] // INTERNAL 'javaClassName'
 <- javaClassName
 -> javaClassName
[OK] changeWhenCount 'countCCB > 5' (a, CCB b)  { CHANGECLASS a TO CCB WHERE count(b) > 5; }
 <- countCCB > 5
 -> countCCB > 5
[OK] changeWhenCountAB 'countCCACCB > 5' (CCA a, CCB b)  { CHANGECLASS a TO CCB WHERE countCCACCB(a, b) > 5; }
 <- countCCACCB > 5
 -> countCCACCB > 5
[OK] changeAllA 'all where CCA > 5' ()  { CHANGECLASS CCA a TO CCB WHERE count(a) > 5; }
 <- all where CCA > 5
 -> all where CCA > 5
[OK] deleteA 'delete A > 5' ()  { DELETE CCA a WHERE count(a) > 5; }
 <- delete A > 5
 -> delete A > 5
[OK] changeAllAWhenCountAB 'all count CCACCB > 5' (CCB b)  { CHANGECLASS CCA a TO CCB WHERE countCCACCB(a, b) > 5; }
 <- all count CCACCB > 5
 -> all count CCACCB > 5
[OK] changeAllAWhenCount 'all count CCB > 5' (CCB b)  { CHANGECLASS CCA a TO CCB WHERE count(b) > 5 AND a IS CCA; }
 <- all count CCB > 5
 -> all count CCB > 5
[OK] FORM TestEvalActionForm 'Тест скриптов'
 <- Тест скриптов
 -> Scripts test
[OK] copyNameToArticles 'Скопировать имя склада в имена артиклей' (Store s)  { 
 <- Скопировать имя склада в имена артиклей
 -> Copy warehouse name to article names
[OK] copyStoreNameToArticle 'Добавить имя склада к имени артикля' (Named s, Named a)  { 
 <- Добавить имя склада к имени артикля
 -> Add warehouse name to article name
[OK] copyStoreNameToArticleError 'Скопировать имя склада в имя артикля (с ошибкой)' (Named s, Named a)  { 
 <- Скопировать имя склада в имя артикля (с ошибкой)
 -> Copy warehouse name to article name (with error)
[OK] createNewStore '{addhugestore}' ()  { 
 <- {addhugestore}
 -> {addhugestore}
[OK]     name(Named k) <- 'New store ' + sessionObj() WHERE k == sessionObj() ;
 <- New store 
 -> New store 
[OK] } TOOLBAR IMAGE 'add.png';
 <- add.png
 -> add.png
[OK]         name(article) <- 'More then 3';
 <- More then 3
 -> More then 3
[OK]     MESSAGE 'I= ' + i();
 <- I= 
 -> I= 
[OK]         name(article) <- 'Article ' + quantity(document2, article);
 <- Article 
 -> Article 
[OK]         name(Named article) <- 'NEW' IF article IS Article IF document IS IncomeDocument;
 <- NEW
 -> NEW
[OK]         name(article) <- 'Changed';
 <- Changed
 -> Changed
[OK]     MESSAGE 'I= ' + i();
 <- I= 
 -> I= 
[OK]     READ 'file://c:/sprgrm.dbf' TO importFile;
 <- file://c:/sprgrm.dbf
 -> file://c:/sprgrm.dbf
[OK]     READ 'file:///c:/sprgrm.fpt' TO memoFile;
 <- file:///c:/sprgrm.fpt
 -> file:///c:/sprgrm.fpt
[OK] FORM TestImport 'Тест IMPORT' 
 <- Тест IMPORT
 -> IMPORT test
[OK] // CONSTRAINT propertyExpression [CHECKED [BY propertyName1, ..., propertyNameN]] propertyExpression MESSAGE 'message';
 <- message
 -> message
[OK] CONSTRAINT foo(store, article) > 1000 CHECKED MESSAGE 'ошибка: >1000';
 <- ошибка: >1000
 -> error: >1000
[OK] BEFORE constraintAction(store, article) DO MESSAGE 'Before Aspect';
 <- Before Aspect
 -> Before Aspect
[OK]     MESSAGE 'changes were canceled';
 <- changes were canceled
 -> changes were canceled
[OK]     MESSAGE 'form apply message';
 <- form apply message
 -> form apply message
[OK]     MESSAGE 'Now closing...';
 <- Now closing...
 -> Now closing...
[OK] // FORM name ['caption'] [DOCKED | FLOAT] | EXTEND FORM name
 <- caption
 -> caption
[OK] FORM documentArticle 'По документам (caption)' 
 <- По документам (caption)
 -> By documents (caption)
[OK] // [alias=] className ['<caption>'] [ON CHANGE action]
 <- <caption>
 -> <caption>
[OK] // TREE [SID] [alias=] className ['<caption>'] [PARENT <property>] | [groupAlias=] (object1 definition, ..., objectN definition) [PARENT <properties separated with space>],
 <- <caption>
 -> <caption>
[OK] //            [alias=] className ['<caption>'] [PARENT <property>] | [groupAlias=] (object1 definition, ..., objectN definition) [PARENT <properties separated with space>]
 <- <caption>
 -> <caption>
[OK] //                     [FOREGROUND <mappedProperty>] [ON (CHANGE | CHANGEWYS | CONTEXTMENU | EDIT) <mappedAction>] [(BEFORE | AFTER) (propertyAlias | <mappedProperty>)] [EVENTID 'id']
 <- id
 -> id
[OK] showDocumentArticleModalForm 'Показать модальную "По документам"'()  { 
 <- Показать модальную "По документам"
 -> Show modal "By documents"
[OK] 	        name[Named](k) <- 'this is new article';
 <- this is new article
 -> this is new article
[OK] 	        MESSAGE 'Object wasnt added';
 <- Object wasnt added
 -> Object wasn't added
[OK] 	        MESSAGE 'You pressed "ok"';
 <- You pressed "ok"
 -> You pressed "ok"
[OK] 	        MESSAGE 'You have choosen article ' + name(article) + ' and store ' + name(store(document));
 <- You have choosen article ' + name(article) + ' and store 
 -> You have chosen article ' + name(article) + ' and store 
[OK] 	            name[Named](k) <- 'THIS article was chosen in modal form';
 <- THIS article was chosen in modal form
 -> THIS article was chosen in modal form
[OK] 	            name(k) <- 'Document for THIS store was chosen in modal form';
 <- Document for THIS store was chosen in modal form
 -> Document for THIS store was chosen in modal form
[OK] testAction 'Показать "По документам" 3 раза'()  { 
 <- Показать "По документам" 3 раза
 -> Show "By documents" 3 times
[OK]             MESSAGE 'You pressed "ok"';
 <- You pressed "ok"
 -> You pressed "ok"
[OK] //            MESSAGE 'You pressed "close"';
 <- You pressed "close"
 -> You pressed "close"
[OK] FORM testModalForm 'Тестовая форма'
 <- Тестовая форма
 -> Test form
[OK]     OBJECTS article=Article, i 'Новое имя товара ("Товар %N%"):' =INTEGER PANEL, store=Store, s 'Новое имя склада:' =STRING[50] PANEL
 <- Новое имя товара ("Товар %N%"):' =INTEGER PANEL, store=Store, s 'Новое имя склада:
 -> New product name ("Product %N%"):' =INTEGER PANEL, store=Store, s 'New warehouse name:
[OK] showTestModalForm 'Показать док-модальную форму (влож. сессия)'()  { 
 <- Показать док-модальную форму (влож. сессия)
 -> Show doc modal form (nested session)
[OK]             name(Named k) <- 'Товар ' + i WHERE k == article;
 <- Товар 
 -> Product 
[OK] setDefaultNames 'Задать имена по умолчанию' ()  { 
 <- Задать имена по умолчанию
 -> Set default names
[OK]         name(s) <- 'Склад '  + s;
 <- Склад 
 -> Warehouse 
[OK]         name(a) <- 'Товар ' + a;
 <- Товар 
 -> Product 
[OK] //        staticCaption(s) <- 'Warehouse ' + s;
 <- Склад 
 -> Warehouse 
[OK] //        staticCaption(a) <- 'Product ' + a;
 <- Товар 
 -> Product 
[OK] name(Store s) <- 'Склад ' + s WHEN SET(s IS Store);
 <- Склад 
 -> Warehouse 
[OK] //staticCaption(Store s) <- 'Warehouse ' + s WHEN SET(s IS Store);
 <- Склад 
 -> Warehouse 
[OK] FORM remindUserPass 'Напоминание логина'
 <- Напоминание логина
 -> Login reminder
[OK] remindPasswordEmail 'Выслать логин на этот email' (Contact u, BPSTRING[200] to)  {
 <- Выслать логин на этот email
 -> Send login to this email
[OK] //    FROM 'luxsoft@adsl.by'
 <- luxsoft@adsl.by
 -> luxsoft@adsl.by
[OK]     SUBJECT 'Напоминание пароля для ' + email(u)
 <- Напоминание пароля для 
 -> Password reminder for 
[OK]     CC 'some@someserv.net'
 <- some@someserv.net
 -> some@someserv.net
[OK] //    BCC 'luxsoft@adsl.by'
 <- luxsoft@adsl.by
 -> luxsoft@adsl.by
[OK]     ATTACH attachFile() NAME 'ATTACH: Напоминание пароля для ' + email(u)
 <- ATTACH: Напоминание пароля для 
 -> ATTACH: Password reminder for 
[OK] justSendEmail 'Просто выслать емэйл'  (BPSTRING[200] to)  { EMAIL
 <- Просто выслать емэйл
 -> Just send an email
[OK]     SUBJECT 'Тема письма'
 <- Тема письма
 -> Letter subject
[OK]     BODY '<font color=#FF0000 size=+3>big red text</font>'; }
 <- <font color=#FF0000 size=+3>big red text</font>
 -> <font color=#FF0000 size=+3>big red text</font>
[OK] FORM TestEmailForm 'Тест EMAIL'
 <- Тест EMAIL
 -> EMAIL test
[OK]     OBJECTS s 'Email:' =STRING[100] PANEL, u=CustomUser
 <- Email:
 -> Email:
[OK] testRequestInput 'Тестирование REQUEST input'(Store s)  { 
 <- Тестирование REQUEST input
 -> Testing REQUEST input
[OK]     ASK 'Быть или не быть?' DO {
 <- Быть или не быть?
 -> To be or not to be?
[OK] //countF 'Number of filtered warehouses' = GROUP SUM 1 IF fs(s);
 <- Кол-во фильтр. складов
 -> Number of filtered warehouses
[OK] //setNameX 'Add X to name' = () {
 <- Добавить X к имени
 -> Add X to name
[OK] //        name(s) <- 'X' + name(s);
 <- X
 -> X
[OK] FORM storeArticle 'По складам'
 <- По складам
 -> By warehouses
[OK]         FILTER '{showhuge}' storeIsHuge(s) 'F10'
 <- {showhuge}' storeIsHuge(s) 'F10
 -> {showhuge}' storeIsHuge(s) 'F10
[OK] FORM TestSeek 'Тест SEEK' 
 <- Тест SEEK
 -> SEEK test
[OK] countF 'Кол-во фильтр. складов' = GROUP SUM 1 IF [ VIEW storeArticle.s](Store s);
 <- Кол-во фильтр. складов
 -> Number of filtered warehouses
[OK] orderF 'Порядок в группе объектов' (Store s) = PARTITION SUM 1 IF [ FILTER storeArticle.s](s) ORDER [ ORDER storeArticle.s](s), s;
 <- Порядок в группе объектов
 -> Order in an object group
[OK] setNameX 'Добавить X к имени'()  { 
 <- Добавить X к имени
 -> Add X to name
[OK]         name(s) <- 'X' + k() + name(s);
 <- X
 -> X
[OK] //    name(s) <- 'U' + name(s);
 <- U
 -> U
[OK] seekX 'Seek object'()  { 
 <- Seek object
 -> Seek object
[OK] seekLC 'Seek object s Last' ()  { 
 <- Seek object s Last
 -> Seek object s Last
[OK] seekFC 'Seek object s First'()  { 
 <- Seek object s First
 -> Seek object s First
[OK] seekGFC 'Seek group (s, a) First' ()  { 
 <- Seek group (s, a) First
 -> Seek group (s, a) First
[OK] seekPart 'Seek Part s Last' ()  { 
 <- Seek Part s Last
 -> Seek Part s Last
[OK] seekPartF 'Seek Part a First' ()  { 
 <- Seek Part a First
 -> Seek Part a First
[OK]     caption = 'Главный контейнер';
 <- Главный контейнер
 -> Main container
[OK]     imagePath = 'add.png';
 <- add.png
 -> add.png
[OK]     PROPERTY(storeSizeName(s)) { caption = 'Имя размера склада'; }
 <- Имя размера склада
 -> Warehouse size name
[OK] //        font = '"Times New Roman" bold 36';
 <- "Times New Roman" bold 36
 -> "Times New Roman" bold 36
[OK] //        font = '';
 <- 
 -> 
[OK] //        font = '5';
 <- 5
 -> 5
[OK] //        fontStyle = 'bold';
 <- bold
 -> bold
[OK] //        font = 'Tahoma 36';
 <- Tahoma 36
 -> Tahoma 36
[OK]     captionFont = 'bold 32';
 <- bold 32
 -> bold 32
[OK]         imagePath = 'add.png';   
 <- add.png
 -> add.png
[OK]         font = 'bold 16';
 <- bold 16
 -> bold 16
[OK]         askConfirmMessage = 'ORLY?';
 <- ORLY?
 -> ORLY?
[OK]         imagePath = 'add.png';
 <- add.png
 -> add.png
[OK]         font = 'bold 16';
 <- bold 16
 -> bold 16
[OK]         captionFont = 'bold 16';
 <- bold 16
 -> bold 16
[OK]         imagePath = 'add.png';
 <- add.png
 -> add.png
[OK]         captionFont = 'bold 16';
 <- bold 16
 -> bold 16
[OK]         font = 'bold 16';
 <- bold 16
 -> bold 16
[OK]         imagePath = 'add.png';
 <- add.png
 -> add.png
[OK]         captionFont = 'bold 16';
 <- bold 16
 -> bold 16
[OK]         font = 'bold 16';
 <- bold 16
 -> bold 16
[OK]         caption = '!!!';
 <- !!!
 -> !!!
[OK]         font = 'bold';
 <- bold
 -> bold
[OK] FORM editStore 'Редактирование склада'
 <- Редактирование склада
 -> Editing warehouse
[OK] FORM editArticleGroup 'Редактирование группы товаров'
 <- Редактирование группы товаров
 -> Editing a product group
[OK] teststring(Store store) = '\n\'\\ghhgh\\"' AND store IS Store;
 <- \n\'\\ghhgh\\"
 -> \n\'\\ghhgh\\"
[OK] FORM TestDataPropForm 'Тест дат'
 <- Тест дат
 -> Date test
[OK] storeHeader (StoreSize ss) = 'storeSize: ' + sizeCode(ss);
 <- storeSize: 
 -> storeSize: 
[OK] FORM TestColumnGroupObjects 'Тест групп в колонках (StoreSize/Store)'
 <- Тест групп в колонках (StoreSize/Store)
 -> Group in columns test (StoreSize/Store)
[OK]     PROPERTIES storeString(s, ss) COLUMNS  'cols1' (ss) HEADER storeHeader(ss)
 <- cols1
 -> cols1
[OK]     PROPERTIES storeString2(s, ss) COLUMNS 'cols1' (ss) HEADER storeHeader2(s, ss) BACKGROUND colorizeMatching(s, ss)
 <- cols1
 -> cols1
[OK] stringEqualsAll (BPSTRING[3] string) = string == BPSTRING[3]('Все');
 <- Все
 -> All
[OK] FORM TestTree 'Тест дерева (элементы навигатора)'
 <- Тест дерева (элементы навигатора)
 -> Tree test (navigator elements)
[OK] FORM TestExpandables 'Тест Expandables'
 <- Тест Expandables
 -> Expandables test
[OK] FORM TestAggr 'Тест агрегаций'
 <- Тест агрегаций
 -> Aggregation test
[OK] FORM TestHeaders 'Тест заголовков'
 <- Тест заголовков
 -> Headers test
[OK]         FILTER '{showhuge}' storeIsHuge(s) 'F10'
 <- {showhuge}' storeIsHuge(s) 'F10
 -> {showhuge}' storeIsHuge(s) 'F10
[OK] FORM TestHotkeys 'Тест хоткеев'
 <- Тест хоткеев
 -> Hotkey test
[OK]         FILTER 'Показывать только огромные склады' storeIsHuge(s) 'F7'
 <- Показывать только огромные склады' storeIsHuge(s) 'F7
 -> Show only huge warehouses' storeIsHuge(s) 'F7
[OK]         FILTER 'Показывать только огромные склады' storeIsHuge(s) 'F3'
 <- Показывать только огромные склады' storeIsHuge(s) 'F3
 -> Show only huge warehouses' storeIsHuge(s) 'F3
[OK]         FILTER 'Показывать только большие склады' storeIsBig(s) 'F9'
 <- Показывать только большие склады' storeIsBig(s) 'F9
 -> Show only big warehouses' storeIsBig(s) 'F9
[OK]         FILTER 'Показывать только средние склады' storeIsMedium(s) 'F10'
 <- Показывать только средние склады' storeIsMedium(s) 'F10
 -> Show only medium warehouses' storeIsMedium(s) 'F10
[OK]         FILTER 'Показывать только маленькие склады' storeIsSmall(s) 'F11'
 <- Показывать только маленькие склады' storeIsSmall(s) 'F11
 -> Show only small warehouses' storeIsSmall(s) 'F11
[OK]         changeKey = 'F4';
 <- F4
 -> F4
[OK]         changeKey = 'F5';
 <- F5
 -> F5
[OK] FORM TestTabs 'Тест табов'
 <- Тест табов
 -> Tab test
[OK]                 caption = 'Панель a';
 <- Панель a
 -> Panel a
[OK]                 caption = 'Панель s';
 <- Панель s
 -> Panel s
[OK] isEditable 'Включить редактирование' () = DATA LOCAL BOOLEAN ();
 <- Включить редактирование
 -> Enable editing
[OK] isReadOnly 'Только чтение' () = TRUE AND NOT isEditable();
 <- Только чтение
 -> Read-only
[OK] FORM TestReadOnlyIf 'Тест read-only'
 <- Тест read-only
 -> Read-only test
[OK]         caption = 'Включить read-only';
 <- Включить read-only
 -> Enable read-only
[OK]             caption = 'Таблицы';
 <- Таблицы
 -> Tables
[OK]             caption = 'Дерево';
 <- Дерево
 -> Tree
[OK]         MESSAGE 'Number: ' + i;
 <- Number: 
 -> Number: 
[OK]         MESSAGE 'String: ' + st;
 <- String: 
 -> String: 
[OK]             MESSAGE 'Tick';
 <- Tick
 -> Tick
[OK] onEditSimple()  { MESSAGE 'Edit!'; }                               
 <- Edit!
 -> Edit!
[OK]     MESSAGE 'Hello world!';
 <- Hello world!
 -> Hello world!
[OK]     MESSAGE name(s) + 'Hello world!';
 <- Hello world!
 -> Hello world!
[OK]     MESSAGE 'On string change';
 <- On string change
 -> On string change
[OK] FORM TestOnActions 'Тест "ON actions"'
 <- Тест "ON actions"
 -> Test "ON actions"
[OK]                   DELETE ON CONTEXTMENU 'Hello world!' onHelloWorld() GRID
 <- Hello world!
 -> Hello world!
[OK]         caption = 'onEditTest';
 <- onEditTest
 -> onEditTest
[OK]         caption = 'onChangeTest';
 <- onChangeTest
 -> onChangeTest
[OK] textToInt 'string->integer' (Store store) = INTEGER(sbpstring(store));
 <- string->integer
 -> string->integer
[OK] longToString 'long->string' (Store store) = BPSTRING[15](slong(store));
 <- long->string
 -> long->string
[OK] nameDate 'name:date' (Store store) = name(store) + ':' + sdate(store);
 <- name:date' (Store store) = name(store) + ':
 -> name:date' (Store store) = name(store) + ':
[OK] sumDoubleInt 'double+integer' (Store store) = sdouble(store) + sinteger(store) CHARWIDTH 25;
 <- double+integer
 -> double+integer
[OK] sumDoubleNumeric 'double+numeric' (Store store) = sdouble(store) + snumeric(store) CHARWIDTH 25;
 <- double+numeric
 -> double+numeric
[OK] sumNumericInt 'numeric+integer' (Store store) = snumeric(store) + sinteger(store) CHARWIDTH 25;
 <- numeric+integer
 -> numeric+integer
[OK] sumIntLong 'integer+long' (Store store) = sinteger(store) + slong(store) CHARWIDTH 25;
 <- integer+long
 -> integer+long
[OK] sumStringBoolean 'name:boolean' (Store store) = name(store) + ':' + sboolean(store) CHARWIDTH 25;
 <- name:boolean' (Store store) = name(store) + ':
 -> name:boolean' (Store store) = name(store) + ':
[OK] sumTextInteger 'text+integer' (Store store) = stext(store) + sinteger(store) CHARWIDTH 25;
 <- text+integer
 -> text+integer
[OK] sumNameString 'name+string' (Store store) = name(store) + sbpstring(store) CHARWIDTH 25;
 <- name+string
 -> name+string
[OK] subDoubleInt 'double-integer' (Store store) = sdouble(store) - sinteger(store) CHARWIDTH 25;
 <- double-integer
 -> double-integer
[OK] subDoubleNumeric 'double-numeric' (Store store) = sdouble(store) - snumeric(store) CHARWIDTH 25;
 <- double-numeric
 -> double-numeric
[OK] subNumericInt 'numeric-integer' (Store store) = snumeric(store) - sinteger(store) CHARWIDTH 25;
 <- numeric-integer
 -> numeric-integer
[OK] subIntLong 'integer-long' (Store store) = sinteger(store) - slong(store) CHARWIDTH 25;
 <- integer-long
 -> integer-long
[OK] multDoubleInt 'double*integer' (Store store) = sdouble(store) * sinteger(store) CHARWIDTH 25;
 <- double*integer
 -> double*integer
[OK] multDoubleNumeric 'double*numeric' (Store store) = sdouble(store) * snumeric(store) CHARWIDTH 25;
 <- double*numeric
 -> double*numeric
[OK] multNumericInt 'numeric*integer' (Store store) = snumeric(store) * sinteger(store) CHARWIDTH 25;
 <- numeric*integer
 -> numeric*integer
[OK] multIntLong 'integer*long' (Store store) = sinteger(store) * slong(store) CHARWIDTH 25;
 <- integer*long
 -> integer*long
[OK] concatNull(Store store) = name(store) + ', ' + sbpstring(store) + ', ' + slong(store);
 <- , ' + sbpstring(store) + ', 
 -> , ' + sbpstring(store) + ', 
[OK] concatNotNull(Named store) = CONCAT ', ', name(store), sbpstring(store), slong(store);
 <- , 
 -> , 
[OK] concatToText(Named store) = CONCAT ', ', stext(store), name(store), sbpstring(store), slong(store);
 <- , 
 -> , 
[OK] concatToVar(Named store) = CONCAT ', ', name(store), sbpstring(store), slong(store), '<const>' IF store IS Store;
 <- , ', name(store), sbpstring(store), slong(store), '<const>
 -> , ', name(store), sbpstring(store), slong(store), '<const>
[OK] concatVarNull(Store store) =  'name: ' + name(store) + '; long: ' + slong(store) + '; string: ' + sbpstring(store);
 <- name: ' + name(store) + '; long: ' + slong(store) + '; string: 
 -> name: ' + name(store) + '; long: ' + slong(store) + '; string: 
[OK] concatVarNotNull(Named store) = CONCAT '', 'name: ' IF store IS Store, name(store), '; long: ' IF store IS Store, slong(store), '; string: ' IF store IS Store, sbpstring(store);
 <- ', 'name: ' IF store IS Store, name(store), '; long: ' IF store IS Store, slong(store), '; string: 
 -> ', 'name: ' IF store IS Store, name(store), '; long: ' IF store IS Store, slong(store), '; string: 
[OK] FORM TestOperators 'Тест операторов CAST, CONCAT, "+-*"'
 <- Тест операторов CAST, CONCAT, "+-*"
 -> Test of operators CAST, CONCAT, "+ - *"
[OK]             caption = 'cast, concat';
 <- cast, concat
 -> cast, concat
[OK]             caption = 'sum';
 <- sum
 -> sum
[OK]             caption = 'sub';
 <- sub
 -> sub
[OK]             caption = 'mult';
 <- mult
 -> mult
[OK] FORM TestLayout 'Тест Layout'
 <- Тест Layout
 -> Layout test
[OK]             caption = 'Сплиты';
 <- Сплиты
 -> Splits
[OK]             caption = 'Заполнение';
 <- Заполнение
 -> Filling
[OK]                 caption = 'Вертикальное';
 <- Вертикальное
 -> Vertical
[OK]                 caption = 'Горизонтальное';
 <- Горизонтальное
 -> Horizontal
[OK]                 caption = 'Поровну';
 <- Поровну
 -> Equally
[OK]                 MOVE PROPERTY(st7) { caption='short'; fill = 1; panelCaptionAbove=TRUE; }  
 <- short
 -> short
[OK]                 MOVE PROPERTY(st8) { caption='this caption is much loooooonger than the first one'; fill = 1; panelCaptionAbove=TRUE; }
 <- this caption is much loooooonger than the first one
 -> this caption is much loooooonger than the first one
[OK] //        MESSAGE 'FOUND: ' + name(dialogBarcodeArticle()) + '; current: ' + name(article);
 <- FOUND: ' + name(dialogBarcodeArticle()) + '; current: 
 -> FOUND: ' + name(dialogBarcodeArticle()) + '; current: 
[OK] //        MESSAGE 'NOT FOUND: current: ' + name(article);
 <- NOT FOUND: current: 
 -> NOT FOUND: current: 
[OK] addDetailInputBarcode 'Ввод штрихкода :' (article) = DATA LOCAL BPSTRING[15] (Article) TOOLBAR CHANGEKEY 'F4' EVENTID 'SCANNER'
 <- Ввод штрихкода :' (article) = DATA LOCAL BPSTRING[15] (Article) TOOLBAR CHANGEKEY 'F4' EVENTID 'SCANNER
 -> Barcode input:' (article) = DATA LOCAL BPSTRING[15] (Article) TOOLBAR CHANGEKEY 'F4' EVENTID 'SCANNER
[OK] FORM TestRequest 'Тест RequestInput'
 <- Тест RequestInput
 -> RequestInput test
[OK] CONSTRAINT storeSize(contextStore(Article article)) != StoreSize.huge AND storeSize(contextStore(article)) != StoreSize.big CHECKED MESSAGE 'Article\'s contextStore must be huge or big';
 <- Article\'s contextStore must be huge or big
 -> Article\'s contextStore must be huge or big
[OK] barcodeMoreThanSome(Article article) = barcode(article AS Article) > '3';
 <- 3
 -> 3
[OK] FORM TestContextFilters 'Тест ContextFilters'
 <- Тест ContextFilters
 -> ContextFilters test
[OK]     PROPERTY(csn1) { caption='Default ON CHANGE'; }
 <- Default ON CHANGE
 -> Default ON CHANGE
[OK]     PROPERTY(csn2) { caption='Custom ON CHANGE'; }
 <- Custom ON CHANGE
 -> Custom ON CHANGE
[OK]     PROPERTY(csn3) { caption='Default ON CHANGE'; }
 <- Default ON CHANGE
 -> Default ON CHANGE
[OK]     PROPERTY(csn4) { caption='Custom ON CHANGE'; }
 <- Custom ON CHANGE
 -> Custom ON CHANGE
[OK] FORM TestShowIfs 'Тест ShowIfs'
 <- Тест ShowIfs
 -> ShowIfs test
[OK]         FILTER 'int(товар) == 12' ainteger(a) == 12 'F8'
 <- int(товар) == 12' ainteger(a) == 12 'F8
 -> int(product) == 12' ainteger(a) == 12 'F8
[OK]         FILTER 'int(товар) == 13' ainteger(a) == 13 'F9'
 <- int(товар) == 13' ainteger(a) == 13 'F9
 -> int(product) == 13' ainteger(a) == 13 'F9
[OK]         FILTER 'long(товар) == 12' along(a) == 12 'F10'
 <- long(товар) == 12' along(a) == 12 'F10
 -> long(product) == 12' along(a) == 12 'F10
[OK] FORM TestQuickFilter 'Тест QuickFilter'
 <- Тест QuickFilter
 -> QuickFilter test
[OK] FORM TestQuickSearch 'Тест QuickSearch'
 <- Тест QuickSearch
 -> QuickSearch test
[OK] FORM TestImage 'Тест Image'
 <- Тест Image
 -> Image test
[OK]         MOVE PROPERTY(si1) { caption = ''; fill = 1; };
 <- 
 -> 
[OK] FORM TestMargins 'Тест Margins'
 <- Тест Margins
 -> Margins test
[OK]         caption = 'Склад (панель)';
 <- Склад (панель)
 -> Warehouse (panel)
[OK] FORM TestToolbars 'Тест Toolbars'
 <- Тест Toolbars
 -> Toolbars test
[OK] FORM TestPartition 'Тест Partition'
 <- Тест Partition
 -> Partition test
[OK] FORM TestFocus 'Тест Focus'
 <- Тест Focus
 -> Focus test
[OK] focusStoreName 'Перенести фокус на name(s)'()  { ACTIVATE PROPERTY TestFocus.name(s); }
 <- Перенести фокус на name(s)
 -> Move focus to name (s)
[OK] FORM TestRichText 'Тест RichText'
 <- Тест RichText
 -> RichText test
[OK] FORM TestLabelWidth 'Тест LabelWidth'
 <- Тест LabelWidth
 -> LabelWidth test
[OK] FORM TestColumns 'Тест групп в колонках (Store/Article)'
 <- Тест групп в колонках (Store/Article)
 -> Group in columns test (Store/Article)
[OK]     PROPERTIES(s, a) COLUMNS 'store' (s) HEADER name(s) sainteger
 <- store
 -> store
[OK] FORM TestShowIfInTreeAndContainers 'Тест ShowIf (tree & containers)'
 <- Тест ShowIf (tree & containers)
 -> ShowIf test (tree & containers)
[OK]             caption = 'some1';
 <- some1
 -> some1
[OK]                 caption = 'some2';
 <- some2
 -> some2
[OK]                 caption = 'some3';
 <- some3
 -> some3
[OK]                 caption = 'some4';
 <- some4
 -> some4
[OK]                 caption = 'some5';
 <- some5
 -> some5
[OK]                 caption = 'some6';
 <- some6
 -> some6
[OK]                 caption = 'some7';
 <- some7
 -> some7
[OK] FORM TestDisappearingActon 'Тест исчезающей кнопки' AUTOREFRESH 1
 <- Тест исчезающей кнопки
 -> Disappearing button test
[OK] FORM TestSessionProps 'Тест передачи значений между сессиями'
 <- Тест передачи значений между сессиями
 -> Test for passing values between sessions
[OK]                 ssbpstring(s) <- '<value from new session>';
 <- <value from new session>
 -> <value from new session>
[OK]         ssbpstring(s) <- 'some value';
 <- some value
 -> some value
[OK]         MESSAGE 'Before: ' + ssbpstring(s);
 <- Before: 
 -> Before: 
[OK]         MESSAGE 'After: ' + ssbpstring(s);
 <- After: 
 -> After: 
[OK]     ssbpstring(s) <- '<value from top session>';
 <- <value from top session>
 -> <value from top session>
[OK]             ssbpstring(s) <- '<value from nested session>';
 <- <value from nested session>
 -> <value from nested session>
[OK] testAddInNestedSession 'Добавить группу товаров'(ArticleGroup parentGroup)  { 
 <- Добавить группу товаров
 -> Add product group
[OK] FORM TestNestedSessions 'Тест вложенных сессий'
 <- Тест вложенных сессий
 -> Nested sessions test
[OK] FORM TestExtendFilterGroup 'Тест EXTEND FilterGroup'
 <- Тест EXTEND FilterGroup
 -> EXTEND FilterGroup test
[OK]         FILTER 'SMALL Stores' storeIsSmall(s) 'F9'
 <- SMALL Stores' storeIsSmall(s) 'F9
 -> SMALL Stores' storeIsSmall(s) 'F9
[OK]         FILTER 'MEDIUM Stores' storeIsMedium(s) 'F10'
 <- MEDIUM Stores' storeIsMedium(s) 'F10
 -> MEDIUM Stores' storeIsMedium(s) 'F10
[OK]         FILTER 'BIG Stores' storeIsBig(s) 'F11'
 <- BIG Stores' storeIsBig(s) 'F11
 -> BIG Stores' storeIsBig(s) 'F11
[OK]         FILTER 'HUGE Stores' storeIsHuge(s) 'F12'
 <- HUGE Stores' storeIsHuge(s) 'F12
 -> HUGE Stores' storeIsHuge(s) 'F12
[OK] FORM TestHTMLInReports 'Test HTML in reports'
 <- Test HTML in reports
 -> Test HTML in reports
[OK] FORM TestKeepSessionProps 'Test LOCAL NESTED'
 <- Test LOCAL NESTED
 -> Test LOCAL NESTED
[OK] //    MESSAGE 'Begin';
 <- Begin
 -> Begin
[OK]     name(s) <- 'name from action';
 <- name from action
 -> name from action
[OK]         name(a) <- 'name from action ' + i();
 <- name from action 
 -> name from action 
[OK]     name(s) <- 'name from action';
 <- name from action
 -> name from action
[OK]     name(s) <- 'name from action';
 <- name from action
 -> name from action
[OK]     name(s) <- 'name from action';
 <- name from action
 -> name from action
[OK] //    MESSAGE 'End';
 <- End
 -> End
[OK]     name(x) <- 'name from action';
 <- name from action
 -> name from action
[OK]     name(x) <- 'name from action';
 <- name from action
 -> name from action
[OK]     name(x) <- 'name from action';
 <- name from action
 -> name from action
[OK]     name(x) <- 'name from action';
 <- name from action
 -> name from action
[OK] CONSTRAINT f(A a) > g(a) MESSAGE 'Forbidden';
 <- Forbidden
 -> Forbidden
[OK] //tstCustom  INTERNAL  'samples.TestCustomActionProperty' ();
 <- samples.TestCustomActionProperty
 -> samples.TestCustomActionProperty
[OK] //externalDB = EXTERNAL DB 'jdbc:($1)://($2)/eqs?user=root&password=' EXEC 'select ($3), date from history' TO testFile;
 <- jdbc:($1)://($2)/eqs?user=root&password=' EXEC 'select ($3), date from history
 -> jdbc:($1)://($2)/eqs?user=root&password=' EXEC 'select ($3), date from history
[OK] //externalHTTP = EXTERNAL HTTP 'https://www.gastronom.ru/($1)/images/20170418/b7568ebc.jpg' TO testFile, testFile2;
 <- https://www.gastronom.ru/($1)/images/20170418/b7568ebc.jpg
 -> https://www.gastronom.ru/($1)/images/20170418/b7568ebc.jpg
[OK] //    str1(s) <- 'binfiles';
 <- binfiles
 -> binfiles
[OK] //    str1(s) <- 'mysql';
 <- mysql
 -> mysql
[OK] //    str2(s) <- 'localhost';
 <- localhost
 -> localhost
[OK] //    str3(s) <- 'id';
 <- id
 -> id
[OK]             MESSAGE '==2';
 <- ==2
 -> ==2
[OK]         name(s) <- 'name from action';
 <- name from action
 -> name from action
[OK]                 name(s) <- 'name from action';
 <- name from action
 -> name from action
[OK]                     name(s) <- 'name from action';
 <- name from action
 -> name from action
[OK]                 name(s) <- 'name from action';
 <- name from action
 -> name from action
[OK]                         name(s) <- 'name from action';
 <- name from action
 -> name from action
[OK]             name(s) <- 'name from action';
 <- name from action
 -> name from action
[OK]             name(s) <- 'name from action';
 <- name from action
 -> name from action
[OK]             name(s) <- 'name from action';
 <- name from action
 -> name from action
[OK]             name(a) <- 'name from action ' + tttt();
 <- name from action 
 -> name from action 
[OK]         name(s) <- 'name from action';
 <- name from action
 -> name from action
[OK]         name(s) <- 'name from action';
 <- name from action
 -> name from action
[OK]         name(s) <- 'name from action';
 <- name from action
 -> name from action
[OK] FORM TestActionDebugger 'Тест ActionDebugger' 
 <- Тест ActionDebugger
 -> ActionDebugger test
[OK] //path() = 'file:///C:/temp.txt';
 <- file:///C:/temp.txt
 -> file:///C:/temp.txt
[OK] writeA(Store s)  { WRITE file() TO path(s) + 'txt'; } 
 <- txt
 -> txt
[OK] FORM TestReadWrite 'Тест READ/WRITE'
 <- Тест READ/WRITE
 -> READ/WRITE test
[OK] // WINDOW <name> '<caption>' (MENU | PANEL | TREE | TOOLBAR) [ option [, option ...] ]
 <- <caption>
 -> <caption>
[OK] WINDOW objectsWindow 'Объекты' TREE POSITION(0, 6, 20, 64) DRAWROOT;
 <- Объекты
 -> Objects
[OK]     // NEW <name> ['<new caption>'] [((AFTER | BEFORE) <name2>) | FIRST] [WINDOW <new window>];
 <- <новый заголовок>
 -> <new caption>
[OK]     // NEW <name> ['<caption>'] [ACTION <action name>] [((AFTER | BEFORE) <name2>) | FIRST] [WINDOW <window name>] [IMAGE <path to icon>];
 <- <заголовок>
 -> <caption>
[OK]         NEW FOLDER element1 'Element 1' AFTER securityPolicy;
 <- Element 1
 -> Element 1
[OK]         NEW FOLDER element2 'Element 2' BEFORE securityPolicy;
 <- Element 2
 -> Element 2
[OK]         NEW FOLDER outer 'Outer element' {
 <- Outer element
 -> Outer element
[OK]             NEW dictionaries 'Dictionaries' = dictionaries {
 <- Dictionaries
 -> Dictionaries
[OK]         NEW FOLDER testNavigators '-Тестовые навигаторы-' AFTER securityPolicy WINDOW root;
 <- -Тестовые навигаторы-
 -> -Test navigators-
[OK]     testNavigators 'Тестовые навигаторы' {
 <- Тестовые навигаторы
 -> Test navigators
[OK]         NEW ACTION testNavigatorAction 'Показать "По документам" 3 раза'  = testAction[] FIRST;
 <- Показать "По документам" 3 раза
 -> Show "By documents" 3 times
[OK]         MOVE dictionaries 'Словари';
 <- Словари
 -> Dictionaries
[OK]     NEW FOLDER tests 'Тесты' WINDOW toolbar {
 <- Тесты
 -> Tests
[OK] FORM fibForm 'Числа фибоначи'
 <- Числа фибоначи
 -> Fibonacci numbers
[OK] testChange 'testChange' (Newtest t)  { 
 <- testChange
 -> testChange
[OK] FORM newTestForm 'Test Exception'
 <- Test Exception
 -> Test Exception
[OK]     first 'First',
 <- First
 -> First
[OK]     second 'Second',
 <- Second
 -> Second
[OK]     third 'Third'
 <- Third
 -> Third
[OK]      first 'First',
 <- First
 -> First
[OK]      second 'Second',
 <- Second
 -> Second
[OK]      third 'Third'
 <- Third
 -> Third
[OK] FORM TestMultithreading 'Test Multithreading'
 <- Test Multithreading
 -> Test Multithreading
[OK] FORM TestMultithreading2 'Test Multithreading'
 <- Test Multithreading
 -> Test Multithreading
[OK] 	    READ 'file://c:/1.txt' TO zippingFile;
 <- file://c:/1.txt
 -> file://c:/1.txt
[OK] 	    zipping(s) <- zippingFile() WHERE s == '1.txt';
 <- 1.txt
 -> 1.txt
[OK] 	    READ 'file://c:/2.xml' TO zippingFile;
 <- file://c:/2.xml
 -> file://c:/2.xml
[OK] 	    zipping(s) <- zippingFile() WHERE s == '2.xml';
 <- 2.xml
 -> 2.xml
[OK] FORM TestLink 'TestLink'
 <- TestLink
 -> TestLink
[OK] FORM TestScroll 'TestScroll'
 <- TestScroll
 -> TestScroll
[OK]             caption = 'Scroll';
 <- Scroll
 -> Scroll
[OK]             caption = 'No Scroll';
 <- No Scroll
 -> No Scroll
[OK] addIncomeDocument 'Добавить XXX'  { };
 <- Добавить XXX
 -> Add XXX
[OK]         ASK 'Точно?' DO {
 <- Точно?
 -> Are you sure?
[OK] editCIncomeDocument 'Edit C' (IncomeDocument d)  { 
 <- Edit C
 -> Edit C
[OK]         caption = 'Добавить C';
 <- Добавить C
 -> Add C
[OK]         caption = 'Add nested';
 <- Add nested
 -> Add nested
[OK]         caption = 'Add session';
 <- Add session
 -> Add session
[OK]         caption = 'Edit nested';
 <- Edit nested
 -> Edit nested
[OK]         caption = 'Edit session';
 <- Edit session
 -> Edit session
[OK]         caption = 'Delete session';
 <- Delete session
 -> Delete session
[OK]     ASK 'Точно?' DO
 <- Точно?
 -> Are you sure?
[OK] CONSTRAINT dq(s, a) < 10 MESSAGE 'ddd';
 <- ddd
 -> ddd
[OK] FORM TFA1 'TEST 1'
 <- TEST 1
 -> TEST 1
[OK] FORM TFA2 'TEST 2'
 <- TEST 2
 -> TEST 2
[OK] FORM TFA3 'TEST 3'
 <- TEST 3
 -> TEST 3
[OK] //    ASK 'Are you sure?' d=YESNO DO {
 <- Are you sure?
 -> Are you sure?
[OK] //        ASK 'Definitely' IF NOT d DO { 
 <- Definitely
 -> Definitely
[OK] test 'TEST INPUT FILE' ()  { 
 <- TEST INPUT FILE
 -> TEST INPUT FILE
[OK]     EXTERNAL SQL 'jdbc:postgresql://localhost/testdb?user=postgres&password=11111' EXEC 'SELECT x.a,x.b,x.c,x.d FROM $1 x WHERE x.a > $2;' PARAMS a, b TO testExternalResult; 
 <- jdbc:postgresql://localhost/testdb?user=postgres&password=11111' EXEC 'SELECT x.a,x.b,x.c,x.d FROM $1 x WHERE x.a > $2;
 -> jdbc:postgresql://localhost/testdb?user=postgres&password=11111' EXEC 'SELECT x.a,x.b,x.c,x.d FROM $1 x WHERE x.a > $2;
[OK] //    IMPORT XML ROOT 'export' TO xa=a, xb=b, xc=c, xd=d, xs=s FROM t();
 <- export
 -> export
[OK] //    EXTERNAL SQL '$1' EXEC 'SELECT x.a,x.b,x.c,x.d FROM $2 x WHERE x.a > $3;' PARAMS 'jdbc:postgresql://localhost/vitalur?user=postgres&password=11111', t(), 7 TO testExternalResult;
 <- $1' EXEC 'SELECT x.a,x.b,x.c,x.d FROM $2 x WHERE x.a > $3;' PARAMS 'jdbc:postgresql://localhost/vitalur?user=postgres&password=11111
 -> $1' EXEC 'SELECT x.a,x.b,x.c,x.d FROM $2 x WHERE x.a > $3;' PARAMS 'jdbc:postgresql://localhost/vitalur?user=postgres&password=11111
[OK]     EXTERNAL LSF 'http://localhost:7651' EXEC 'Features.testImport[FILE]' PARAMS t();
 <- http://localhost:7651' EXEC 'Features.testImport[FILE]
 -> http://localhost:7651' EXEC 'Features.testImport[FILE]
[OK]     PROPERTIES(a) 'ORDER'=name, barcode=barcode
 <- ORDER
 -> ORDER
[OK] FORM TestRequestInput 'Тест RequestInput'
 <- Тест RequestInput
 -> RequestInput test
[OK]     PROPERTIES (a0) a, 'Add A1'=NEW[A1], 'Add A2'=NEW[A2], EDIT, DELETE
 <- Add A1'=NEW[A1], 'Add A2
 -> Add A1'=NEW[A1], 'Add A2
[OK]     PROPERTIES fltest(), 'TESTCAPTION'=5 ON CHANGE { 
 <- TESTCAPTION
 -> TESTCAPTION
[OK]                                 MESSAGE 'HI'; 
 <- HI
 -> HI
[OK]         caption = 'BQ';    
 <- BQ
 -> BQ
[OK]         caption = 'CQ';    
 <- CQ
 -> CQ
[OK] CLASS Class1 'Class1';   
 <- Class1
 -> Class1
[OK] CLASS Class2 'Class2';
 <- Class2
 -> Class2
[OK] FORM test3 'testForm-3'
 <- testForm-3
 -> testForm-3
[OK] GROUP tgr 'ggf';
 <- ggf
 -> ggf
[OK]         caption = 'dsds';
 <- dsds
 -> dsds
[OK]         caption = 'fdfd';
 <- fdfd
 -> fdfd
[OK]     tst() <- 'dfd     ';
 <- dfd     
 -> dfd     
[OK]     vtst() <- 'bdfd     ';
 <- bdfd     
 -> bdfd     
[OK]     tst2() <- 'fd   ';
 <- fd   
 -> fd   
[OK]     vtst2() <- 'fd   ';
 <- fd   
 -> fd   
[OK]     MESSAGE tst() + ',' + vtst();
 <- ,
 -> ,
[OK]     MESSAGE tst2() + ',' + vtst2();
 <- ,
 -> ,
[OK]     MESSAGE CONCAT ',',tst(),vtst();
 <- ,
 -> ,
[OK]     MESSAGE CONCAT ',',tst2(),vtst2();
 <- ,
 -> ,
[OK]     tst(a) <- 'fggf   ' WHERE a=1;
 <- fggf   
 -> fggf   
[OK]     tst(a) <- 'tggf   ' WHERE a=2;
 <- tggf   
 -> tggf   
[OK] //    vtst(a) <- 'fggf   ' WHERE a=1;
 <- fggf   
 -> fggf   
[OK] //    vtst(a) <- 'tggf   ' WHERE a=2;
 <- tggf   
 -> tggf   
[OK]     MESSAGE 'NOFLEX + : ' + tst(1) + ',' + tst(2);
 <- NOFLEX + : ' + tst(1) + ',
 -> NOFLEX + : ' + tst(1) + ',
[OK]     MESSAGE 'VAR + : ' + vtst(1) + ',' + vtst(2);
 <- VAR + : ' + vtst(1) + ',
 -> VAR + : ' + vtst(1) + ',
[OK]     MESSAGE 'NOFLEX CONCAT : ' + CONCAT ',',tst(1),tst(2);
 <- NOFLEX CONCAT : ' + CONCAT ',
 -> NOFLEX CONCAT : ' + CONCAT ',
[OK]     MESSAGE 'VAR CONCAT : ' + CONCAT ',',vtst(1),vtst(1);
 <- VAR CONCAT : ' + CONCAT ',
 -> VAR CONCAT : ' + CONCAT ',
[OK]     MESSAGE 'NOFLEX GROUPC : ' + (GROUP CONCAT tst(a),',');
 <- NOFLEX GROUPC : ' + (GROUP CONCAT tst(a),',
 -> NOFLEX GROUPC : ' + (GROUP CONCAT tst(a),',
[OK]     MESSAGE 'VAR GROUPC : ' + (GROUP CONCAT vtst(a),',');
 <- VAR GROUPC : ' + (GROUP CONCAT vtst(a),',
 -> VAR GROUPC : ' + (GROUP CONCAT vtst(a),',
[OK]     EXTERNAL LSF 'http://localhost:7651' EXEC 'Features.tstexp[]' TO result, xml, dbf;
 <- http://localhost:7651' EXEC 'Features.tstexp[]
 -> http://localhost:7651' EXEC 'Features.tstexp[]
[OK]         pattern='dd.MM';
 <- dd.MM
 -> dd.MM
[OK]         pattern='dd.MM';
 <- dd.MM
 -> dd.MM
[OK] CLASS XA 'XA';
 <- XA
 -> XA
[OK] CLASS XADetail 'XADetail';
 <- XADetail
 -> XADetail
[OK] CLASS XB 'XB' : XBC;
 <- XB
 -> XB
[OK] CLASS XBDetail 'XBDetail' : XBCDetail;
 <- XBDetail
 -> XBDetail
[OK] CLASS XC 'XC' : XBC;
 <- XC
 -> XC
[OK] CLASS XCDetail 'XBDetail' : XBCDetail;
 <- XBDetail
 -> XBDetail
[OK] CLASS XADetailLog 'Log';
 <- Log
 -> Log
[OK]     yes 'yes',
 <- yes
 -> yes
[OK]     no 'no',
 <- no
 -> no
[OK]     maybe 'maybe'
 <- maybe
 -> maybe
[OK]     htmlLinkInTab(HTMLLINK('https://luxsoft.by/'));
 <- https://luxsoft.by/
 -> https://luxsoft.by/
[OK]     EXTERNAL HTTP 'http://localhost:7651/exec?action=doSomething&p=$2&p=$1' PARAMS '1','2';
 <- http://localhost:7651/exec?action=doSomething&p=$2&p=$1' PARAMS '1','2
 -> http://localhost:7651/exec?action=doSomething&p=$2&p=$1' PARAMS '1','2
[OK]     headers(TEXT h) <- 'xxx' WHERE h = 'h1';
 <- xxx' WHERE h = 'h1
 -> xxx' WHERE h = 'h1
[OK]     headers(TEXT h) <- 'yyy' WHERE h = 'h2';
 <- yyy' WHERE h = 'h2
 -> yyy' WHERE h = 'h2
[OK]     cookies(TEXT c) <- '12345' WHERE c = 'c1';
 <- 12345' WHERE c = 'c1
 -> 12345' WHERE c = 'c1
[OK]     cookies(TEXT c) <- '09876' WHERE c = 'c2';
 <- 09876' WHERE c = 'c2
 -> 09876' WHERE c = 'c2
[OK] //    EXTERNAL HTTP 'https://en.wikipedia.org/wiki/File:Example.jpg' HEADERS headers[TEXT] COOKIES cookies[TEXT] HEADERSTO headersTo COOKIESTO cookiesTo;
 <- https://en.wikipedia.org/wiki/File:Example.jpg
 -> https://en.wikipedia.org/wiki/File:Example.jpg
[OK] 	MESSAGE headersTo('Content-language');
 <- Content-language
 -> Content-language
[OK] 	MESSAGE cookiesTo('c1');
 <- c1
 -> c1
[OK] IF failedHttp() THEN MESSAGE 'Alarm!'; ELSE MESSAGE 'OK';
 <- Alarm!'; ELSE MESSAGE 'OK
 -> Alarm!'; ELSE MESSAGE 'OK
[OK] GROUP declaration EXTID 'gd:GoodsDeclaration';
 <- gd:GoodsDeclaration
 -> gd:GoodsDeclaration
[OK] GROUP shipment EXTID 'cacdo:DeclarationGoodsShipmentDetails';//: declaration;
 <- cacdo:DeclarationGoodsShipmentDetails
 -> cacdo:DeclarationGoodsShipmentDetails
[OK]     OBJECTS d = INTEGER EXTID 'cacdo:DeclarationGoodsItemDetails' IN shipment
 <- cacdo:DeclarationGoodsItemDetails
 -> cacdo:DeclarationGoodsItemDetails
[OK]     PROPERTIES(d) order EXTID 'casdo:ConsignmentItemOrdinal'
 <- casdo:ConsignmentItemOrdinal
 -> casdo:ConsignmentItemOrdinal
[OK]         MESSAGE 'count=' + (GROUP SUM 1 IF order(INTEGER i));
 <- count=
 -> count=
[OK] resourcePath() = 'e:/work/2/assets/';
 <- e:/work/2/assets/
 -> e:/work/2/assets/
[OK]     READ 'file:' + resourcePath() + na TO exportFile;
 <- file:
 -> file:
[OK] GROUP bodyS EXTID 'S:Body';
 <- S:Body
 -> S:Body
[OK] GROUP getDocumentsResponse EXTID 'GetDocumentsResponse' : bodyS;
 <- GetDocumentsResponse
 -> GetDocumentsResponse
[OK] GROUP getDocumentsResult EXTID 'GetDocumentsResult' : getDocumentsResponse;
 <- GetDocumentsResult
 -> GetDocumentsResult
[OK]    PROPERTIES() IN getDocumentsResult succesful EXTID 'Succesful',
 <- Succesful
 -> Succesful
[OK]                                       message EXTID 'Message',
 <- Message
 -> Message
[OK]                                       errorCode EXTID 'ErrorCode'
 <- ErrorCode
 -> ErrorCode
crowdout/strings/tryonline/src (sources: crowdin/strings/tryonline/src) -> samples/tryonline/src - translated files:
crowdout/strings/tryonline/src/main/lsfusion (sources: crowdin/strings/tryonline/src/main/lsfusion) -> samples/tryonline/src/main/lsfusion - translated files:

In samples/tryonline/src/main/lsfusion/InstallLog.lsf of Category strings - Number of lines: 33; Number of occurances: 1

[OK] FORM installLog 'Журнал инсталляций'
 <- Журнал инсталляций
 -> Installations log

In samples/tryonline/src/main/lsfusion/Main.lsf of Category strings - Number of lines: 243; Number of occurances: 50

[OK] CLASS Server 'Сервер';
 <- Сервер
 -> Server
[OK] text 'Текст ответа' = DATA TEXT (Server, LONG);
 <- Текст ответа
 -> Response text
[OK] baseDir 'Директорий запуска' = DATA BPSTRING[50] ();
 <- Директорий запуска
 -> Launch directory
[OK] examplesDBDir 'Директорий примеров (СУБД)' = DATA BPSTRING[50] ();
 <- Директорий примеров (СУБД)
 -> Sample directory (DBMS)
[OK] examplesPlatformDir 'Директорий примеров (Платформа)' = DATA BPSTRING[50] ();
 <- Директорий примеров (Платформа)
 -> Sample directory (Platform)
[OK] dbPassword 'Пароль к базе' = DATA BPSTRING[50] () CHARWIDTH 10 NOFLEX; // for postgres user
 <- Пароль к базе
 -> Database password
[OK] serverStartCmd 'Команда запуска сервера' = DATA STRING[1000] (); // will be started from some basedir subfolder 
 <- Команда запуска сервера
 -> Server start command
[OK] serverEncoding 'Кодировка консоли' = DATA BPSTRING[10] (); // server console output encoding
 <- Кодировка консоли
 -> Console encoding
[OK] minPort 'Мин. порт' = DATA LONG (); 
 <- Мин. порт
 -> Min. port
[OK] maxPort 'Макс. порт' = DATA LONG (); 
 <- Макс. порт
 -> Max. port
[OK]         baseDir() <- './box';
 <- ./box
 -> ./box
[OK]         serverStartCmd() <- 'java -Dlsfusion.server.lightstart=true -Dlsfusion.server.devmode=true -cp .:../server.jar lsfusion.server.logics.BusinessLogicsBootstrap'; // windows : -> ; no double quotes in linux
 <- java -Dlsfusion.server.lightstart=true -Dlsfusion.server.devmode=true -cp .:../server.jar lsfusion.server.logics.BusinessLogicsBootstrap
 -> java -Dlsfusion.server.lightstart=true -Dlsfusion.server.devmode=true -cp .:../server.jar lsfusion.server.logics.BusinessLogicsBootstrap
[OK]         serverEncoding() <- 'UTF-8'; // for windows may be single-byte (for example cp1251)
 <- UTF-8
 -> UTF-8
[OK]         dbPassword() <- '11111';    
 <- 11111
 -> 11111
[OK] runProcess INTERNAL 'RunProcessActionProperty' (Server, TEXT, TEXT, TEXT);
 <- RunProcessActionProperty
 -> RunProcessActionProperty
[OK] killProcess INTERNAL 'KillProcessActionProperty' (Server);
 <- KillProcessActionProperty
 -> KillProcessActionProperty
[OK] serverDir(Server server) = baseDir() + '/' + LONG(server);
 <- /
 -> /
[OK] dbName(Server server) = 'db' + LONG(server);
 <- db
 -> db
[OK] createServer 'Создать сервер' (Server server) {
 <- Создать сервер
 -> Create server
[OK]     confDir() <- serverDir(server) + '/conf';
 <- /conf
 -> /conf
[OK]     copy(baseDir() + '/log4j.xml', 'file://' + serverDir(server) + '/log4j.xml');
 <- /log4j.xml', 'file://' + serverDir(server) + '/log4j.xml
 -> /log4j.xml', 'file://' + serverDir(server) + '/log4j.xml
[OK]     WRITE RAWFILE('db.server=localhost'+'\n'+
 <- db.server=localhost'+'\n
 -> db.server=localhost'+'\n
[OK]                   'db.name='+dbName(server)+'\n'+
 <- db.name='+dbName(server)+'\n
 -> db.name='+dbName(server)+'\n
[OK]                   'db.user=postgres'+'\n'+
 <- db.user=postgres'+'\n
 -> db.user=postgres'+'\n
[OK]                   'db.password='+dbPassword()+'\n'+                                                              
 <- db.password='+dbPassword()+'\n
 -> db.password='+dbPassword()+'\n
[OK]                   'logics.topModule=Main\n'+
 <- logics.topModule=Main\n
 -> logics.topModule=Main\n
[OK]                   'rmi.port='+port()) TO 'file://' + confDir() + '/settings.properties';
 <- rmi.port='+port()) TO 'file://' + confDir() + '/settings.properties
 -> rmi.port='+port()) TO 'file://' + confDir() + '/settings.properties
[OK] deleteServer 'Удалить сервер' (Server server) {
 <- Удалить сервер
 -> Delete server
[OK]     EXTERNAL SQL 'jdbc:postgresql://localhost/tryonline?user=postgres&password='+dbPassword() EXEC 'DROP DATABASE ' + dbName(server) + ';';
 <- jdbc:postgresql://localhost/tryonline?user=postgres&password='+dbPassword() EXEC 'DROP DATABASE ' + dbName(server) + ';
 -> jdbc:postgresql://localhost/tryonline?user=postgres&password='+dbPassword() EXEC 'DROP DATABASE ' + dbName(server) + ';
[OK] runServer 'Запустить сервер' (Server server, TEXT code) {
 <- Запустить сервер
 -> Start server
[OK]         WRITE RAWFILE(TEXTFILE('MODULE Main; ' + code)) TO 'file://' + serverDir(server) + '/Main.lsf';
 <- MODULE Main; ' + code)) TO 'file://' + serverDir(server) + '/Main.lsf
 -> MODULE Main; ' + code)) TO 'file://' + serverDir(server) + '/Main.lsf
[OK] killServer 'Остановить сервер' (Server server) {
 <- Остановить сервер
 -> Stop server
[OK]     loadDefaultScheduledTask ('Остановка неиспользованных серверов', 2014_07_01_01:00, 60, SchedulerStartType.afterStart);
 <- Остановка неиспользованных серверов
 -> Stopping unused servers
[OK]     loadDefaultScheduledTaskDetail ('Остановка неиспользованных серверов', 1, 'Main.stopUnusedServers[]');
 <- Остановка неиспользованных серверов', 1, 'Main.stopUnusedServers[]
 -> Stopping unused servers', 1, 'Main.stopUnusedServers[]
[OK]                         text=(GROUP CONCAT newAnswers(LONG answer),'' ORDER answer);                          
 <- 
 -> 
[OK] FORM servers 'Сервера'
 <- Сервера
 -> Servers
[OK]     OBJECTS a 'Ответы' = LONG
 <- Ответы
 -> Responses
[OK] caption 'Заголовок' = DATA STRING (Example);
 <- Заголовок
 -> Header
[OK] path 'Путь' = DATA STRING (Example);
 <- Путь
 -> Path
[OK] mode 'Режим' = DATA INTEGER (Example);
 <- Режим
 -> Mode
[OK] order 'Порядок' = DATA INTEGER (Example);
 <- Порядок
 -> Order
[OK] exPath 'Путь' = DATA STRING (Example, LONG); 
 <- Путь
 -> Path
[OK] FORM examples 'Примеры'
 <- Примеры
 -> Examples
[OK]     FOR run = 'DFKRJKJSIEIJKDFJI' DO {
 <- DFKRJKJSIEIJKDFJI
 -> DFKRJKJSIEIJKDFJI
[OK]         readedText() <- regexpReplace(readedText(), '//#'+block+' end.*\\n', run, 'n'); // we need \\n to match \n itself
 <- //#'+block+' end.*\\n', run, 'n
 -> //#'+block+' end.*\\n', run, 'n
[OK]                 removeTextBeforeBlockEnd('module');
 <- module
 -> module
[OK]                     removeTextBeforeBlockEnd('header');
 <- header
 -> header
[OK]                     text() <- text() + '\n' + readedText(); 
 <- \n
 -> \n
[OK]                 text() <- regexpReplace(text(), '//#.*(\\n)?', '', 'ng');
 <- //#.*(\\n)?', '', 'ng
 -> //#.*(\\n)?', '', 'ng
[OK]                 removeTextBeforeBlockEnd('header');
 <- header
 -> header
crowdout/strings/tryonline/src/main/lsfusion/tryonline (sources: crowdin/strings/tryonline/src/main/lsfusion/tryonline) -> samples/tryonline/src/main/lsfusion/tryonline - translated files:

In samples/tryonline/src/main/lsfusion/tryonline/HelloWorld.lsf of Category strings - Number of lines: 15; Number of occurances: 4

[OK] showHelloWorld 'Показать сообщение' () {
 <- Показать сообщение
 -> Show message
[OK]     MESSAGE 'Hello world!';
 <- Hello world!
 -> Hello world!
[OK] FORM formHelloWorld 'Форма'
 <- Форма
 -> Form
[OK]     PROPERTIES 'Сообщение' = 'Hello world!';
 <- Сообщение' = 'Hello world!
 -> Message' = 'Hello world!

In samples/tryonline/src/main/lsfusion/tryonline/MapCalendar.lsf of Category strings - Number of lines: 64; Number of occurances: 8

[OK] name(Element pt) <- (CASE WHEN pt IS Point THEN 'Точка' ELSE 'Полигон') + ' ' + LONG(pt) WHEN SET(pt IS Element);
 <- Точка' ELSE 'Полигон') + ' 
 -> Dot' ELSE 'Polygon') + ' 
[OK] polygon(Area a) <- '48.885488755596874 2.266616821289063,48.83941303819501 2.2714233398437504,48.81635927146624 2.338027954101563,48.823140892101684 2.4060058593750004,48.869683240775785 2.4183654785156254,48.90354608612111 2.355194091796875' WHEN SET (a IS Area); // minsk
 <- 48.885488755596874 2.266616821289063,48.83941303819501 2.2714233398437504,48.81635927146624 2.338027954101563,48.823140892101684 2.4060058593750004,48.869683240775785 2.4183654785156254,48.90354608612111 2.355194091796875
 -> 48.885488755596874 2.266616821289063,48.83941303819501 2.2714233398437504,48.81635927146624 2.338027954101563,48.823140892101684 2.4060058593750004,48.869683240775785 2.4183654785156254,48.90354608612111 2.355194091796875
[OK] FORM map 'Карта'
 <- Карта
 -> Map
[OK]     PROPERTIES color = RGB(255, 0, 0) IF isInAnyArea(o), inParis '' = 'I am ' + (CASE WHEN isInAnyArea(o) THEN '' ELSE 'not ') + 'in Paris. Drag me' SHOWIF o IS Point PANEL 
 <- ' = 'I am ' + (CASE WHEN isInAnyArea(o) THEN '' ELSE 'not ') + 'in Paris. Drag me
 -> ' = 'I am ' + (CASE WHEN isInAnyArea(o) THEN '' ELSE 'not ') + 'in Paris. Drag me
[OK]     PROPERTIES (o) 'Добавить точку' = NEW[Point], 'Добавить область' = NEW[Area], DELETE
 <- Добавить точку' = NEW[Point], 'Добавить область
 -> Add point' = NEW[Point], 'Add area
[OK]     	EXTERNAL SQL 'LOCAL' EXEC 'CREATE EXTENSION postgis';
 <- LOCAL' EXEC 'CREATE EXTENSION postgis
 -> LOCAL' EXEC 'CREATE EXTENSION postgis
[OK] name(Event e) <- 'Событие' + ' ' + LONG(e) WHEN SET(e IS Event);
 <- Событие' + ' 
 -> Event' + ' 
[OK] FORM calendar 'Календарь'
 <- Календарь
 -> Calendar
crowdout/strings/betgame/src/main/lsfusion (sources: crowdin/strings/betgame/src/main/lsfusion) -> samples/betgame/src/main/lsfusion - translated files:

In samples/betgame/src/main/lsfusion/BetGame.lsf of Category strings - Number of lines: 149; Number of occurances: 42

[OK] CLASS Team 'Команда';
 <- Команда
 -> Team
[OK] name 'Название' = DATA ISTRING[50] (Team) IN id;
 <- Название
 -> Name
[OK] FORM team 'Команда'
 <- Команда
 -> Team
[OK] FORM teams 'Команды'
 <- Команды
 -> Teams
[OK] CLASS Match 'Матч';
 <- Матч
 -> Match
[OK] dateTime 'Начало матча' = DATA DATETIME (Match) NONULL IN id;
 <- Начало матча
 -> Match start
[OK] CONSTRAINT CHANGED(dateTime(Match m)) AND PREV(dateTime(m)) AND NOT DROPPED(m IS Match) MESSAGE 'Запрещено изменять время начала матча';
 <- Запрещено изменять время начала матча
 -> It is forbidden to change the start time of the match
[OK] homeTeam 'Хозяева' = DATA Team (Match) NONULL;
 <- Хозяева
 -> Hosts
[OK] nameHomeTeam 'Хозяева' (Match m) = name(homeTeam(m)) IN id; 
 <- Хозяева
 -> Hosts
[OK] awayTeam 'Гости' = DATA Team (Match) NONULL;
 <- Гости
 -> Guests
[OK] nameAwayTeam 'Гости' (Match m) = name(awayTeam(m)) IN id; 
 <- Гости
 -> Guests
[OK] homeScore 'Результат (хозяева)' = DATA INTEGER (Match);
 <- Результат (хозяева)
 -> Result (hosts)
[OK] awayScore 'Результат (гости)' = DATA INTEGER (Match);
 <- Результат (гости)
 -> Result (guests)
[OK] homeScore 'Ставка (хозяева)' = DATA INTEGER (Match, CustomUser);
 <- Ставка (хозяева)
 -> Bet (hosts)
[OK] awayScore 'Ставка (гости)' = DATA INTEGER (Match, CustomUser);
 <- Ставка (гости)
 -> Bet (guests)
[OK] home 'Победа (хозяева)' (Match m) = (GROUP SUM 1 IF homeScore(m, CustomUser c) > awayScore(m, c)) IF started(m);   
 <- Победа (хозяева)
 -> Victory (hosts)
[OK] tie 'Ничья' (Match m) = (GROUP SUM 1 IF homeScore(m, CustomUser c) = awayScore(m, c)) IF started(m);
 <- Ничья
 -> Draw
[OK] away 'Победа (гости)' (Match m) = (GROUP SUM 1 IF homeScore(m, CustomUser c) < awayScore(m, c)) IF started(m);
 <- Победа (гости)
 -> Victory (guests)
[OK] startedHomeScore 'Ставка (хозяева)' (Match m, CustomUser c) = homeScore(m, c) IF started(m);  
 <- Ставка (хозяева)
 -> Bet (hosts)
[OK] startedAwayScore 'Ставка (хозяева)' (Match m, CustomUser c) = awayScore(m, c) IF started(m);  
 <- Ставка (хозяева)
 -> Bet (hosts)
[OK] hasBet 'Сделана ставка' (Match m, CustomUser c) = homeScore(m, c) AND awayScore(m, c);
 <- Сделана ставка
 -> Bet made
[OK] countBets 'Кол-во ставок' (Match m) = GROUP SUM 1 IF hasBet(m, CustomUser c); 
 <- Кол-во ставок
 -> Number of bets
[OK] CONSTRAINT DROPPED(Match m IS Match) AND PREV(countBets(m)) MESSAGE 'Запрещено удалять матч, по которому сделаны ставки';
 <- Запрещено удалять матч, по которому сделаны ставки
 -> It is forbidden to delete a match on which bets were made
[OK] CONSTRAINT CHANGED(homeScore(Match m, CustomUser c)) AND started(m) MESSAGE 'Запрещено изменять результат начавшегося матча';
 <- Запрещено изменять результат начавшегося матча
 -> It is forbidden to change the result of a started match
[OK] CONSTRAINT CHANGED(awayScore(Match m, CustomUser c)) AND started(m) MESSAGE 'Запрещено изменять результат начавшегося матча';
 <- Запрещено изменять результат начавшегося матча
 -> It is forbidden to change the result of a started match
[OK] CONSTRAINT CHANGED(homeScore(Match m)) AND NOT started(m) MESSAGE 'Запрещено изменять счет матча до начала матча';
 <- Запрещено изменять счет матча до начала матча
 -> It is forbidden to change the match score before the match start
[OK] CONSTRAINT CHANGED(awayScore(Match m)) AND NOT started(m) MESSAGE 'Запрещено изменять счет матча до начала матча';
 <- Запрещено изменять счет матча до начала матча
 -> It is forbidden to change the match score before the match start
[OK] currentHomeScore 'Ставка (хозяева)' (Match m) = homeScore(m, currentUser()); 
 <- Ставка (хозяева)
 -> Bet (hosts)
[OK] currentAwayScore 'Ставка (гости)' (Match m) = awayScore(m, currentUser());
 <- Ставка (гости)
 -> Bet (guests)
[OK] cost 'Стоимость' = DATA INTEGER (Match);
 <- Стоимость
 -> Cost
[OK] correctScore 'Правильный счет' (CustomUser c) = GROUP SUM 1 IF correctScore (Match m, c);
 <- Правильный счет
 -> Correct score
[OK] correctDelta 'Правильная разница' (CustomUser c) = GROUP SUM 1 IF correctDelta (Match m, c);
 <- Правильная разница
 -> Correct difference
[OK] correctResult 'Правильный результат' (CustomUser c) = GROUP SUM 1 IF correctResult (Match m, c);
 <- Правильный результат
 -> Correct result
[OK] points 'Кол-во баллов' = CASE
 <- Кол-во баллов
 -> Number of points
[OK] points 'Кол-во баллов' (CustomUser c) = GROUP SUM points(Match m, c); 
 <- Кол-во баллов
 -> Number of points
[OK] points 'Кол-во баллов' (Match m) = GROUP SUM points(m, CustomUser c);
 <- Кол-во баллов
 -> Number of points
[OK] pointsStarted 'Кол-во баллов' (Match m) = points(m) IF started(m); 
 <- Кол-во баллов
 -> Number of points
[OK] score 'Кол-во очков' (Match m, CustomUser c) = NUMERIC[16,4](cost(m) * points(m, c)) / points(m);
 <- Кол-во очков
 -> Number of points
[OK] score 'Кол-во очков' (CustomUser c) = GROUP SUM score(Match m, c); 
 <- Кол-во очков
 -> Number of points
[OK] FORM match 'Матч'
 <- Матч
 -> Match
[OK] FORM matches 'Ставки'
 <- Ставки
 -> Bets
[OK] FORM standings 'Таблица'
 <- Таблица
 -> Table
